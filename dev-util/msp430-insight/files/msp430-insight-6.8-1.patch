diff -urN insight-6.8-1/bfd/archures.c insight-6.8-1-new/bfd/archures.c
--- insight-6.8-1/bfd/archures.c	Mon Feb  4 20:15:50 2008
+++ insight-6.8-1-new/bfd/archures.c	Mon Nov 23 20:29:41 2009
@@ -380,7 +380,13 @@
 .#define bfd_mach_msp14          14
 .#define bfd_mach_msp15          15
 .#define bfd_mach_msp16          16
+.#define bfd_mach_msp20          20
 .#define bfd_mach_msp21          21
+.#define bfd_mach_msp22          22
+.#define bfd_mach_msp23          23
+.#define bfd_mach_msp24          24
+.#define bfd_mach_msp241         241
+.#define bfd_mach_msp26          26
 .#define bfd_mach_msp31          31
 .#define bfd_mach_msp32          32
 .#define bfd_mach_msp33          33
@@ -388,6 +394,9 @@
 .#define bfd_mach_msp42          42
 .#define bfd_mach_msp43          43
 .#define bfd_mach_msp44          44
+.#define bfd_mach_msp46          46
+.#define bfd_mach_msp47          47
+.#define bfd_mach_msp54          54
 .  bfd_arch_xc16x,     {* Infineon's XC16X Series.               *}
 .#define bfd_mach_xc16x         1
 .#define bfd_mach_xc16xl        2
diff -urN insight-6.8-1/bfd/bfd-in2.h insight-6.8-1-new/bfd/bfd-in2.h
--- insight-6.8-1/bfd/bfd-in2.h	Wed Feb 20 16:17:56 2008
+++ insight-6.8-1-new/bfd/bfd-in2.h	Mon Nov 23 20:29:41 2009
@@ -2057,7 +2057,13 @@
 #define bfd_mach_msp14          14
 #define bfd_mach_msp15          15
 #define bfd_mach_msp16          16
+#define bfd_mach_msp20          20
 #define bfd_mach_msp21          21
+#define bfd_mach_msp22          22
+#define bfd_mach_msp23          23
+#define bfd_mach_msp24          24
+#define bfd_mach_msp241         241
+#define bfd_mach_msp26          26
 #define bfd_mach_msp31          31
 #define bfd_mach_msp32          32
 #define bfd_mach_msp33          33
@@ -2065,6 +2071,9 @@
 #define bfd_mach_msp42          42
 #define bfd_mach_msp43          43
 #define bfd_mach_msp44          44
+#define bfd_mach_msp46          46
+#define bfd_mach_msp47          47
+#define bfd_mach_msp54          54
   bfd_arch_xc16x,     /* Infineon's XC16X Series.               */
 #define bfd_mach_xc16x         1
 #define bfd_mach_xc16xl        2
@@ -4324,6 +4333,25 @@
   BFD_RELOC_MSP430_16_BYTE,
   BFD_RELOC_MSP430_2X_PCREL,
   BFD_RELOC_MSP430_RL_PCREL,
+  BFD_RELOC_MSP430X_SRC_BYTE,
+  BFD_RELOC_MSP430X_SRC,
+  BFD_RELOC_MSP430X_DST_BYTE,
+  BFD_RELOC_MSP430X_DST,
+  BFD_RELOC_MSP430X_DST_2ND_BYTE,
+  BFD_RELOC_MSP430X_DST_2ND,
+  BFD_RELOC_MSP430X_PCREL_SRC_BYTE,
+  BFD_RELOC_MSP430X_PCREL_SRC,
+  BFD_RELOC_MSP430X_PCREL_DST_BYTE,
+  BFD_RELOC_MSP430X_PCREL_DST,
+  BFD_RELOC_MSP430X_PCREL_DST_2ND,
+  BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE,
+  BFD_RELOC_MSP430X_S_BYTE,
+  BFD_RELOC_MSP430X_S,
+  BFD_RELOC_MSP430X_D_BYTE,
+  BFD_RELOC_MSP430X_D,
+  BFD_RELOC_MSP430X_PCREL_D,
+  BFD_RELOC_MSP430X_INDXD,
+  BFD_RELOC_MSP430X_PCREL_INDXD,
 
 /* IQ2000 Relocations.  */
   BFD_RELOC_IQ2000_OFFSET_16,
diff -urN insight-6.8-1/bfd/cpu-msp430.c insight-6.8-1-new/bfd/cpu-msp430.c
--- insight-6.8-1/bfd/cpu-msp430.c	Tue Jul  3 16:26:40 2007
+++ insight-6.8-1-new/bfd/cpu-msp430.c	Mon Nov 23 20:29:41 2009
@@ -65,29 +65,56 @@
   /* msp430x16x.  */
   N (16, bfd_mach_msp16, "msp:16", FALSE, & arch_info_struct[7]),
 
+  /* msp430x20x */
+  N (16, bfd_mach_msp20, "msp:20", FALSE, & arch_info_struct[8]),
+
   /* msp430x21x.  */
-  N (16, bfd_mach_msp21, "msp:21", FALSE, & arch_info_struct[8]),
+  N (16, bfd_mach_msp21, "msp:21", FALSE, & arch_info_struct[9]),
+
+  /* msp430x22x */
+  N (16, bfd_mach_msp22, "msp:22", FALSE, & arch_info_struct[10]),
+
+  /* msp430x23x0.  */
+  N (16, bfd_mach_msp23, "msp:23", FALSE, & arch_info_struct[11]),
+
+  /* msp430x24x, msp430x24x1, msp430x2410  */
+  N (16, bfd_mach_msp24, "msp:24", FALSE, & arch_info_struct[12]),
+
+  /* msp430x241x */
+  N (16, bfd_mach_msp241, "msp:241", FALSE, & arch_info_struct[13]),
+
+  /* msp430x26x */
+  N (16, bfd_mach_msp26, "msp:26", FALSE, & arch_info_struct[14]), 
 
   /* msp430x31x.  */
-  N (16, bfd_mach_msp31, "msp:31", FALSE, & arch_info_struct[9]), 
+  N (16, bfd_mach_msp31, "msp:31", FALSE, & arch_info_struct[15]), 
 
   /* msp430x32x.  */
-  N (16, bfd_mach_msp32, "msp:32", FALSE, & arch_info_struct[10]), 
+  N (16, bfd_mach_msp32, "msp:32", FALSE, & arch_info_struct[16]), 
 
   /* msp430x33x.  */
-  N (16, bfd_mach_msp33, "msp:33", FALSE, & arch_info_struct[11]),
+  N (16, bfd_mach_msp33, "msp:33", FALSE, & arch_info_struct[17]),
   
   /* msp430x41x.  */
-  N (16, bfd_mach_msp41, "msp:41", FALSE, & arch_info_struct[12]),
+  N (16, bfd_mach_msp41, "msp:41", FALSE, & arch_info_struct[18]),
 
   /* msp430x42x.  */
-  N (16, bfd_mach_msp42, "msp:42", FALSE, & arch_info_struct[13]),
+  N (16, bfd_mach_msp42, "msp:42", FALSE, & arch_info_struct[19]),
 
   /* msp430x43x.  */
-  N (16, bfd_mach_msp43, "msp:43", FALSE, & arch_info_struct[14]),
+  N (16, bfd_mach_msp43, "msp:43", FALSE, & arch_info_struct[20]),
 
   /* msp430x44x.  */
-  N (16, bfd_mach_msp43, "msp:44", FALSE, NULL)
+  N (16, bfd_mach_msp44, "msp:44", FALSE, & arch_info_struct[21]),
+ 
+  /* msp430x46xx.  */
+  N (20, bfd_mach_msp46, "msp:46", FALSE, & arch_info_struct[22]),
+
+  /* msp430x47x3, 47x4.  */
+  N (16, bfd_mach_msp47, "msp:47", FALSE, & arch_info_struct[23]),
+
+  /* msp430x54xx.  */
+  N (20, bfd_mach_msp54, "msp:54", FALSE, NULL)
 };
 
 const bfd_arch_info_type bfd_msp430_arch =
diff -urN insight-6.8-1/bfd/elf32-msp430.c insight-6.8-1-new/bfd/elf32-msp430.c
--- insight-6.8-1/bfd/elf32-msp430.c	Fri Sep 28 10:43:45 2007
+++ insight-6.8-1-new/bfd/elf32-msp430.c	Mon Nov 23 20:29:41 2009
@@ -90,7 +90,7 @@
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
 
-  /* A 16 bit absolute relocation for command address.  */
+  /* A 16 bit PC relative relocation for command address.  */
   HOWTO (R_MSP430_16_PCREL,	/* type */
 	 1,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -120,7 +120,7 @@
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
 
-  /* A 16 bit absolute relocation for command address.  */
+  /* A 16 bit PC relative relocation, byte operations.  */
   HOWTO (R_MSP430_16_PCREL_BYTE,/* type */
 	 1,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -163,7 +163,292 @@
 	 FALSE,			/* partial_inplace */
 	 0,			/* src_mask */
 	 0xffff,		/* dst_mask */
-	 TRUE)			/* pcrel_offset */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute src operand relocation, byte operations */
+  HOWTO (R_MSP430X_SRC_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_SRC_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute src operand relocation */
+  HOWTO (R_MSP430X_SRC,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_SRC",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute dst operand relocation, src is register mode, byte operations */
+  HOWTO (R_MSP430X_DST_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_DST_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute dst operand relocation, src is register mode */
+  HOWTO (R_MSP430X_DST,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_DST",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute dst operand relocation, byte operations */
+  HOWTO (R_MSP430X_DST_2ND_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_DST_2ND_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute dst operand relocation */
+  HOWTO (R_MSP430X_DST_2ND,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_DST_2ND",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative src operand relocation, byte operations */
+  HOWTO (R_MSP430X_PCREL_SRC_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_SRC_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative src operand relocation */
+  HOWTO (R_MSP430X_PCREL_SRC,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_SRC",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative dst operand relocation, src is register mode, byte operations */
+  HOWTO (R_MSP430X_PCREL_DST_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_DST_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative dst operand relocation, src is register mode */
+  HOWTO (R_MSP430X_PCREL_DST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_DST",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative dst operand relocation, byte operations */
+  HOWTO (R_MSP430X_PCREL_DST_2ND_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_DST_2ND_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative dst operand relocation */
+  HOWTO (R_MSP430X_PCREL_DST_2ND,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_DST_2ND",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions immediate src operand relocation */
+  HOWTO (R_MSP430X_S_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_S_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions absolute src operand relocation */
+  HOWTO (R_MSP430X_S,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_S",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions immediate dst operand relocation */
+  HOWTO (R_MSP430X_D_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_D_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions absolute dst operand relocation */
+  HOWTO (R_MSP430X_D,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_D",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions absolute dst operand relocation */
+  HOWTO (R_MSP430X_PCREL_D,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_D",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 16 bit msp430x relocation ***  for msp430x calla 16-bit PC-relative index ***/
+  HOWTO (R_MSP430X_PCREL_INDXD,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_INDXD",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 16 bit msp430x relocation ***  for msp430x bra/calla 16-bit index ***/
+  HOWTO (R_MSP430X_INDXD,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_INDXD",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */	  
 };
 
 /* Map BFD reloc types to MSP430 ELF reloc types.  */
@@ -185,7 +470,29 @@
     {BFD_RELOC_MSP430_16_PCREL_BYTE, R_MSP430_16_PCREL_BYTE},
     {BFD_RELOC_MSP430_16_BYTE,       R_MSP430_16_BYTE},
     {BFD_RELOC_MSP430_2X_PCREL,      R_MSP430_2X_PCREL},
-    {BFD_RELOC_MSP430_RL_PCREL,      R_MSP430_RL_PCREL}
+    {BFD_RELOC_MSP430_RL_PCREL,      R_MSP430_RL_PCREL},
+
+    {BFD_RELOC_MSP430X_SRC_BYTE,     R_MSP430X_SRC_BYTE},
+    {BFD_RELOC_MSP430X_SRC,          R_MSP430X_SRC},
+    {BFD_RELOC_MSP430X_DST_BYTE,     R_MSP430X_DST_BYTE},
+    {BFD_RELOC_MSP430X_DST,          R_MSP430X_DST},
+    {BFD_RELOC_MSP430X_DST_2ND_BYTE, R_MSP430X_DST_2ND_BYTE},
+    {BFD_RELOC_MSP430X_DST_2ND,      R_MSP430X_DST_2ND},
+
+    {BFD_RELOC_MSP430X_PCREL_SRC_BYTE,       R_MSP430X_PCREL_SRC_BYTE},
+    {BFD_RELOC_MSP430X_PCREL_SRC,            R_MSP430X_PCREL_SRC},
+    {BFD_RELOC_MSP430X_PCREL_DST_BYTE,       R_MSP430X_PCREL_DST_BYTE},
+    {BFD_RELOC_MSP430X_PCREL_DST,            R_MSP430X_PCREL_DST},
+    {BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE,   R_MSP430X_PCREL_DST_2ND_BYTE},
+    {BFD_RELOC_MSP430X_PCREL_DST_2ND,        R_MSP430X_PCREL_DST_2ND},
+
+    {BFD_RELOC_MSP430X_S_BYTE,       R_MSP430X_S_BYTE},
+    {BFD_RELOC_MSP430X_S,            R_MSP430X_S},
+    {BFD_RELOC_MSP430X_D_BYTE,       R_MSP430X_D_BYTE},
+    {BFD_RELOC_MSP430X_D,            R_MSP430X_D},
+    {BFD_RELOC_MSP430X_PCREL_D,      R_MSP430X_PCREL_D},
+    {BFD_RELOC_MSP430X_INDXD,        R_MSP430X_INDXD},
+    {BFD_RELOC_MSP430X_PCREL_INDXD,  R_MSP430X_PCREL_INDXD},
   };
 
 static reloc_howto_type *
@@ -207,10 +514,7 @@
 {
   unsigned int i;
 
-  for (i = 0;
-       i < (sizeof (elf_msp430_howto_table)
-	    / sizeof (elf_msp430_howto_table[0]));
-       i++)
+  for (i = 0; i < ARRAY_SIZE (elf_msp430_howto_table); i++)
     if (elf_msp430_howto_table[i].name != NULL
 	&& strcasecmp (elf_msp430_howto_table[i].name, r_name) == 0)
       return &elf_msp430_howto_table[i];
@@ -282,18 +586,44 @@
 {
   bfd_reloc_status_type r = bfd_reloc_ok;
   bfd_vma x;
-  bfd_signed_vma srel;
+  bfd_signed_vma srel = 0;
 
-  switch (howto->type)
+  if (howto->type > R_MSP430_32 && howto->type < R_MSP430_max)
     {
-    case R_MSP430_10_PCREL:
       contents += rel->r_offset;
       srel = (bfd_signed_vma) relocation;
       srel += rel->r_addend;
-      srel -= rel->r_offset;
+
+      if(howto->pc_relative)
+        {
+          srel -= rel->r_offset;
+          srel -= (input_section->output_section->vma +
+	           input_section->output_offset);
+        }
+        
+      switch (howto->type)
+        {
+        case R_MSP430X_PCREL_D:     // PC relative dst operand of calla
+        case R_MSP430X_PCREL_INDXD: // 16-bit idx in mova/bra instruction PC relative (symbolic) mode operand
+          srel -= 2;                // operand located 2 bytes after opcode
+          break;
+        case R_MSP430X_PCREL_SRC:   // PC-relative 20-bit address operand
+        case R_MSP430X_PCREL_SRC_BYTE:
+        case R_MSP430X_PCREL_DST:
+        case R_MSP430X_PCREL_DST_BYTE:
+          srel -= 4;                // operand located 4 bytes after opcode
+          break;
+        case R_MSP430X_PCREL_DST_2ND:
+        case R_MSP430X_PCREL_DST_2ND_BYTE:
+          srel -= 6;                // operand located 6 bytes after opcode
+          break;
+        }
+    }
+    
+  switch (howto->type)
+    {
+    case R_MSP430_10_PCREL:
       srel -= 2;		/* Branch instructions add 2 to the PC...  */
-      srel -= (input_section->output_section->vma +
-	       input_section->output_offset);
 
       if (srel & 1)
 	return bfd_reloc_outofrange;
@@ -311,13 +641,7 @@
       break;
 
     case R_MSP430_2X_PCREL:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
-      srel -= rel->r_offset;
       srel -= 2;		/* Branch instructions add 2 to the PC...  */
-      srel -= (input_section->output_section->vma +
-	       input_section->output_offset);
 
       if (srel & 1)
 	return bfd_reloc_outofrange;
@@ -341,13 +665,7 @@
 
     case R_MSP430_16_PCREL:
     case R_MSP430_RL_PCREL:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
-      srel -= rel->r_offset;
       /* Only branch instructions add 2 to the PC...  */
-      srel -= (input_section->output_section->vma +
-	       input_section->output_offset);
 
       if (srel & 1)
 	return bfd_reloc_outofrange;
@@ -356,35 +674,138 @@
       break;
 
     case R_MSP430_16_PCREL_BYTE:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
-      srel -= rel->r_offset;
       /* Only branch instructions add 2 to the PC...  */
-      srel -= (input_section->output_section->vma +
-	       input_section->output_offset);
 
       bfd_put_16 (input_bfd, srel & 0xffff, contents);
       break;
 
     case R_MSP430_16_BYTE:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
       bfd_put_16 (input_bfd, srel & 0xffff, contents);
       break;
 
     case R_MSP430_16:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
-
       if (srel & 1)
 	return bfd_reloc_notsupported;
 
       bfd_put_16 (input_bfd, srel & 0xffff, contents);
       break;
 
+    case R_MSP430X_SRC:         // address operand
+    case R_MSP430X_PCREL_SRC:   // PC-relative address operand
+
+    // 20 bit reloc for msp430x 
+    // src in Non-register mode extended instructions,
+    // imm/abs in bra instruction  
+
+    // src(19:16) located at positions 10:7 of extension word
+    // src(15:0) located just after opcode
+
+      if (srel & 1)             // odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_SRC_BYTE:            // byte instructions or immediate operand
+    case R_MSP430X_PCREL_SRC_BYTE:
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xf87f) | ((srel >> 9) & 0x0780);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 4); 
+      break;
+
+    case R_MSP430X_DST:         // address operand
+    case R_MSP430X_PCREL_DST:
+
+    // 20 bit reloc for msp430x
+    // dst in Non-register mode extended instructions,
+    // imm/abs/20-bit idx in calla instruction
+
+    // dst(19:16) located at positions 3:0 of extension word
+    // dst(15:0) located just after opcode
+
+      if (srel & 1)             // odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_DST_BYTE:    // byte instructions or immediate operand
+    case R_MSP430X_PCREL_DST_BYTE:
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xfff0) | ((srel >> 16) & 0x000f);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 4); 
+      break;
+
+    case R_MSP430X_DST_2ND:     // address operand
+    case R_MSP430X_PCREL_DST_2ND:
+
+    // 20 bit reloc for msp430x
+    // dst in Non-register mode extended instructions,
+
+    // dst(19:16) located at positions 3:0 of extension word
+    // dst(15:0) located after src(15:0)
+
+      if (srel & 1)             // odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_DST_2ND_BYTE:        // byte instructions or immediate operand
+    case R_MSP430X_PCREL_DST_2ND_BYTE:
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xfff0) | ((srel >> 16) & 0x000f);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 6); 
+      break;
+
+    case R_MSP430X_S:                   // absolute src operand of address instructions
+    // 20 bit reloc for msp430x 
+
+    // src(19:16) located at positions 11:8 of opcode
+    // src(15:0) located just after opcode
+
+      if (srel & 1)             //odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_S_BYTE:              // immediate src operand of address instructions
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xf0ff) | ((srel >> 8) & 0x0f00);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 2); 
+      break;
+
+    case R_MSP430X_D:                   // absolute dst operand of address instructions
+    case R_MSP430X_PCREL_D:             // PC relative dst operand of calla
+    // 20 bit reloc for msp430x, 
+
+    // dst(19:16) located at positions 3:0 of opcode
+    // dst(15:0) located just after opcode
+
+      if (srel & 1)             //odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_D_BYTE:              //immediate dst operand of address instructions
+
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xfff0) | ((srel >> 16) & 0x000f);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 2); 
+      break;
+
+    case R_MSP430X_PCREL_INDXD: // 16-bit idx in mova/bra instruction PC relative (symbolic) mode operand
+
+      if (srel & 1)             //odd address 
+	return bfd_reloc_notsupported;
+    case R_MSP430X_INDXD:       // 16-bit idx in calla/mova/bra instruction  
+
+      x = srel & 0xffff;
+      bfd_put_16 (input_bfd, x, contents + 2);          //16 least-significant bits
+      break;
+
     default:
       r = _bfd_final_link_relocate (howto, input_bfd, input_section,
 				    contents, rel->r_offset,
@@ -560,6 +981,34 @@
       val = E_MSP430_MACH_MSP430x16;
       break;
 
+    case bfd_mach_msp20:
+      val = E_MSP430_MACH_MSP430x20;
+      break;
+
+    case bfd_mach_msp21:
+      val = E_MSP430_MACH_MSP430x21;
+      break;
+
+    case bfd_mach_msp22:
+      val = E_MSP430_MACH_MSP430x22;
+      break;
+
+    case bfd_mach_msp23:
+      val = E_MSP430_MACH_MSP430x23;
+      break;
+
+    case bfd_mach_msp24:
+      val = E_MSP430_MACH_MSP430x24;
+      break;
+
+    case bfd_mach_msp241:
+      val = E_MSP430_MACH_MSP430x241;
+      break;
+
+    case bfd_mach_msp26:
+      val = E_MSP430_MACH_MSP430x26;
+      break;
+
     case bfd_mach_msp31:
       val = E_MSP430_MACH_MSP430x31;
       break;
@@ -587,6 +1036,14 @@
     case bfd_mach_msp44:
       val = E_MSP430_MACH_MSP430x44;
       break;
+
+    case bfd_mach_msp47:
+      val = E_MSP430_MACH_MSP430x47;
+      break;
+
+    case bfd_mach_msp54:
+      val = E_MSP430_MACH_MSP430x54;
+      break;
     }
 
   elf_elfheader (abfd)->e_machine = EM_MSP430;
@@ -637,6 +1094,34 @@
 	  e_set = bfd_mach_msp16;
 	  break;
 
+       case E_MSP430_MACH_MSP430x20:
+         e_set = bfd_mach_msp20;
+         break;
+
+       case E_MSP430_MACH_MSP430x21:
+         e_set = bfd_mach_msp21;
+         break;
+
+       case E_MSP430_MACH_MSP430x22:
+         e_set = bfd_mach_msp22;
+         break;
+
+        case E_MSP430_MACH_MSP430x23:
+	  e_set = bfd_mach_msp23;
+	  break;
+
+       case E_MSP430_MACH_MSP430x24:
+         e_set = bfd_mach_msp24;
+         break;
+
+       case E_MSP430_MACH_MSP430x241:
+         e_set = bfd_mach_msp241;
+         break;
+
+       case E_MSP430_MACH_MSP430x26:
+         e_set = bfd_mach_msp26;
+         break;
+
 	case E_MSP430_MACH_MSP430x31:
 	  e_set = bfd_mach_msp31;
 	  break;
@@ -664,6 +1149,17 @@
 	case E_MSP430_MACH_MSP430x44:
 	  e_set = bfd_mach_msp44;
 	  break;
+ 
+ 	case E_MSP430_MACH_MSP430x46:
+ 	  e_set = bfd_mach_msp46;
+	  break;
+
+	case E_MSP430_MACH_MSP430x47:
+	  e_set = bfd_mach_msp47;
+	  break;
+
+	case E_MSP430_MACH_MSP430x54:
+	  e_set = bfd_mach_msp54;
 	}
     }
 
diff -urN insight-6.8-1/bfd/libbfd.h insight-6.8-1-new/bfd/libbfd.h
--- insight-6.8-1/bfd/libbfd.h	Wed Feb 20 18:42:36 2008
+++ insight-6.8-1-new/bfd/libbfd.h	Mon Nov 23 20:29:41 2009
@@ -1947,6 +1947,25 @@
   "BFD_RELOC_MSP430_16_BYTE",
   "BFD_RELOC_MSP430_2X_PCREL",
   "BFD_RELOC_MSP430_RL_PCREL",
+  "BFD_RELOC_MSP430X_SRC_BYTE",
+  "BFD_RELOC_MSP430X_SRC",
+  "BFD_RELOC_MSP430X_DST_BYTE",
+  "BFD_RELOC_MSP430X_DST",
+  "BFD_RELOC_MSP430X_DST_2ND_BYTE",
+  "BFD_RELOC_MSP430X_DST_2ND",
+  "BFD_RELOC_MSP430X_PCREL_SRC_BYTE",
+  "BFD_RELOC_MSP430X_PCREL_SRC",
+  "BFD_RELOC_MSP430X_PCREL_DST_BYTE",
+  "BFD_RELOC_MSP430X_PCREL_DST",
+  "BFD_RELOC_MSP430X_PCREL_DST_2ND",
+  "BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE",
+  "BFD_RELOC_MSP430X_S_BYTE",
+  "BFD_RELOC_MSP430X_S",
+  "BFD_RELOC_MSP430X_D_BYTE",
+  "BFD_RELOC_MSP430X_D",
+  "BFD_RELOC_MSP430X_PCREL_D",
+  "BFD_RELOC_MSP430X_INDXD",
+  "BFD_RELOC_MSP430X_PCREL_INDXD",
   "BFD_RELOC_IQ2000_OFFSET_16",
   "BFD_RELOC_IQ2000_OFFSET_21",
   "BFD_RELOC_IQ2000_UHI16",
diff -urN insight-6.8-1/bfd/reloc.c insight-6.8-1-new/bfd/reloc.c
--- insight-6.8-1/bfd/reloc.c	Wed Feb 20 16:17:56 2008
+++ insight-6.8-1-new/bfd/reloc.c	Mon Nov 23 20:29:41 2009
@@ -4864,6 +4864,44 @@
   BFD_RELOC_MSP430_2X_PCREL
 ENUMX
   BFD_RELOC_MSP430_RL_PCREL
+ENUMX
+  BFD_RELOC_MSP430X_SRC_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_SRC
+ENUMX
+  BFD_RELOC_MSP430X_DST_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_DST
+ENUMX
+  BFD_RELOC_MSP430X_DST_2ND_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_DST_2ND
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_SRC_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_SRC
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_DST_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_DST
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_DST_2ND
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_S_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_S
+ENUMX
+  BFD_RELOC_MSP430X_D_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_D
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_D
+ENUMX
+  BFD_RELOC_MSP430X_INDXD
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_INDXD
 ENUMDOC
   msp430 specific relocation codes
 
diff -urN insight-6.8-1/gdb/Makefile.in insight-6.8-1-new/gdb/Makefile.in
--- insight-6.8-1/gdb/Makefile.in	Mon Mar 17 13:15:08 2008
+++ insight-6.8-1-new/gdb/Makefile.in	Mon Nov 23 20:29:41 2009
@@ -1339,6 +1339,11 @@
 	$(AR) q libgdb.a $(LIBGDB_OBS)
 	$(RANLIB) libgdb.a
 
+_gdbver.h:
+	cat $(srcdir)/version.in | sed s/\\\([0-9]\\\)\.\\\([0-9]\\\)/\#define\ GDB_VERSION_INT\ 0x\\1\\20/g > _gdbver.h
+
+msp430-tdep.o: _gdbver.h
+
 # This is useful when debugging GDB, because some Unix's don't let you run GDB
 # on itself without copying the executable.  So "make gdb1" will make
 # gdb and put a copy in gdb1, and you can run it with "gdb gdb1".
diff -urN insight-6.8-1/gdb/configure.tgt insight-6.8-1-new/gdb/configure.tgt
--- insight-6.8-1/gdb/configure.tgt	Mon Feb 11 22:58:41 2008
+++ insight-6.8-1-new/gdb/configure.tgt	Mon Nov 23 20:29:41 2009
@@ -319,6 +319,17 @@
 	gdb_sim=../sim/mn10300/libsim.a
 	;;
 
+msp430-*-*)
+	#gdb_target=msp430
+	#gdb_multi_arch=yes
+	#target-specific object files to use
+	gdb_target_obs="msp430-tdep.o"
+	#simulator library for target
+	gdb_sim=../sim/msp430/libsim.a
+	#set to "yes" if gdbserver supports target
+	build_gdbserver=no
+	;;
+
 mt-*-*)
 	# Target: Morpho Technologies ms1 processor
 	gdb_target_obs="mt-tdep.o"
diff -urN insight-6.8-1/include/elf/msp430.h insight-6.8-1-new/include/elf/msp430.h
--- insight-6.8-1/include/elf/msp430.h	Tue May 10 12:21:10 2005
+++ insight-6.8-1-new/include/elf/msp430.h	Mon Nov 23 20:29:41 2009
@@ -33,6 +33,13 @@
 #define E_MSP430_MACH_MSP430x14  14
 #define E_MSP430_MACH_MSP430x15  15
 #define E_MSP430_MACH_MSP430x16  16
+#define E_MSP430_MACH_MSP430x20  20
+#define E_MSP430_MACH_MSP430x21  21
+#define E_MSP430_MACH_MSP430x22  22
+#define E_MSP430_MACH_MSP430x23  23
+#define E_MSP430_MACH_MSP430x24  24
+#define E_MSP430_MACH_MSP430x241  241
+#define E_MSP430_MACH_MSP430x26  26
 #define E_MSP430_MACH_MSP430x31  31
 #define E_MSP430_MACH_MSP430x32  32
 #define E_MSP430_MACH_MSP430x33  33
@@ -40,6 +47,9 @@
 #define E_MSP430_MACH_MSP430x42  42
 #define E_MSP430_MACH_MSP430x43  43
 #define E_MSP430_MACH_MSP430x44  44
+#define E_MSP430_MACH_MSP430x46   46
+#define E_MSP430_MACH_MSP430x47   47
+#define E_MSP430_MACH_MSP430x54   54
 
 /* Relocations.  */
 START_RELOC_NUMBERS (elf_msp430_reloc_type)
@@ -52,6 +62,25 @@
      RELOC_NUMBER (R_MSP430_16_PCREL_BYTE, 	6)
      RELOC_NUMBER (R_MSP430_2X_PCREL,		7)
      RELOC_NUMBER (R_MSP430_RL_PCREL,		8)
+     RELOC_NUMBER (R_MSP430X_SRC_BYTE,		9)
+     RELOC_NUMBER (R_MSP430X_SRC,		10)
+     RELOC_NUMBER (R_MSP430X_DST_BYTE,		11)
+     RELOC_NUMBER (R_MSP430X_DST,		12)
+     RELOC_NUMBER (R_MSP430X_DST_2ND_BYTE,	13)
+     RELOC_NUMBER (R_MSP430X_DST_2ND,		14)
+     RELOC_NUMBER (R_MSP430X_PCREL_SRC_BYTE,	15)
+     RELOC_NUMBER (R_MSP430X_PCREL_SRC,		16)
+     RELOC_NUMBER (R_MSP430X_PCREL_DST_BYTE,	17)
+     RELOC_NUMBER (R_MSP430X_PCREL_DST,		18)
+     RELOC_NUMBER (R_MSP430X_PCREL_DST_2ND,	19)
+     RELOC_NUMBER (R_MSP430X_PCREL_DST_2ND_BYTE,	20)
+     RELOC_NUMBER (R_MSP430X_S_BYTE,		21)
+     RELOC_NUMBER (R_MSP430X_S,			22)
+     RELOC_NUMBER (R_MSP430X_D_BYTE,		23)
+     RELOC_NUMBER (R_MSP430X_D,			24)
+     RELOC_NUMBER (R_MSP430X_PCREL_D,		25)
+     RELOC_NUMBER (R_MSP430X_INDXD,		26)
+     RELOC_NUMBER (R_MSP430X_PCREL_INDXD,	27)
 
 END_RELOC_NUMBERS (R_MSP430_max)
 
diff -urN insight-6.8-1/include/opcode/msp430.h insight-6.8-1-new/include/opcode/msp430.h
--- insight-6.8-1/include/opcode/msp430.h	Tue May 10 12:21:13 2005
+++ insight-6.8-1-new/include/opcode/msp430.h	Mon Nov 23 20:29:41 2009
@@ -25,7 +25,7 @@
   int ol;	/* Operand length words.  */
   int am;	/* Addr mode.  */
   int reg;	/* Register.  */
-  int mode;	/* Pperand mode.  */
+  int mode;	/* Operand mode.  */
 #define OP_REG		0
 #define OP_EXP		1
 #ifndef DASM_SECTION
@@ -33,91 +33,240 @@
 #endif
 };
 
-#define BYTE_OPERATION  (1 << 6)  /* Byte operation flag for all instructions.  */
+#define BYTE_OPERATION          (1 << 6)  /* Byte operation flag for 430 instructions.  */
+#define BYTE_OPERATION_X        (1 << 22) /* Byte operation flag for 430x instructions.  */
+#define NON_ADDR_OPERATION      (1 << 6)  /* Address operation flag for 430x instructions.  */
+
+typedef enum 
+{ 
+  DEFAULT_OP,   // instruction has no modifier
+  WORD_OP,      // .w
+  BYTE_OP,      // .b
+  ADDR_OP       // .a
+} 
+opwidth_t;
+
+typedef enum
+{ 
+  CORE_430,     // 1xxx, 2xxx, 3xxx, 4xxx
+  CORE_430X,    // 241x, 26xx, 46xx
+  CORE_430X2,   // 5xxx
+}
+core_t;
+
+typedef enum
+{
+  FMT_EMULATED = 0,
+  FMT_DOUBLE_OPERAND,
+  FMT_SINGLE_OPERAND,
+  FMT_JUMP,
+  FMT_EMULATED_POLYMORPH_JUMP,
+  FMT_EMULATED_LONG_POLYMORPH_JUMP,
+  FMT_X_DOUBLE_OPERAND,
+  FMT_X_SINGLE_OPERAND,
+  FMT_X_EXCEPTION,
+  FMT_X_EMULATED,
+  FMT_X_ADDRESS,
+
+  FMT_X = FMT_X_DOUBLE_OPERAND,
+  FMT_MASK = 0x000f,
+
+  /* allowed modifiers: .b, .w, .a */
+  MOD_NONE = 0, 
+  MOD_W = 1 << 4, 
+  MOD_B = 1 << 5, 
+  MOD_A = 1 << 6,
+  MOD_MASK = 0x0070,
+  
+  /* opcode variant */
+  VAR_MASK = 0x0380,
+} 
+format_t;
+
+#define OP_V(x) (x << 7)
 
 struct  msp430_opcode_s
 {
   char *name;
-  int fmt;
-  int insn_opnumb;
-  int bin_opcode;
-  int bin_mask;
+  format_t fmt;
+  unsigned int insn_opnumb;
+  unsigned int bin_opcode;
+  unsigned int bin_mask;
 };
 
-#define MSP_INSN(name, size, numb, bin, mask) { #name, size, numb, bin, mask }
+#define opcode_format(opcode)   (opcode->fmt & FMT_MASK)
+#define opcode_modifier(opcode) (opcode->fmt & MOD_MASK)
+#define opcode_variant(opcode)  ((opcode->fmt & VAR_MASK) >> 7)
+
+/* opcode variants:  */
+enum
+{   
+   V_NONE = 0,          // ordinary instruction
+
+   /* FMT_EMULATED: */
+   V_NOOP,              // no operands: set/clear bit instructions, reti
+   V_SHIFT,             // shift instructions
+   V_BR,                // br instruction
+   
+   /* FMT_SINGLE_OPERAND: */
+   V_RETI = 1,          // reti
+   V_CALL = 2,          // hex operand in disassembly
+
+   /* FMT_X_SINGLE_OPERAND: */
+                        // V_NONE - #N operand disallowed
+   V_SWPSXT = 1,        // #N operand disallowed, special A/L, B/W bits case with .a modifier
+   V_PUSHX,             // #N operand allowed
+
+   /* FMT_X_EXCEPTIONS: */
+   V_CALLA = 0,         // calla 
+   V_ROTM,              // two operands, rotations
+   V_POPM,              // two operands, popm
+   V_PUSHM,             // two operands, pushm
+
+   /* FMT_X_EMULATED: */
+                        // V_NONE - substituted by 430x double operand instruction
+   V_X_SHIFT,           // shifts
+   V_RETA,              // reta, short instruction, no operands
+   V_EMU_ADDR,          // substituted by address instruction other than mova 
+   V_BRA,               // bra, substituted by mova address instruction == format II exception instruction
+   // clra emulated by msp430 instruction
 
-static struct msp430_opcode_s msp430_opcodes[] = 
+   /* FMT_X_ADDRESS: */
+   V_MOVA = 1,          // mova, more address modes allowed
+};
+
+#define MSP_INSN(name, format, opnumb, bin, mask) { #name, format, opnumb, bin, mask }
+
+static struct msp430_opcode_s const msp430_opcodes[] = 
 {
-  MSP_INSN (and,   1, 2, 0xf000, 0xf000),
-  MSP_INSN (inv,   0, 1, 0xe330, 0xfff0),
-  MSP_INSN (xor,   1, 2, 0xe000, 0xf000),
-  MSP_INSN (setz,  0, 0, 0xd322, 0xffff),
-  MSP_INSN (setc,  0, 0, 0xd312, 0xffff),
-  MSP_INSN (eint,  0, 0, 0xd232, 0xffff),
-  MSP_INSN (setn,  0, 0, 0xd222, 0xffff),
-  MSP_INSN (bis,   1, 2, 0xd000, 0xf000),
-  MSP_INSN (clrz,  0, 0, 0xc322, 0xffff),
-  MSP_INSN (clrc,  0, 0, 0xc312, 0xffff),
-  MSP_INSN (dint,  0, 0, 0xc232, 0xffff),
-  MSP_INSN (clrn,  0, 0, 0xc222, 0xffff),
-  MSP_INSN (bic,   1, 2, 0xc000, 0xf000),
-  MSP_INSN (bit,   1, 2, 0xb000, 0xf000),
-  MSP_INSN (dadc,  0, 1, 0xa300, 0xff30),
-  MSP_INSN (dadd,  1, 2, 0xa000, 0xf000),
-  MSP_INSN (tst,   0, 1, 0x9300, 0xff30),
-  MSP_INSN (cmp,   1, 2, 0x9000, 0xf000),
-  MSP_INSN (decd,  0, 1, 0x8320, 0xff30),
-  MSP_INSN (dec,   0, 1, 0x8310, 0xff30),
-  MSP_INSN (sub,   1, 2, 0x8000, 0xf000),
-  MSP_INSN (sbc,   0, 1, 0x7300, 0xff30),
-  MSP_INSN (subc,  1, 2, 0x7000, 0xf000),
-  MSP_INSN (adc,   0, 1, 0x6300, 0xff30),
-  MSP_INSN (rlc,   0, 2, 0x6000, 0xf000),
-  MSP_INSN (addc,  1, 2, 0x6000, 0xf000),
-  MSP_INSN (incd,  0, 1, 0x5320, 0xff30),
-  MSP_INSN (inc,   0, 1, 0x5310, 0xff30),
-  MSP_INSN (rla,   0, 2, 0x5000, 0xf000),
-  MSP_INSN (add,   1, 2, 0x5000, 0xf000),
-  MSP_INSN (nop,   0, 0, 0x4303, 0xffff),
-  MSP_INSN (clr,   0, 1, 0x4300, 0xff30),
-  MSP_INSN (ret,   0, 0, 0x4130, 0xff30),
-  MSP_INSN (pop,   0, 1, 0x4130, 0xff30),
-  MSP_INSN (br,    0, 3, 0x4000, 0xf000),
-  MSP_INSN (mov,   1, 2, 0x4000, 0xf000),
-  MSP_INSN (jmp,   3, 1, 0x3c00, 0xfc00),
-  MSP_INSN (jl,    3, 1, 0x3800, 0xfc00),
-  MSP_INSN (jge,   3, 1, 0x3400, 0xfc00),
-  MSP_INSN (jn,    3, 1, 0x3000, 0xfc00),
-  MSP_INSN (jc,    3, 1, 0x2c00, 0xfc00),
-  MSP_INSN (jhs,   3, 1, 0x2c00, 0xfc00),
-  MSP_INSN (jnc,   3, 1, 0x2800, 0xfc00),
-  MSP_INSN (jlo,   3, 1, 0x2800, 0xfc00),
-  MSP_INSN (jz,    3, 1, 0x2400, 0xfc00),
-  MSP_INSN (jeq,   3, 1, 0x2400, 0xfc00),
-  MSP_INSN (jnz,   3, 1, 0x2000, 0xfc00),
-  MSP_INSN (jne,   3, 1, 0x2000, 0xfc00),
-  MSP_INSN (reti,  2, 0, 0x1300, 0xffc0),
-  MSP_INSN (call,  2, 1, 0x1280, 0xffc0),
-  MSP_INSN (push,  2, 1, 0x1200, 0xff80),
-  MSP_INSN (sxt,   2, 1, 0x1180, 0xffc0),
-  MSP_INSN (rra,   2, 1, 0x1100, 0xff80),
-  MSP_INSN (swpb,  2, 1, 0x1080, 0xffc0),
-  MSP_INSN (rrc,   2, 1, 0x1000, 0xff80),
+  MSP_INSN (and,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xf000, 0xfffff000),
+  MSP_INSN (inv,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0xe330, 0xfffffff0),
+  MSP_INSN (xor,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xe000, 0xfffff000),
+  MSP_INSN (setz,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xd322, 0xffffffff),
+  MSP_INSN (setc,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xd312, 0xffffffff),
+  MSP_INSN (eint,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xd232, 0xffffffff),
+  MSP_INSN (setn,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xd222, 0xffffffff),
+  MSP_INSN (bis,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xd000, 0xfffff000),
+  MSP_INSN (clrz,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xc322, 0xffffffff),
+  MSP_INSN (clrc,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xc312, 0xffffffff),
+  MSP_INSN (dint,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xc232, 0xffffffff),
+  MSP_INSN (clrn,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xc222, 0xffffffff),
+  MSP_INSN (bic,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xc000, 0xfffff000),
+  MSP_INSN (bit,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xb000, 0xfffff000),
+  MSP_INSN (dadc,  FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0xa300, 0xffffff30),
+  MSP_INSN (dadd,  FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xa000, 0xfffff000),
+  MSP_INSN (tst,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x9300, 0xffffff30),
+  MSP_INSN (cmp,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x9000, 0xfffff000),
+  MSP_INSN (decd,  FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x8320, 0xffffff30),
+  MSP_INSN (dec,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x8310, 0xffffff30),
+  MSP_INSN (sub,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x8000, 0xfffff000),
+  MSP_INSN (sbc,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x7300, 0xffffff30),
+  MSP_INSN (subc,  FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x7000, 0xfffff000),
+  MSP_INSN (adc,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x6300, 0xffffff30),
+  MSP_INSN (rlc,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(V_SHIFT),       2, 0x6000, 0xfffff000),
+  MSP_INSN (addc,  FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x6000, 0xfffff000),
+  MSP_INSN (incd,  FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x5320, 0xffffff30),
+  MSP_INSN (inc,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x5310, 0xffffff30),
+  MSP_INSN (rla,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(V_SHIFT),       2, 0x5000, 0xfffff000),
+  MSP_INSN (add,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x5000, 0xfffff000),
+  MSP_INSN (nop,   FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0x4303, 0xffffffff),
+  MSP_INSN (clr,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x4300, 0xffffff30),
+  MSP_INSN (clra,  FMT_EMULATED          | MOD_NONE          | OP_V(0),             1, 0x4300, 0xffffff30),     // MOV      #0, Rdst
+  MSP_INSN (ret,   FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0x4130, 0xffffffff),
+  MSP_INSN (pop,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x4130, 0xffffff30),
+  MSP_INSN (br,    FMT_EMULATED          | MOD_NONE          | OP_V(V_BR),          1, 0x4000, 0xfffff08f),
+  MSP_INSN (mov,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x4000, 0xfffff000),
+
+  MSP_INSN (jmp,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x3c00, 0xfffffc00),
+  MSP_INSN (jl,    FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x3800, 0xfffffc00),
+  MSP_INSN (jge,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x3400, 0xfffffc00),
+  MSP_INSN (jn,    FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x3000, 0xfffffc00),
+  MSP_INSN (jc,    FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2c00, 0xfffffc00),
+  MSP_INSN (jhs,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2c00, 0xfffffc00),
+  MSP_INSN (jnc,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2800, 0xfffffc00),
+  MSP_INSN (jlo,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2800, 0xfffffc00),
+  MSP_INSN (jz,    FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2400, 0xfffffc00),
+  MSP_INSN (jeq,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2400, 0xfffffc00),
+  MSP_INSN (jnz,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2000, 0xfffffc00),
+  MSP_INSN (jne,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2000, 0xfffffc00),
+
+  MSP_INSN (reti,  FMT_SINGLE_OPERAND    | MOD_NONE          | OP_V(V_RETI),        0, 0x1300, 0xffffffc0),
+  MSP_INSN (call,  FMT_SINGLE_OPERAND    | MOD_NONE          | OP_V(V_CALL),        1, 0x1280, 0xffffffc0),
+  MSP_INSN (push,  FMT_SINGLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             1, 0x1200, 0xffffff80),
+  MSP_INSN (sxt,   FMT_SINGLE_OPERAND    | MOD_NONE          | OP_V(0),             1, 0x1180, 0xffffffc0),
+  MSP_INSN (rra,   FMT_SINGLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             1, 0x1100, 0xffffff80),
+  MSP_INSN (swpb,  FMT_SINGLE_OPERAND    | MOD_NONE          | OP_V(0),             1, 0x1080, 0xffffffc0),
+  MSP_INSN (rrc,   FMT_SINGLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             1, 0x1000, 0xffffff80),
+
+
+  /* emulated instructions placed just before instruction emulated by for disassembly search */
+  MSP_INSN (popx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x41301800, 0xff30f800), // MOVX     @SP+, dst
+  MSP_INSN (clrx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x43001800, 0xff30f800), // MOVX     #0, dst
+  MSP_INSN (movx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x40001800, 0xf000f800),
+  MSP_INSN (incx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x53101800, 0xff30f800), // ADDX     #1, dst
+  MSP_INSN (incdx, FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x53201800, 0xff30f800), // ADDX     #2, dst
+  MSP_INSN (rlax,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(V_X_SHIFT),     1, 0x50001800, 0xf000f800), // ADDX     dst, dst
+  MSP_INSN (addx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x50001800, 0xf000f800),
+  MSP_INSN (adcx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x63001800, 0xff30f800), // ADDCX    #0, dst
+  MSP_INSN (rlcx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(V_X_SHIFT),     1, 0x60001800, 0xf000f800), // ADDCX    dst, dst
+  MSP_INSN (addcx, FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x60001800, 0xf000f800),
+  MSP_INSN (sbcx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x73001800, 0xff30f800), // SUBCX    #0, dst
+  MSP_INSN (subcx, FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x70001800, 0xf000f800),
+  MSP_INSN (decx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x83101800, 0xff30f800), // SUBX     #1, dst
+  MSP_INSN (decdx, FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x83201800, 0xff30f800), // SUBX     #2, dst
+  MSP_INSN (subx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x80001800, 0xf000f800),
+  MSP_INSN (tstx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x93001800, 0xff30f800), // CMPX     #0, dst
+  MSP_INSN (cmpx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x90001800, 0xf000f800),
+  MSP_INSN (dadcx, FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0xa3001800, 0xff30f800), // DADDX    #0, dst
+  MSP_INSN (daddx, FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xa0001800, 0xf000f800),
+  MSP_INSN (bitx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xb0001800, 0xf000f800),
+  MSP_INSN (bicx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xc0001800, 0xf000f800),
+  MSP_INSN (bisx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xd0001800, 0xf000f800),
+  MSP_INSN (invx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0xe3301800, 0xff30f800), // XORX     #-1, dst
+  MSP_INSN (xorx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xe0001800, 0xf000f800),
+  MSP_INSN (andx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xf0001800, 0xf000f800),
+  
+  MSP_INSN (rrcx,  FMT_X_SINGLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x10001800, 0xff80f800),
+  MSP_INSN (swpbx, FMT_X_SINGLE_OPERAND  | MOD_W|MOD_A       | OP_V(V_SWPSXT),      1, 0x10801800, 0xffc0f800),
+  MSP_INSN (rrax,  FMT_X_SINGLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x11001800, 0xff80f800),
+  MSP_INSN (sxtx,  FMT_X_SINGLE_OPERAND  | MOD_W|MOD_A       | OP_V(V_SWPSXT),      1, 0x11801800, 0xffc0f800),
+  MSP_INSN (pushx, FMT_X_SINGLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(V_PUSHX),       1, 0x12001800, 0xff80f800),
+
+  MSP_INSN (calla, FMT_X_EXCEPTION       | MOD_NONE          | OP_V(V_CALLA),       1, 0x1300, 0xffffff00),
+  MSP_INSN (pushm, FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_PUSHM),       2, 0x1400, 0xfffffe00),
+  MSP_INSN (popm,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_POPM),        2, 0x1600, 0xfffffe00),
+  MSP_INSN (rrcm,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_ROTM),        2, 0x0040, 0xfffff3e0),
+  MSP_INSN (rram,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_ROTM),        2, 0x0140, 0xfffff3e0),
+  MSP_INSN (rlam,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_ROTM),        2, 0x0240, 0xfffff3e0),
+  MSP_INSN (rrum,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_ROTM),        2, 0x0340, 0xfffff3e0),
+
+  /* Address.  */
+  MSP_INSN (incda, FMT_X_EMULATED        | MOD_NONE          | OP_V(V_EMU_ADDR),    1, 0x03e0, 0xfffffff0),     // ADDA     #2, Rdst = ADDA R3, Rdst
+  MSP_INSN (adda,  FMT_X_ADDRESS         | MOD_NONE          | OP_V(0),             2, 0x00a0, 0xfffff0b0),
+  MSP_INSN (tsta,  FMT_X_EMULATED        | MOD_NONE          | OP_V(V_EMU_ADDR),    1, 0x03d0, 0xfffffff0),     // CMPA     #0, Rdst = CMPA R3, Rdst
+  MSP_INSN (cmpa,  FMT_X_ADDRESS         | MOD_NONE          | OP_V(0),             2, 0x0090, 0xfffff0b0),
+  MSP_INSN (decda, FMT_X_EMULATED        | MOD_NONE          | OP_V(V_EMU_ADDR),    1, 0x03f0, 0xfffffff0),     // SUBA     #2, Rdst = SUBA R3, Rdst
+  MSP_INSN (suba,  FMT_X_ADDRESS         | MOD_NONE          | OP_V(0),             2, 0x00b0, 0xfffff0b0),
+  MSP_INSN (reta,  FMT_X_EMULATED        | MOD_NONE          | OP_V(V_RETA),        0, 0x0110, 0xffffffff),     // MOVA     @SP+, PC
+  MSP_INSN (bra,   FMT_X_EMULATED        | MOD_NONE          | OP_V(V_BRA),         1, 0x0000, 0xfffff0cf),     // MOVA     dst, PC
+  MSP_INSN (bra,   FMT_X_EMULATED        | MOD_NONE          | OP_V(V_BRA),         1, 0x0080, 0xfffff0bf),     // MOVA     #imm20, PC; MOVA Rsrc, Rdst
+  MSP_INSN (mova,  FMT_X_ADDRESS         | MOD_NONE          | OP_V(V_MOVA),        1, 0x0000, 0xfffff000),
+  
   /* Simple polymorphs.  */
-  MSP_INSN (beq,   4, 0, 0, 0xffff),
-  MSP_INSN (bne,   4, 1, 0, 0xffff),
-  MSP_INSN (blt,   4, 2, 0, 0xffff),
-  MSP_INSN (bltu,  4, 3, 0, 0xffff),
-  MSP_INSN (bge,   4, 4, 0, 0xffff),
-  MSP_INSN (bgeu,  4, 5, 0, 0xffff),
-  MSP_INSN (bltn,  4, 6, 0, 0xffff),
-  MSP_INSN (jump,  4, 7, 0, 0xffff),
-  /* Long polymorphs.  */
-  MSP_INSN (bgt,   5, 0, 0, 0xffff),
-  MSP_INSN (bgtu,  5, 1, 0, 0xffff),
-  MSP_INSN (bleu,  5, 2, 0, 0xffff),
-  MSP_INSN (ble,   5, 3, 0, 0xffff),
+  MSP_INSN (beq,   FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(0),             1, 0, 0xffff),
+  MSP_INSN (bne,   FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(1),             1, 0, 0xffff),
+  MSP_INSN (blt,   FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(2),             1, 0, 0xffff),
+  MSP_INSN (bltu,  FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(3),             1, 0, 0xffff),
+  MSP_INSN (bge,   FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(4),             1, 0, 0xffff),
+  MSP_INSN (bgeu,  FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(5),             1, 0, 0xffff),
+  MSP_INSN (bltn,  FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(6),             1, 0, 0xffff),
+  MSP_INSN (jump,  FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(7),             1, 0, 0xffff),
 
+  /* Long polymorphs.  */
+  MSP_INSN (bgt,   FMT_EMULATED_LONG_POLYMORPH_JUMP | MOD_NONE | OP_V(0),           1, 0, 0xffff),
+  MSP_INSN (bgtu,  FMT_EMULATED_LONG_POLYMORPH_JUMP | MOD_NONE | OP_V(1),           1, 0, 0xffff),
+  MSP_INSN (bleu,  FMT_EMULATED_LONG_POLYMORPH_JUMP | MOD_NONE | OP_V(2),           1, 0, 0xffff),
+  MSP_INSN (ble,   FMT_EMULATED_LONG_POLYMORPH_JUMP | MOD_NONE | OP_V(3),           1, 0, 0xffff),
   /* End of instruction set.  */
   { NULL, 0, 0, 0, 0 }
 };
diff -urN insight-6.8-1/opcodes/Makefile.am insight-6.8-1-new/opcodes/Makefile.am
--- insight-6.8-1/opcodes/Makefile.am	Fri Dec 21 18:04:04 2007
+++ insight-6.8-1-new/opcodes/Makefile.am	Mon Nov 23 20:29:41 2009
@@ -155,6 +155,7 @@
 	m10300-opc.c \
 	mmix-dis.c \
 	mmix-opc.c \
+	msp430-dis.c \
 	mt-asm.c \
 	mt-desc.c \
 	mt-dis.c \
diff -urN insight-6.8-1/opcodes/Makefile.in insight-6.8-1-new/opcodes/Makefile.in
--- insight-6.8-1/opcodes/Makefile.in	Fri Dec 21 18:04:04 2007
+++ insight-6.8-1-new/opcodes/Makefile.in	Mon Nov 23 20:29:41 2009
@@ -384,6 +384,7 @@
 	m10300-opc.c \
 	mmix-dis.c \
 	mmix-opc.c \
+	msp430-dis.c \
 	mt-asm.c \
 	mt-desc.c \
 	mt-dis.c \
diff -urN insight-6.8-1/opcodes/msp430-dis.c insight-6.8-1-new/opcodes/msp430-dis.c
--- insight-6.8-1/opcodes/msp430-dis.c	Thu Jul  5 11:49:02 2007
+++ insight-6.8-1-new/opcodes/msp430-dis.c	Mon Nov 23 20:29:41 2009
@@ -51,12 +51,153 @@
   return bfd_getl16 (buffer);
 }
 
+static unsigned short
+msp430dis_operand (bfd_vma addr, disassemble_info *info, int reg, int am, int *cmd_len)
+{
+  static int const op_length [][5] = 
+  {
+  // am  | reg  0  1  2  3  >3
+  /*  0  */  {  0, 0, 0, 0, 0 },    // Rn
+  /*  1  */  {  2, 2, 2, 0, 2 },    // x(Rn)
+  /*  2  */  {  0, 0, 0, 0, 0 },    // @Rn
+  /*  3  */  {  2, 0, 0, 0, 0 },    // @Rn+
+  };
+  if (reg >= (int)(sizeof(op_length[0]) / sizeof(op_length[0][0])))
+    reg = sizeof(op_length[0]) / sizeof(op_length[0][0])- 1;
+    
+  if (op_length[am][reg])
+    {
+      bfd_byte buffer[2];
+      int status = info->read_memory_func (addr, buffer, 2, info);
+      if (status != 0)
+      {
+        info->memory_error_func (status, addr, info);
+        return -1;
+      }
+      *cmd_len += 2;
+      return bfd_getl16 (buffer);
+    }
+  return 0;
+}
+
+typedef enum
+{
+  OP_20BIT,
+  OP_16BIT,
+  OP_20BIT_HEX,
+  OP_16BIT_HEX,
+  OP_DECIMAL,
+} operand_t;
+
+static void 
+msp430x_decode_operand(int reg, int am, int addr, int dst, operand_t size, char *op, char *comm)
+{
+  if (op)       // if operand not hidden in emulated instruction
+    switch (am)
+      {
+      case 0:                   // Rn
+        if (reg == 3)
+          {
+            sprintf (op, "#0"); // constant #0
+            sprintf (comm, "r3 As==00");
+          }
+        else
+          {
+            sprintf (op, "r%d", reg);
+          }
+        break;
+      case 1:                   // x(Rn)
+        if (reg == 0)           // Symbolic, ADDR
+          {
+            if (size == OP_20BIT || size == OP_20BIT_HEX)
+              sprintf (op, "0x%05x", dst & 0xfffff);
+            else
+              sprintf (op, "0x%04x", dst & 0xffff);
+            sprintf (comm, "PC rel. 0x%05x", ((int)addr + dst) & 0xfffff);
+          }
+        else if (reg == 2)      // Absolute, &ADDR
+          {
+            if (size == OP_20BIT || size == OP_20BIT_HEX)
+              sprintf (op, "&0x%05x", dst & 0xfffff);
+            else
+              sprintf (op, "&0x%04x", dst & 0xffff);
+          }
+        else if (reg == 3)      // constant #1
+          {
+            sprintf (op, "#1");
+            sprintf (comm, "r3 As==01");
+          }
+        else                    // Indexed, x(Rn)
+          {
+            sprintf (op, "%d(r%d)", dst, reg);
+            if (size == OP_20BIT || size == OP_20BIT_HEX)
+              sprintf (comm, "0x%05x(r%d)", dst & 0xfffff, reg);
+            else
+              sprintf (comm, "0x%04x(r%d)", dst & 0xffff, reg);
+          }
+        break;
+      case 2:                   // @Rn
+        if (reg == 2)           // constant #4
+          {
+            sprintf (op, "#4");
+            sprintf (comm, "r2 As==10");
+          }
+        else if(reg == 3)       // constant #2
+          {
+            sprintf (op, "#2");
+            sprintf (comm, "r3 As==10");
+          }
+        else
+          {
+            sprintf (op, "@r%d", reg);
+          }
+        break;
+      case 3:                   // @Rn+
+        switch  (reg)
+          {
+          case 0:               // immediate, #N
+            switch (size)
+              {
+              case OP_16BIT:
+                sprintf (op, "#%d", dst);
+                sprintf (comm, "#0x%04x", dst & 0xffff);
+                break;
+              case OP_16BIT_HEX:
+                sprintf (op, "#0x%04x", dst & 0xffff);
+                break;
+              case OP_20BIT:
+                sprintf (op, "#%d", dst);
+                sprintf (comm, "#0x%05x", dst & 0xfffff);
+                break;
+              case OP_20BIT_HEX:
+                sprintf (op, "#0x%05x", dst & 0xfffff);
+                break;
+              default:          // #n in rxxm
+                sprintf (op, "#%d", dst);
+                break;
+              }
+            break;
+          case 2:               // constant #8
+            sprintf (op, "#8");
+            sprintf (comm, "r2 As==11");
+            break;  
+          case 3:               // constant #-1
+            sprintf (op, "#-1");
+	    sprintf (comm, "r3 As==11");
+            break;
+          default:
+            sprintf (op, "@r%d+", reg);
+            break;
+          }
+        break;
+      }
+}
+
 static int
-msp430_nooperands (struct msp430_opcode_s *opcode,
+msp430_nooperands (struct msp430_opcode_s const *opcode,
 		   bfd_vma addr ATTRIBUTE_UNUSED,
 		   unsigned short insn ATTRIBUTE_UNUSED,
-		   char *comm,
-		   int *cycles)
+		   char *comm)
 {
   /* Pop with constant.  */
   if (insn == 0x43b2)
@@ -64,18 +205,16 @@
   if (insn == opcode->bin_opcode)
     return 2;
 
-  if (opcode->fmt == 0)
+  if (opcode_format(opcode) == FMT_EMULATED)
     {
       if ((insn & 0x0f00) != 3 || (insn & 0x0f00) != 2)
 	return 0;
 
       strcpy (comm, "emulated...");
-      *cycles = 1;
     }
   else
     {
       strcpy (comm, "return from interupt");
-      *cycles = 5;
     }
 
   return 2;
@@ -83,16 +222,14 @@
 
 static int
 msp430_singleoperand (disassemble_info *info,
-		      struct msp430_opcode_s *opcode,
+		      struct msp430_opcode_s const *opcode,
 		      bfd_vma addr,
 		      unsigned short insn,
 		      char *op,
-		      char *comm,
-		      int *cycles)
+		      char *comm)
 {
   int regs = 0, regd = 0;
   int ad = 0, as = 0;
-  int where = 0;
   int cmd_len = 2;
   short dst = 0;
 
@@ -101,9 +238,9 @@
   as = (insn & 0x0030) >> 4;
   ad = (insn & 0x0080) >> 7;
 
-  switch (opcode->fmt)
+  switch (opcode_format(opcode))
     {
-    case 0:			/* Emulated work with dst register.  */
+    case FMT_EMULATED:		/* Emulated work with dst register.  */
       if (regs != 2 && regs != 3 && regs != 1)
 	return 0;
 
@@ -115,167 +252,23 @@
       if ((opcode->bin_opcode & 0xff00) == 0x5300 && as == 3)
 	return 0;
 
-      if (ad == 0)
-	{
-	  *cycles = 1;
-
-	  /* Register.  */
-	  if (regd == 0)
-	    {
-	      *cycles += 1;
-	      sprintf (op, "r0");
-	    }
-	  else if (regd == 1)
-	    sprintf (op, "r1");
-
-	  else if (regd == 2)
-	    sprintf (op, "r2");
-
-	  else
-	    sprintf (op, "r%d", regd);
-	}
-      else	/* ad == 1 msp430dis_opcode.  */
-	{
-	  if (regd == 0)
-	    {
-	      /* PC relative.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      *cycles = 4;
-	      sprintf (op, "0x%04x", dst);
-	      sprintf (comm, "PC rel. abs addr 0x%04x",
-		       PS ((short) (addr + 2) + dst));
-	    }
-	  else if (regd == 2)
-	    {
-	      /* Absolute.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      *cycles = 4;
-	      sprintf (op, "&0x%04x", PS (dst));
-	    }
-	  else
-	    {
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      *cycles = 4;
-	      sprintf (op, "%d(r%d)", dst, regd);
-	    }
-	}
+      dst = msp430dis_operand (addr + cmd_len, info, regd, ad, &cmd_len);
+      msp430x_decode_operand (regd, ad, addr + cmd_len, dst, OP_16BIT, op, comm);
       break;
 
-    case 2:	/* rrc, push, call, swpb, rra, sxt, push, call, reti etc...  */
-      if (as == 0)
-	{
-	  if (regd == 3)
-	    {
-	      /* Constsnts.  */
-	      sprintf (op, "#0");
-	      sprintf (comm, "r3 As==00");
-	    }
-	  else
-	    {
-	      /* Register.  */
-	      sprintf (op, "r%d", regd);
-	    }
-	  *cycles = 1;
-	}
-      else if (as == 2)
-	{
-	  *cycles = 1;
-	  if (regd == 2)
-	    {
-	      sprintf (op, "#4");
-	      sprintf (comm, "r2 As==10");
-	    }
-	  else if (regd == 3)
-	    {
-	      sprintf (op, "#2");
-	      sprintf (comm, "r3 As==10");
-	    }
-	  else
-	    {
-	      *cycles = 3;
-	      /* Indexed register mode @Rn.  */
-	      sprintf (op, "@r%d", regd);
-	    }
-	}
-      else if (as == 3)
-	{
-	  *cycles = 1;
-	  if (regd == 2)
-	    {
-	      sprintf (op, "#8");
-	      sprintf (comm, "r2 As==11");
-	    }
-	  else if (regd == 3)
-	    {
-	      sprintf (op, "#-1");
-	      sprintf (comm, "r3 As==11");
-	    }
-	  else if (regd == 0)
-	    {
-	      *cycles = 3;
-	      /* absolute. @pc+ */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      sprintf (op, "#%d", dst);
-	      sprintf (comm, "#0x%04x", PS (dst));
-	    }
-	  else
-	    {
-	      *cycles = 3;
-	      sprintf (op, "@r%d+", regd);
-	    }
-	}
-      else if (as == 1)
-	{
-	  *cycles = 4;
-	  if (regd == 0)
-	    {
-	      /* PC relative.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      sprintf (op, "0x%04x", PS (dst));
-	      sprintf (comm, "PC rel. 0x%04x",
-		       PS ((short) addr + 2 + dst));
-	    }
-	  else if (regd == 2)
-	    {
-	      /* Absolute.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      sprintf (op, "&0x%04x", PS (dst));
-	    }
-	  else if (regd == 3)
-	    {
-	      *cycles = 1;
-	      sprintf (op, "#1");
-	      sprintf (comm, "r3 As==01");
-	    }
-	  else
-	    {
-	      /* Indexd.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      sprintf (op, "%d(r%d)", dst, regd);
-	    }
-	}
+    case FMT_SINGLE_OPERAND:	/* rrc, push, call, swpb, rra, sxt, push, call, reti etc...  */
+      dst = msp430dis_operand (addr + cmd_len, info, regd, as, &cmd_len);
+      if(opcode_variant(opcode) != V_CALL)
+        msp430x_decode_operand (regd, as, addr + cmd_len, dst, OP_16BIT, op, comm);
+      else
+        msp430x_decode_operand (regd, as, addr + cmd_len, dst, OP_16BIT_HEX, op, comm);
       break;
 
-    case 3:			/* Jumps.  */
-      where = insn & 0x03ff;
-      if (where & 0x200)
-	where |= ~0x03ff;
-      if (where > 512 || where < -511)
-	return 0;
-
-      where *= 2;
-      sprintf (op, "$%+-8d", where + 2);
-      sprintf (comm, "abs 0x%x", PS ((short) (addr) + 2 + where));
-      *cycles = 2;
+    case FMT_JUMP:		/* Jumps.  */
+      dst = (short)((insn & 0x03ff) << 6) >> 5;        // sign extension, word addr to byte addr conversion
+      sprintf (op, "$%+-8d", dst + 2);
+      sprintf (comm, "abs 0x%x", PS ((short) (addr) + 2 + dst));
       return 2;
-      break;
     default:
       cmd_len = 0;
     }
@@ -285,26 +278,26 @@
 
 static int
 msp430_doubleoperand (disassemble_info *info,
-		      struct msp430_opcode_s *opcode,
+		      struct msp430_opcode_s const *opcode,
 		      bfd_vma addr,
 		      unsigned short insn,
 		      char *op1,
 		      char *op2,
 		      char *comm1,
-		      char *comm2,
-		      int *cycles)
+		      char *comm2)
 {
   int regs = 0, regd = 0;
   int ad = 0, as = 0;
   int cmd_len = 2;
-  short dst = 0;
+  short ops;
+  short opd;
 
   regd = insn & 0x0f;
   regs = (insn & 0x0f00) >> 8;
   as = (insn & 0x0030) >> 4;
   ad = (insn & 0x0080) >> 7;
 
-  if (opcode->fmt == 0)
+  if (opcode_format(opcode) == FMT_EMULATED)
     {
       /* Special case: rla and rlc are the only 2 emulated instructions that
 	 fall into two operand instructions.  */
@@ -319,348 +312,352 @@
       if (regd != regs || as != ad)
 	return 0;		/* May be 'data' section.  */
 
-      if (ad == 0)
+      if (ad == 0 && regd == 3) // #N
 	{
-	  /* Register mode.  */
-	  if (regd == 3)
-	    {
-	      strcpy (comm1, _("Illegal as emulation instr"));
-	      return -1;
-	    }
-
-	  sprintf (op1, "r%d", regd);
-	  *cycles = 1;
-	}
-      else			/* ad == 1 */
-	{
-	  if (regd == 0)
-	    {
-	      /* PC relative, Symbolic.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 4;
-	      *cycles = 6;
-	      sprintf (op1, "0x%04x", PS (dst));
-	      sprintf (comm1, "PC rel. 0x%04x",
-		       PS ((short) addr + 2 + dst));
-
-	    }
-	  else if (regd == 2)
-	    {
-	      /* Absolute.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      /* If the 'src' field is not the same as the dst
-		 then this is not an rla instruction.  */
-	      if (dst != msp430dis_opcode (addr + 4, info))
-		return 0;
-	      cmd_len += 4;
-	      *cycles = 6;
-	      sprintf (op1, "&0x%04x", PS (dst));
-	    }
-	  else
-	    {
-	      /* Indexed.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 4;
-	      *cycles = 6;
-	      sprintf (op1, "%d(r%d)", dst, regd);
-	    }
+	  strcpy (comm1, _("Illegal as emulation instr"));
+	  return -1;
 	}
+      ops = msp430dis_operand (addr + cmd_len, info, regs, as, &cmd_len);
+      opd = msp430dis_operand (addr + cmd_len, info, regd, ad, &cmd_len);
+      /* If the 'src' field is not the same as the dst
+         then this is not an rla instruction.  */
+      if (ops != opd)  
+        return 0;
+      msp430x_decode_operand (regs, as, addr + cmd_len, ops, OP_16BIT, op1, comm1);
 
       *op2 = 0;
       *comm2 = 0;
       return cmd_len;
     }
-
   /* Two operands exactly.  */
+
   if (ad == 0 && regd == 3)
     {
       /* R2/R3 are illegal as dest: may be data section.  */
       strcpy (comm1, _("Illegal as 2-op instr"));
       return -1;
     }
+  ops = msp430dis_operand (addr + cmd_len, info, regs, as, &cmd_len);
+  msp430x_decode_operand (regs, as, addr + cmd_len, ops, OP_16BIT, op1, comm1);
 
-  /* Source.  */
-  if (as == 0)
-    {
-      *cycles = 1;
-      if (regs == 3)
-	{
-	  /* Constsnts.  */
-	  sprintf (op1, "#0");
-	  sprintf (comm1, "r3 As==00");
-	}
-      else
-	{
-	  /* Register.  */
-	  sprintf (op1, "r%d", regs);
-	}
-    }
-  else if (as == 2)
-    {
-      *cycles = 1;
+  opd = msp430dis_operand (addr + cmd_len, info, regd, ad, &cmd_len);
+  msp430x_decode_operand (regd, ad, addr + cmd_len, opd, OP_16BIT, op2, comm2);
+  return cmd_len;
+}
 
-      if (regs == 2)
-	{
-	  sprintf (op1, "#4");
-	  sprintf (comm1, "r2 As==10");
-	}
-      else if (regs == 3)
-	{
-	  sprintf (op1, "#2");
-	  sprintf (comm1, "r3 As==10");
-	}
-      else
-	{
-	  *cycles = 2;
+static int
+msp430_branchinstr (disassemble_info *info,
+		    struct msp430_opcode_s const *opcode ATTRIBUTE_UNUSED,
+		    bfd_vma addr ATTRIBUTE_UNUSED,
+		    unsigned short insn,
+		    char *op1,
+		    char *comm1)
+{
+  int regs = (insn & 0x0f00) >> 8;
+  int as = (insn & 0x0030) >> 4;
+  int cmd_len = 2;
+  short dst;
 
-	  /* Indexed register mode @Rn.  */
-	  sprintf (op1, "@r%d", regs);
-	}
-      if (!regs)
-	*cycles = 3;
-    }
-  else if (as == 3)
-    {
-      if (regs == 2)
-	{
-	  sprintf (op1, "#8");
-	  sprintf (comm1, "r2 As==11");
-	  *cycles = 1;
-	}
-      else if (regs == 3)
-	{
-	  sprintf (op1, "#-1");
-	  sprintf (comm1, "r3 As==11");
-	  *cycles = 1;
-	}
-      else if (regs == 0)
-	{
-	  *cycles = 3;
-	  /* Absolute. @pc+.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "#%d", dst);
-	  sprintf (comm1, "#0x%04x", PS (dst));
-	}
-      else
-	{
-	  *cycles = 2;
-	  sprintf (op1, "@r%d+", regs);
-	}
-    }
-  else if (as == 1)
-    {
-      if (regs == 0)
-	{
-	  *cycles = 4;
-	  /* PC relative.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "0x%04x", PS (dst));
-	  sprintf (comm1, "PC rel. 0x%04x",
-		   PS ((short) addr + 2 + dst));
-	}
-      else if (regs == 2)
-	{
-	  *cycles = 2;
-	  /* Absolute.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "&0x%04x", PS (dst));
-	  sprintf (comm1, "0x%04x", PS (dst));
-	}
-      else if (regs == 3)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#1");
-	  sprintf (comm1, "r3 As==01");
-	}
-      else
-	{
-	  *cycles = 3;
-	  /* Indexed.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "%d(r%d)", dst, regs);
-	}
-    }
+  dst = msp430dis_operand (addr + cmd_len, info, regs, as, &cmd_len);
+  msp430x_decode_operand(regs, as, addr + cmd_len, dst, OP_16BIT_HEX, op1, comm1);
 
-  /* Destination. Special care needed on addr + XXXX.  */
+  return cmd_len;
+}
 
-  if (ad == 0)
-    {
-      /* Register.  */
-      if (regd == 0)
-	{
-	  *cycles += 1;
-	  sprintf (op2, "r0");
-	}
-      else if (regd == 1)
-	sprintf (op2, "r1");
+static opwidth_t
+msp430x_opwidth(unsigned int insn)
+{
+    insn &= NON_ADDR_OPERATION | BYTE_OPERATION_X;
+    
+    if(insn == (NON_ADDR_OPERATION | BYTE_OPERATION_X))
+      return BYTE_OP;
+    if(insn == NON_ADDR_OPERATION)
+      return WORD_OP;
+    if(insn == BYTE_OPERATION_X)
+      return ADDR_OP;
 
-      else if (regd == 2)
-	sprintf (op2, "r2");
+    return 0;   // reserved
+}
 
-      else
-	sprintf (op2, "r%d", regd);
+static int
+msp430x_singleoperand (disassemble_info *info,
+		      struct msp430_opcode_s const *opcode,
+		      bfd_vma addr,
+		      unsigned int insn,
+		      char *op,
+		      char *comm,
+                      int *repeats)
+{
+  int reg = (insn >> 16) & 0xf;
+  int am = (insn >> 20) & 0x3;
+  int cmd_len = 4;
+  int dst = 0;
+
+  if ( opcode_variant(opcode) < V_PUSHX )
+    if ((am == 3 && reg == 0)           // #N operand
+        || (am == 0 && reg == 3)        // R3 is illegal as dest: may be data section. 
+       )
+        {
+          strcpy (comm, _("Illegal as 1-op instr"));
+          return -1;
+        }
+ 
+  // extract repeat count if any
+  if ( am == 0 )                // extension word for register mode
+    {
+      if (insn & 0x008f)        // repetitions
+      {
+        if (insn & 0x0080)
+          *repeats = insn & 0xf;        // positive number is Rn
+        else
+          *repeats = 0 - (insn & 0xf);  // negative number is #N
+      }
+    }
+
+  // extract operands
+  dst = msp430dis_operand(addr + cmd_len, info, reg, am, &cmd_len) | ((insn & 0x0000000f) << 16);
+  dst = (dst << 12) >> 12;      // sign extension
+  msp430x_decode_operand(reg, am, addr + cmd_len, dst, OP_20BIT, op, comm);
+
+  return cmd_len; 
+}
+
+static int
+msp430x_exception (disassemble_info *info,
+		      struct msp430_opcode_s const *opcode,
+		      bfd_vma addr,
+		      unsigned int insn,
+		      char *op1,
+		      char *op2,
+		      char *comm1,
+		      char *comm2,
+		      opwidth_t *op_width)
+{
+  int reg = 0;
+  int cmd_len = 2;
+  int n = 0;
+  int dst = 0;
+  
+  reg = insn & 0xf;
+
+  switch(opcode_variant(opcode))
+    {
+    case V_CALLA:
+      switch((insn >> 4) & 0xf)
+        {
+        case 4:     // Rdst
+          msp430x_decode_operand(reg, 0, 0, 0, 0, op1, comm1);
+          break;
+        case 5:     // x(Rdst)
+          dst = (short)msp430dis_operand(addr + cmd_len, info, reg, 1, &cmd_len);
+          msp430x_decode_operand(reg, 1, addr + cmd_len, dst, OP_16BIT, op1, comm1);
+          break;
+        case 6:     // @Rdst
+          msp430x_decode_operand(reg, 2, 0, 0, 0, op1, comm1);
+          break;
+        case 7:     // @Rdst+
+          msp430x_decode_operand(reg, 3, 0, 0, 0, op1, comm1);
+          break;
+        case 8:     // &abs20
+          dst = msp430dis_operand(addr + cmd_len, info, 2, 1, &cmd_len) | ((insn & 0x000f) << 16);
+          msp430x_decode_operand(2, 1, addr + cmd_len, dst, OP_20BIT_HEX, op1, comm1);
+          break;
+        case 9:     // EDE
+          dst = msp430dis_operand(addr + cmd_len, info, 0, 1, &cmd_len) | ((insn & 0x000f) << 16);
+          msp430x_decode_operand(0, 1, addr + cmd_len, dst, OP_20BIT, op1, comm1);
+          break;
+        case 0xb:   // #imm20
+          dst = msp430dis_operand(addr + cmd_len, info, 0, 3, &cmd_len) | ((insn & 0x000f) << 16);
+          msp430x_decode_operand(0, 3, addr + cmd_len, dst, OP_20BIT_HEX, op1, comm1);
+          break;
+        }
+      break;
+    case V_PUSHM:
+      n = ((insn >> 4) & 0xf) + 1;
+      msp430x_decode_operand(0, 3, 0, n, OP_DECIMAL, op1, comm1);   // #N
+      msp430x_decode_operand(reg, 0, 0, 0, 0, op2, comm2);          // Rdst
+      if ((insn & 0x0100) == 0)
+        *op_width = ADDR_OP;
+      break;
+    case V_POPM:
+      n = ((insn >> 4) & 0xf) + 1;
+      reg = (reg + n - 1) & 0xf;
+      msp430x_decode_operand(0, 3, 0, n, OP_DECIMAL, op1, comm1);   // #N
+      msp430x_decode_operand(reg, 0, 0, 0, 0, op2, comm2);          // Rdst
+      if ((insn & 0x0100) == 0)
+        *op_width = ADDR_OP;
+      break;
+    case V_ROTM:
+      n = ((insn >> 10) & 0x3) + 1;
+      msp430x_decode_operand(0, 3, 0, n, OP_DECIMAL, op1, comm1);   // #N
+      msp430x_decode_operand(reg, 0, 0, 0, 0, op2, comm2);          // Rdst
+      if ((insn & 0x0010) == 0)
+        *op_width = ADDR_OP;
+      break;
+    default:
+      break;
     }
-  else	/* ad == 1.  */
-    {
-      * cycles += 3;
+  return cmd_len; 
+}
 
-      if (regd == 0)
-	{
-	  /* PC relative.  */
-	  *cycles += 1;
-	  dst = msp430dis_opcode (addr + cmd_len, info);
-	  sprintf (op2, "0x%04x", PS (dst));
-	  sprintf (comm2, "PC rel. 0x%04x",
-		   PS ((short) addr + cmd_len + dst));
-	  cmd_len += 2;
-	}
-      else if (regd == 2)
-	{
-	  /* Absolute.  */
-	  dst = msp430dis_opcode (addr + cmd_len, info);
-	  cmd_len += 2;
-	  sprintf (op2, "&0x%04x", PS (dst));
-	}
-      else
-	{
-	  dst = msp430dis_opcode (addr + cmd_len, info);
-	  cmd_len += 2;
-	  sprintf (op2, "%d(r%d)", dst, regd);
-	}
+static int
+msp430x_doubleoperand (disassemble_info *info,
+		      struct msp430_opcode_s const *opcode,
+		      bfd_vma addr,
+		      unsigned int insn,
+		      char *op1,
+		      char *op2,
+		      char *comm1,
+		      char *comm2,
+		      opwidth_t *op_width,
+		      int *repeats)
+{
+  int regs, regd;
+  int as, ad;
+  int ops, opd;
+  int cmd_len = 4;
+
+  regd = (insn >> 16) & 0xf;
+  regs = (insn >> 24) & 0xf;
+  as = (insn >> 20) & 0x3;
+  ad = (insn >> 23) & 0x1;
+
+  if (ad == 0 && regd == 3)
+    {
+      // R3 is illegal as dest: may be data section.
+      if (comm1)
+        strcpy (comm1, _("Illegal as 2-op instr"));
+      else if (comm2)
+        strcpy (comm2, _("Illegal as 2-op instr"));
+      return -1;
     }
+  *op_width = msp430x_opwidth(insn);
+  
+  // extract repeat count if any
+  if ( as == 0 && ad == 0 )     // extension word for register mode
+    {
+      if (insn & 0x008f)        // repetitions
+      {
+        if (insn & 0x0080)
+          *repeats = insn & 0xf;        // positive number is Rn
+        else
+          *repeats = 0 - (insn & 0xf);  // negative number is #N
+      }
+    }
+  // extract operands
+  ops = msp430dis_operand(addr + cmd_len, info, regs, as, &cmd_len) | ((insn & 0x00000780) << 9);
+  ops = (ops << 12) >> 12;      // sign extension
+  msp430x_decode_operand(regs, as, addr + cmd_len, ops, OP_20BIT, op1, comm1);
+
+  opd = msp430dis_operand(addr + cmd_len, info, regd, ad, &cmd_len) | ((insn & 0x0000000f) << 16);
+  opd = (opd << 12) >> 12;      // sign extension
+  if (opcode_variant(opcode) == V_X_SHIFT && ops != opd)
+    return 0;   // different operand => not emulated shift
+
+  msp430x_decode_operand(regd, ad, addr + cmd_len, opd, OP_20BIT, op2, comm2);
 
   return cmd_len;
 }
 
 static int
-msp430_branchinstr (disassemble_info *info,
-		    struct msp430_opcode_s *opcode ATTRIBUTE_UNUSED,
-		    bfd_vma addr ATTRIBUTE_UNUSED,
+msp430x_address (disassemble_info *info,
+		    bfd_vma addr,
 		    unsigned short insn,
 		    char *op1,
+		    char *op2,
 		    char *comm1,
-		    int *cycles)
+		    char *comm2)
 {
-  int regs = 0, regd = 0;
-  int ad = 0, as = 0;
   int cmd_len = 2;
-  short dst = 0;
-
-  regd = insn & 0x0f;
-  regs = (insn & 0x0f00) >> 8;
-  as = (insn & 0x0030) >> 4;
-  ad = (insn & 0x0080) >> 7;
-
-  if (regd != 0)	/* Destination register is not a PC.  */
-    return 0;
-
-  /* dst is a source register.  */
-  if (as == 0)
-    {
-      /* Constants.  */
-      if (regs == 3)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#0");
-	  sprintf (comm1, "r3 As==00");
-	}
-      else
-	{
-	  /* Register.  */
-	  *cycles = 1;
-	  sprintf (op1, "r%d", regs);
-	}
-    }
-  else if (as == 2)
+  int dst = 0;
+  typedef struct 
     {
-      if (regs == 2)
-	{
-	  *cycles = 2;
-	  sprintf (op1, "#4");
-	  sprintf (comm1, "r2 As==10");
-	}
-      else if (regs == 3)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#2");
-	  sprintf (comm1, "r3 As==10");
-	}
-      else
-	{
-	  /* Indexed register mode @Rn.  */
-	  *cycles = 2;
-	  sprintf (op1, "@r%d", regs);
-	}
-    }
-  else if (as == 3)
-    {
-      if (regs == 2)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#8");
-	  sprintf (comm1, "r2 As==11");
-	}
-      else if (regs == 3)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#-1");
-	  sprintf (comm1, "r3 As==11");
-	}
-      else if (regs == 0)
-	{
-	  /* Absolute. @pc+  */
-	  *cycles = 3;
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "#0x%04x", PS (dst));
-	}
-      else
-	{
-	  *cycles = 2;
-	  sprintf (op1, "@r%d+", regs);
-	}
+      int as, regs;
+      int ad, regd;
+      int length;
+    }
+  operands_t;
+  
+  static operands_t const operands_table[] =
+    {
+      { 2, -1, 0, -1, 0 },  // 0 @Rsrc, Rdst
+      { 3, -1, 0, -1, 0 },  // 1 @Rsrc+, Rdst
+      { 1,  2, 0, -1, 2 },  // 2 &abs20, Rdst
+      { 1, -1, 0, -1, 2 },  // 3 x(Rsrc), Rdst
+      { 0,  0, 0,  0, 0 },  // 4
+      { 0,  0, 0,  0, 0 },  // 5
+      { 0, -1, 1,  2, 2 },  // 6 Rsrc, &abs20
+      { 0, -1, 1, -1, 2 },  // 7 Rsrc, x(Rdst)
+      { 3,  0, 0, -1, 2 },  // 8 #imm20, Rdst
+      { 3,  0, 0, -1, 2 },  // 9 #imm20, Rdst
+      { 3,  0, 0, -1, 2 },  // a #imm20, Rdst
+      { 3,  0, 0, -1, 2 },  // b #imm20, Rdst
+      { 0, -1, 0, -1, 0 },  // c Rsrc, Rdst
+      { 0, -1, 0, -1, 0 },  // d Rsrc, Rdst
+      { 0, -1, 0, -1, 0 },  // e Rsrc, Rdst
+      { 0, -1, 0, -1, 0 },  // f Rsrc, Rdst
+    };
+
+  operands_t operands = operands_table[(insn >> 4) & 0xf];
+  if(((insn >> 4) & 0xf) == 6)
+    dst = msp430dis_opcode (addr + cmd_len, info) | ((insn & 0x000f) << 16);
+  else if(((insn >> 4) & 0xb) == 3)
+    dst = (short)msp430dis_opcode (addr + cmd_len, info);
+  else if(operands.length != 0)
+    dst = msp430dis_opcode(addr + cmd_len, info) | ((insn & 0x0f00) << 8);
+
+  if(operands.regs == -1)
+    operands.regs = (insn >> 8 ) & 0x000f;
+  if(operands.regd == -1)
+    operands.regd = (insn >> 0 ) & 0x000f;
+
+  if (operands.regd == 3)
+    {
+      // R3 is illegal as dest: may be data section.
+      if (comm1)
+        strcpy (comm1, _("Illegal as address instr"));
+      else if (comm2)
+        strcpy (comm2, _("Illegal as address instr"));
+      return -1;
     }
-  else if (as == 1)
-    {
-      * cycles = 3;
+  // extract operands
+  msp430x_decode_operand(operands.regs, operands.as, addr + cmd_len, dst,
+                          ((insn >> 4) & 0xf) == 3 ? OP_16BIT_HEX : OP_20BIT_HEX, op1, comm1);
+  msp430x_decode_operand(operands.regd, operands.ad, addr + cmd_len, dst,
+                          ((insn >> 4) & 0xf) == 7 ? OP_16BIT_HEX : OP_20BIT_HEX, op2, comm2);
+  return cmd_len + operands.length;
+}
 
-      if (regs == 0)
-	{
-	  /* PC relative.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  (*cycles)++;
-	  sprintf (op1, "0x%04x", PS (dst));
-	  sprintf (comm1, "PC rel. 0x%04x",
-		   PS ((short) addr + 2 + dst));
-	}
-      else if (regs == 2)
-	{
-	  /* Absolute.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "&0x%04x", PS (dst));
-	}
-      else if (regs == 3)
-	{
-	  (*cycles)--;
-	  sprintf (op1, "#1");
-	  sprintf (comm1, "r3 As==01");
-	}
-      else
-	{
-	  /* Indexd.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "%d(r%d)", dst, regs);
-	}
-    }
+static int
+msp430x_emulated (disassemble_info *info,
+		      struct msp430_opcode_s const *opcode,
+		      bfd_vma addr,
+		      unsigned int insn,
+		      char *op1,
+		      char *comm1,
+		      opwidth_t *op_width,
+		      int *repeats)
+{
 
-  return cmd_len;
+  switch(opcode_variant(opcode))
+    {
+    case V_NONE:
+    case V_X_SHIFT:
+      // emulated by double operand instruction
+      return msp430x_doubleoperand(info, opcode, addr, insn, (char *)0, op1,
+                                   (char *)0, comm1, op_width, repeats);
+    case V_RETA:        // reta, substituted by mova
+      return 2;
+    case V_EMU_ADDR:    // substituted by other address instruction
+      return msp430x_address(info, addr, insn, (char *)0, op1, 
+                             (char *)0, comm1);
+    case V_BRA:         // bra, substituted by mova
+      return msp430x_address(info, addr, insn, op1, (char *)0,
+                             comm1, (char *)0);
+    default:
+      break;
+    }
+  return 0;
 }
 
 int
@@ -668,85 +665,147 @@
 {
   void *stream = info->stream;
   fprintf_ftype prin = info->fprintf_func;
-  struct msp430_opcode_s *opcode;
+  struct msp430_opcode_s const *opcode;
   char op1[32], op2[32], comm1[64], comm2[64];
   int cmd_len = 0;
-  unsigned short insn;
-  int cycles = 0;
-  char *bc = "";
-  char dinfo[32];		/* Debug purposes.  */
-
+  unsigned int insn;
+  int repeats = 0;
+  core_t core = CORE_430;
+  
+  opwidth_t op_width = DEFAULT_OP;      // word instruction by default
+  static char const *width_modifier[] = 
+    {"", "", ".b", ".a" };
+    
   insn = msp430dis_opcode (addr, info);
-  sprintf (dinfo, "0x%04x", insn);
 
-  if (((int) addr & 0xffff) > 0xffdf)
+  if (info->mach == 241 || info->mach == 26 || info->mach == 46)
+    {
+      core = CORE_430X;
+    }
+  else if (info->mach == 54)
+    {
+      core = CORE_430X2;
+    }
+    
+  if ( (core == CORE_430 && ((int) addr & 0xffff) >= 0xffe0)
+      || ( core == CORE_430X && (((int) addr & 0xfffff) >= 0xffc0) && ((int) addr & 0xfffff) < 0x10000)
+      || ( core == CORE_430X2 && (((int) addr & 0xfffff) >= 0xff80) && ((int) addr & 0xfffff) < 0x10000)
+     )
     {
       (*prin) (stream, "interrupt service routine at 0x%04x", 0xffff & insn);
       return 2;
     }
 
+  if (core > CORE_430 && ((insn & 0xf800) == 0x1800))    // Extended instruction
+     insn |= msp430dis_opcode(addr + 2, info) << 16;
+
   *comm1 = 0;
   *comm2 = 0;
 
   for (opcode = msp430_opcodes; opcode->name; opcode++)
     {
       if ((insn & opcode->bin_mask) == opcode->bin_opcode
-	  && opcode->bin_opcode != 0x9300)
+//	  && opcode->bin_opcode != 0x9300       // was disasm tst instruction as cmp #0, dst?
+         )
 	{
 	  *op1 = 0;
 	  *op2 = 0;
 	  *comm1 = 0;
 	  *comm2 = 0;
 
-	  /* r0 as destination. Ad should be zero.  */
-	  if (opcode->insn_opnumb == 3 && (insn & 0x000f) == 0
-	      && (0x0080 & insn) == 0)
+          /* unsupported instruction */
+          if(opcode_format(opcode) >= FMT_X && core < CORE_430X)
+            break;
+
+	  /* r0 as destination. Ad should be zero. Rdst=0 and Ad=0 are encoded in opcode & opcode_mask */
+	  if (opcode_format(opcode) == FMT_EMULATED && opcode_variant(opcode) == V_BR)
 	    {
 	      cmd_len =
-		msp430_branchinstr (info, opcode, addr, insn, op1, comm1,
-				    &cycles);
+		msp430_branchinstr (info, opcode, addr, insn, op1, comm1);
 	      if (cmd_len)
 		break;
 	    }
-
-	  switch (opcode->insn_opnumb)
-	    {
-	    case 0:
-	      cmd_len = msp430_nooperands (opcode, addr, insn, comm1, &cycles);
-	      break;
-	    case 2:
-	      cmd_len =
-		msp430_doubleoperand (info, opcode, addr, insn, op1, op2,
-				      comm1, comm2, &cycles);
-	      if (insn & BYTE_OPERATION)
-		bc = ".b";
-	      break;
-	    case 1:
-	      cmd_len =
-		msp430_singleoperand (info, opcode, addr, insn, op1, comm1,
-				      &cycles);
-	      if (insn & BYTE_OPERATION && opcode->fmt != 3)
-		bc = ".b";
-	      break;
-	    default:
-	      break;
-	    }
+          if(opcode_format(opcode) < FMT_X)
+  	    switch (opcode->insn_opnumb)
+	      {
+	      case 0:
+	        cmd_len = msp430_nooperands (opcode, addr, insn, comm1);
+	        break;
+	      case 2:
+	        cmd_len =
+		  msp430_doubleoperand (info, opcode, addr, insn, op1, op2,
+				        comm1, comm2);
+	        if (insn & BYTE_OPERATION)
+		  op_width = BYTE_OP;
+	        break;
+	      case 1:
+	        cmd_len =
+		  msp430_singleoperand (info, opcode, addr, insn, op1, comm1);
+	        if (insn & BYTE_OPERATION && opcode_format(opcode) != FMT_JUMP)
+		  op_width = BYTE_OP;
+	        break;
+	      default:
+	        break;
+	      }
+          else  // 430x instruction
+            switch(opcode_format(opcode))
+              {
+              case FMT_X_SINGLE_OPERAND:
+                if( opcode_variant(opcode) == V_SWPSXT                          // swpbx, sxtx
+                   && (insn & (NON_ADDR_OPERATION | BYTE_OPERATION_X)) == 0)    // .a, special case
+                      insn ^= BYTE_OPERATION_X;                                 // make A/L, B/W as ordinary
+
+                op_width = msp430x_opwidth(insn);
+
+                if( opcode_variant(opcode) == V_SWPSXT && op_width == BYTE_OP)         // swpbx, sxtx
+                  strcpy (comm1, _("Illegal A/L, B/W bits setting"));
+
+                cmd_len = msp430x_singleoperand (info, opcode, addr, insn, op1, comm1,
+				                 &repeats);
+                break;
+              case FMT_X_EXCEPTION:
+                cmd_len = msp430x_exception (info, opcode, addr, insn, op1, op2, 
+                                                 comm1, comm2, &op_width);
+                break;
+              case FMT_X_DOUBLE_OPERAND:
+                cmd_len = msp430x_doubleoperand (info, opcode, addr, insn, op1, op2, 
+                                                 comm1, comm2, &op_width, &repeats);
+                break;
+              case FMT_X_EMULATED:
+                cmd_len = msp430x_emulated (info, opcode, addr, insn, op1,
+                                            comm1, &op_width, &repeats);
+                break;
+
+              case FMT_X_ADDRESS:
+                cmd_len = msp430x_address (info, addr, insn, op1, op2,
+                                           comm1, comm2);
+                break;
+              default:
+                break;
+              }
 	}
 
       if (cmd_len)
 	break;
     }
 
-  dinfo[5] = 0;
-
   if (cmd_len < 1)
     {
       /* Unknown opcode, or invalid combination of operands.  */
-      (*prin) (stream, ".word	0x%04x;	????", PS (insn));
+      (*prin) (stream, ".word	0x%04x;	????\t%s%s", PS (insn), comm1, comm2);
       return 2;
     }
 
-  (*prin) (stream, "%s%s", opcode->name, bc);
+    
+  if (repeats)
+    {
+      if (repeats < 0)
+        (*prin) (stream, ".rpt\t#%d\n\t\t\t\t", 0 - repeats);
+      else
+        (*prin) (stream, ".rpt\tr%d\n\t\t\t\t", repeats);
+    }
+  
+  (*prin) (stream, "%s%s", opcode->name, width_modifier[op_width]);
 
   if (*op1)
     (*prin) (stream, "\t%s", op1);
@@ -765,23 +824,11 @@
 
   if (*comm1 || *comm2)
     (*prin) (stream, ";");
-  else if (cycles)
-    {
-      if (*op2)
-	(*prin) (stream, ";");
-      else
-	{
-	  if (strlen (op1) < 7)
-	    (*prin) (stream, ";");
-	  else
-	    (*prin) (stream, "\t;");
-	}
-    }
   if (*comm1)
     (*prin) (stream, "%s", comm1);
   if (*comm1 && *comm2)
-    (*prin) (stream, ",");
+    (*prin) (stream, ", ");
   if (*comm2)
-    (*prin) (stream, " %s", comm2);
+    (*prin) (stream, "%s", comm2);
   return cmd_len;
 }
diff -urN insight-6.8-1/sim/configure insight-6.8-1-new/sim/configure
--- insight-6.8-1/sim/configure	Wed Feb  6 01:40:05 2008
+++ insight-6.8-1-new/sim/configure	Mon Nov 23 20:29:41 2009
@@ -284,6 +284,7 @@
 ac_subdirs_all="$ac_subdirs_all mcore"
 ac_subdirs_all="$ac_subdirs_all mips"
 ac_subdirs_all="$ac_subdirs_all mn10300"
+ac_subdirs_all="$ac_subdirs_all msp430"
 ac_subdirs_all="$ac_subdirs_all sh64"
 ac_subdirs_all="$ac_subdirs_all sh"
 ac_subdirs_all="$ac_subdirs_all erc32"
@@ -3496,6 +3497,13 @@
 
 
 subdirs="$subdirs mn10300"
+
+	   igen=yes
+	   ;;
+       msp430*-*-*)
+
+
+subdirs="$subdirs msp430"
 
 	   igen=yes
 	   ;;
diff -urN insight-6.8-1/sim/configure.ac insight-6.8-1-new/sim/configure.ac
--- insight-6.8-1/sim/configure.ac	Wed Feb  6 01:40:05 2008
+++ insight-6.8-1-new/sim/configure.ac	Mon Nov 23 20:29:41 2009
@@ -94,6 +94,10 @@
            AC_CONFIG_SUBDIRS(mn10300)
 	   igen=yes
 	   ;;
+       msp430*-*-*)
+    	    AC_CONFIG_SUBDIRS(msp430)
+	    igen=yes
+	    ;;
        sh64*-*-*)
            AC_CONFIG_SUBDIRS(sh64)
 	   testsuite=yes
diff -urN insight-6.8-1/tcl/win/tclWinChan.c insight-6.8-1-new/tcl/win/tclWinChan.c
--- insight-6.8-1/tcl/win/tclWinChan.c	Thu Feb  2 21:02:09 2006
+++ insight-6.8-1-new/tcl/win/tclWinChan.c	Mon Nov 23 20:50:25 2009
@@ -122,8 +122,8 @@
 };
 
 #ifdef HAVE_NO_SEH
-static void *ESP;
-static void *EBP;
+static void *ESP __attribute__ ((used));
+static void *EBP __attribute__ ((used));
 #endif /* HAVE_NO_SEH */
 
 
diff -urN insight-6.8-1/tcl/win/tclWinDde.c insight-6.8-1-new/tcl/win/tclWinDde.c
--- insight-6.8-1/tcl/win/tclWinDde.c	Tue Jan 21 20:40:22 2003
+++ insight-6.8-1-new/tcl/win/tclWinDde.c	Mon Nov 23 20:52:25 2009
@@ -1175,7 +1175,7 @@
 	}
 	case DDE_EVAL: {
 	    objc -= (async + 3);
-	    ((Tcl_Obj **) objv) += (async + 3);
+	    objv = ((Tcl_Obj **) objv) + (async + 3);
 
             /*
 	     * See if the target interpreter is local.  If so, execute
diff -urN insight-6.8-1/tcl/win/tclWinReg.c insight-6.8-1-new/tcl/win/tclWinReg.c
--- insight-6.8-1/tcl/win/tclWinReg.c	Fri Feb  7 20:52:00 2003
+++ insight-6.8-1-new/tcl/win/tclWinReg.c	Mon Nov 23 20:54:55 2009
@@ -747,7 +747,7 @@
 		    Tcl_NewStringObj(Tcl_DStringValue(&buf),
 			    Tcl_DStringLength(&buf)));
 	    if (regWinProcs->useWide) {
-		while (*((Tcl_UniChar *)p)++ != 0) {}
+		while (*((Tcl_UniChar *)p) != 0) {p = ((Tcl_UniChar *)p) + 1; }
 	    } else {
 		while (*p++ != '\0') {}
 	    }
