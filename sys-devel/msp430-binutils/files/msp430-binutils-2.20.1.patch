diff -urN binutils-2.20.1/bfd/archures.c binutils-2.20.1-mspgcc4/bfd/archures.c
--- binutils-2.20.1/bfd/archures.c	2009-09-10 06:47:11.000000000 -0500
+++ binutils-2.20.1-mspgcc4/bfd/archures.c	2010-04-30 19:31:50.000000000 -0500
@@ -398,7 +398,13 @@
 .#define bfd_mach_msp14          14
 .#define bfd_mach_msp15          15
 .#define bfd_mach_msp16          16
+.#define bfd_mach_msp20          20
 .#define bfd_mach_msp21          21
+.#define bfd_mach_msp22          22
+.#define bfd_mach_msp23          23
+.#define bfd_mach_msp24          24
+.#define bfd_mach_msp241         241
+.#define bfd_mach_msp26          26
 .#define bfd_mach_msp31          31
 .#define bfd_mach_msp32          32
 .#define bfd_mach_msp33          33
@@ -406,6 +412,10 @@
 .#define bfd_mach_msp42          42
 .#define bfd_mach_msp43          43
 .#define bfd_mach_msp44          44
+.#define bfd_mach_msp46          46
+.#define bfd_mach_msp47          47
+.#define bfd_mach_msp471         471
+.#define bfd_mach_msp54          54
 .  bfd_arch_xc16x,     {* Infineon's XC16X Series.               *}
 .#define bfd_mach_xc16x         1
 .#define bfd_mach_xc16xl        2
diff -urN binutils-2.20.1/bfd/bfd-in2.h binutils-2.20.1-mspgcc4/bfd/bfd-in2.h
--- binutils-2.20.1/bfd/bfd-in2.h	2010-02-03 07:28:24.000000000 -0600
+++ binutils-2.20.1-mspgcc4/bfd/bfd-in2.h	2010-04-30 19:31:50.000000000 -0500
@@ -2072,7 +2072,13 @@
 #define bfd_mach_msp14          14
 #define bfd_mach_msp15          15
 #define bfd_mach_msp16          16
+#define bfd_mach_msp20          20
 #define bfd_mach_msp21          21
+#define bfd_mach_msp22          22
+#define bfd_mach_msp23          23
+#define bfd_mach_msp24          24
+#define bfd_mach_msp241         241
+#define bfd_mach_msp26          26
 #define bfd_mach_msp31          31
 #define bfd_mach_msp32          32
 #define bfd_mach_msp33          33
@@ -2080,6 +2086,10 @@
 #define bfd_mach_msp42          42
 #define bfd_mach_msp43          43
 #define bfd_mach_msp44          44
+#define bfd_mach_msp46          46
+#define bfd_mach_msp47          47
+#define bfd_mach_msp471         471
+#define bfd_mach_msp54          54
   bfd_arch_xc16x,     /* Infineon's XC16X Series.               */
 #define bfd_mach_xc16x         1
 #define bfd_mach_xc16xl        2
@@ -4416,6 +4426,25 @@
   BFD_RELOC_MSP430_16_BYTE,
   BFD_RELOC_MSP430_2X_PCREL,
   BFD_RELOC_MSP430_RL_PCREL,
+  BFD_RELOC_MSP430X_SRC_BYTE,
+  BFD_RELOC_MSP430X_SRC,
+  BFD_RELOC_MSP430X_DST_BYTE,
+  BFD_RELOC_MSP430X_DST,
+  BFD_RELOC_MSP430X_DST_2ND_BYTE,
+  BFD_RELOC_MSP430X_DST_2ND,
+  BFD_RELOC_MSP430X_PCREL_SRC_BYTE,
+  BFD_RELOC_MSP430X_PCREL_SRC,
+  BFD_RELOC_MSP430X_PCREL_DST_BYTE,
+  BFD_RELOC_MSP430X_PCREL_DST,
+  BFD_RELOC_MSP430X_PCREL_DST_2ND,
+  BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE,
+  BFD_RELOC_MSP430X_S_BYTE,
+  BFD_RELOC_MSP430X_S,
+  BFD_RELOC_MSP430X_D_BYTE,
+  BFD_RELOC_MSP430X_D,
+  BFD_RELOC_MSP430X_PCREL_D,
+  BFD_RELOC_MSP430X_INDXD,
+  BFD_RELOC_MSP430X_PCREL_INDXD,
 
 /* IQ2000 Relocations.  */
   BFD_RELOC_IQ2000_OFFSET_16,
diff -urN binutils-2.20.1/bfd/cpu-msp430.c binutils-2.20.1-mspgcc4/bfd/cpu-msp430.c
--- binutils-2.20.1/bfd/cpu-msp430.c	2009-09-02 02:18:36.000000000 -0500
+++ binutils-2.20.1-mspgcc4/bfd/cpu-msp430.c	2010-04-30 19:31:50.000000000 -0500
@@ -65,29 +65,60 @@
   /* msp430x16x.  */
   N (16, bfd_mach_msp16, "msp:16", FALSE, & arch_info_struct[7]),
 
+  /* msp430x20x.  */
+  N (16, bfd_mach_msp20, "msp:20", FALSE, & arch_info_struct[8]),
+
   /* msp430x21x.  */
-  N (16, bfd_mach_msp21, "msp:21", FALSE, & arch_info_struct[8]),
+  N (16, bfd_mach_msp21, "msp:21", FALSE, & arch_info_struct[9]),
+
+  /* msp430x22x.  */
+  N (16, bfd_mach_msp22, "msp:22", FALSE, & arch_info_struct[10]),
+
+  /* msp430x23x0.  */
+  N (16, bfd_mach_msp23, "msp:23", FALSE, & arch_info_struct[11]),
+
+  /* msp430x24x including msp430x2410 */
+  N (16, bfd_mach_msp24, "msp:24", FALSE, & arch_info_struct[12]),
+
+  /* msp430x241x except msp430x2410 (extended address range) */
+  N (20, bfd_mach_msp241, "msp:241", FALSE, & arch_info_struct[13]),
+
+  /* msp430x26x.  */
+  N (20, bfd_mach_msp26, "msp:26", FALSE, & arch_info_struct[14]),
 
   /* msp430x31x.  */
-  N (16, bfd_mach_msp31, "msp:31", FALSE, & arch_info_struct[9]), 
+  N (16, bfd_mach_msp31, "msp:31", FALSE, & arch_info_struct[15]), 
 
   /* msp430x32x.  */
-  N (16, bfd_mach_msp32, "msp:32", FALSE, & arch_info_struct[10]), 
+  N (16, bfd_mach_msp32, "msp:32", FALSE, & arch_info_struct[16]), 
 
   /* msp430x33x.  */
-  N (16, bfd_mach_msp33, "msp:33", FALSE, & arch_info_struct[11]),
+  N (16, bfd_mach_msp33, "msp:33", FALSE, & arch_info_struct[17]),
   
   /* msp430x41x.  */
-  N (16, bfd_mach_msp41, "msp:41", FALSE, & arch_info_struct[12]),
+  N (16, bfd_mach_msp41, "msp:41", FALSE, & arch_info_struct[18]),
 
   /* msp430x42x.  */
-  N (16, bfd_mach_msp42, "msp:42", FALSE, & arch_info_struct[13]),
+  N (16, bfd_mach_msp42, "msp:42", FALSE, & arch_info_struct[19]),
 
   /* msp430x43x.  */
-  N (16, bfd_mach_msp43, "msp:43", FALSE, & arch_info_struct[14]),
+  N (16, bfd_mach_msp43, "msp:43", FALSE, & arch_info_struct[20]),
 
   /* msp430x44x.  */
-  N (16, bfd_mach_msp43, "msp:44", FALSE, NULL)
+  N (16, bfd_mach_msp44, "msp:44", FALSE, & arch_info_struct[21]),
+
+  /* msp430x46xx.  */
+  N (20, bfd_mach_msp46, "msp:46", FALSE, & arch_info_struct[22]),
+
+  /* msp430x47x3, 47x4.  */
+  N (16, bfd_mach_msp47, "msp:47", FALSE, & arch_info_struct[23]),
+
+  /* msp430x471x6, 471x7.  */
+  N (20, bfd_mach_msp471, "msp:471", FALSE, & arch_info_struct[24]),
+
+  /* msp430x54xx.  */
+  N (20, bfd_mach_msp54, "msp:54", FALSE, NULL)
+
 };
 
 const bfd_arch_info_type bfd_msp430_arch =
diff -urN binutils-2.20.1/bfd/doc/archures.texi binutils-2.20.1-mspgcc4/bfd/doc/archures.texi
--- binutils-2.20.1/bfd/doc/archures.texi	2009-10-16 06:52:10.000000000 -0500
+++ binutils-2.20.1-mspgcc4/bfd/doc/archures.texi	2010-04-30 19:31:50.000000000 -0500
@@ -363,7 +363,12 @@
 #define bfd_mach_msp14          14
 #define bfd_mach_msp15          15
 #define bfd_mach_msp16          16
+#define bfd_mach_msp20          20
 #define bfd_mach_msp21          21
+#define bfd_mach_msp22          22
+#define bfd_mach_msp24          24
+#define bfd_mach_msp241         241
+#define bfd_mach_msp26          26
 #define bfd_mach_msp31          31
 #define bfd_mach_msp32          32
 #define bfd_mach_msp33          33
@@ -371,6 +376,7 @@
 #define bfd_mach_msp42          42
 #define bfd_mach_msp43          43
 #define bfd_mach_msp44          44
+#define bfd_mach_msp46          46
   bfd_arch_xc16x,     /* Infineon's XC16X Series.               */
 #define bfd_mach_xc16x         1
 #define bfd_mach_xc16xl        2
@@ -623,4 +629,3 @@
 
 This routine is provided for those cases where a bfd * is not
 available
-
diff -urN binutils-2.20.1/bfd/elf32-msp430.c binutils-2.20.1-mspgcc4/bfd/elf32-msp430.c
--- binutils-2.20.1/bfd/elf32-msp430.c	2007-09-28 03:43:45.000000000 -0500
+++ binutils-2.20.1-mspgcc4/bfd/elf32-msp430.c	2010-04-30 19:31:50.000000000 -0500
@@ -90,7 +90,7 @@
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
 
-  /* A 16 bit absolute relocation for command address.  */
+  /* A 16 bit PC relative relocation for command address.  */
   HOWTO (R_MSP430_16_PCREL,	/* type */
 	 1,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -120,7 +120,7 @@
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
 
-  /* A 16 bit absolute relocation for command address.  */
+  /* A 16 bit PC relative relocation, byte operations.  */
   HOWTO (R_MSP430_16_PCREL_BYTE,/* type */
 	 1,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -163,7 +163,292 @@
 	 FALSE,			/* partial_inplace */
 	 0,			/* src_mask */
 	 0xffff,		/* dst_mask */
-	 TRUE)			/* pcrel_offset */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute src operand relocation, byte operations */
+  HOWTO (R_MSP430X_SRC_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_SRC_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute src operand relocation */
+  HOWTO (R_MSP430X_SRC,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_SRC",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute dst operand relocation, src is register mode, byte operations */
+  HOWTO (R_MSP430X_DST_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_DST_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute dst operand relocation, src is register mode */
+  HOWTO (R_MSP430X_DST,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_DST",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute dst operand relocation, byte operations */
+  HOWTO (R_MSP430X_DST_2ND_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_DST_2ND_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x absolute dst operand relocation */
+  HOWTO (R_MSP430X_DST_2ND,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_DST_2ND",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative src operand relocation, byte operations */
+  HOWTO (R_MSP430X_PCREL_SRC_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_SRC_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative src operand relocation */
+  HOWTO (R_MSP430X_PCREL_SRC,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_SRC",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative dst operand relocation, src is register mode, byte operations */
+  HOWTO (R_MSP430X_PCREL_DST_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_DST_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative dst operand relocation, src is register mode */
+  HOWTO (R_MSP430X_PCREL_DST,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_DST",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative dst operand relocation, byte operations */
+  HOWTO (R_MSP430X_PCREL_DST_2ND_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_DST_2ND_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x PC relative dst operand relocation */
+  HOWTO (R_MSP430X_PCREL_DST_2ND,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_DST_2ND",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions immediate src operand relocation */
+  HOWTO (R_MSP430X_S_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_S_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions absolute src operand relocation */
+  HOWTO (R_MSP430X_S,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_S",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0xfffff,		/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions immediate dst operand relocation */
+  HOWTO (R_MSP430X_D_BYTE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_D_BYTE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions absolute dst operand relocation */
+  HOWTO (R_MSP430X_D,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_D",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 20 bit msp430x address instructions absolute dst operand relocation */
+  HOWTO (R_MSP430X_PCREL_D,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 20,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_D",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 16 bit msp430x relocation ***  for msp430x calla 16-bit PC-relative index ***/
+  HOWTO (R_MSP430X_PCREL_INDXD,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_PCREL_INDXD",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A 16 bit msp430x relocation ***  for msp430x bra/calla 16-bit index ***/
+  HOWTO (R_MSP430X_INDXD,	/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MSP430X_INDXD",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffff,		/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */	  
 };
 
 /* Map BFD reloc types to MSP430 ELF reloc types.  */
@@ -185,7 +470,29 @@
     {BFD_RELOC_MSP430_16_PCREL_BYTE, R_MSP430_16_PCREL_BYTE},
     {BFD_RELOC_MSP430_16_BYTE,       R_MSP430_16_BYTE},
     {BFD_RELOC_MSP430_2X_PCREL,      R_MSP430_2X_PCREL},
-    {BFD_RELOC_MSP430_RL_PCREL,      R_MSP430_RL_PCREL}
+    {BFD_RELOC_MSP430_RL_PCREL,      R_MSP430_RL_PCREL},
+
+    {BFD_RELOC_MSP430X_SRC_BYTE,     R_MSP430X_SRC_BYTE},
+    {BFD_RELOC_MSP430X_SRC,          R_MSP430X_SRC},
+    {BFD_RELOC_MSP430X_DST_BYTE,     R_MSP430X_DST_BYTE},
+    {BFD_RELOC_MSP430X_DST,          R_MSP430X_DST},
+    {BFD_RELOC_MSP430X_DST_2ND_BYTE, R_MSP430X_DST_2ND_BYTE},
+    {BFD_RELOC_MSP430X_DST_2ND,      R_MSP430X_DST_2ND},
+
+    {BFD_RELOC_MSP430X_PCREL_SRC_BYTE,       R_MSP430X_PCREL_SRC_BYTE},
+    {BFD_RELOC_MSP430X_PCREL_SRC,            R_MSP430X_PCREL_SRC},
+    {BFD_RELOC_MSP430X_PCREL_DST_BYTE,       R_MSP430X_PCREL_DST_BYTE},
+    {BFD_RELOC_MSP430X_PCREL_DST,            R_MSP430X_PCREL_DST},
+    {BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE,   R_MSP430X_PCREL_DST_2ND_BYTE},
+    {BFD_RELOC_MSP430X_PCREL_DST_2ND,        R_MSP430X_PCREL_DST_2ND},
+
+    {BFD_RELOC_MSP430X_S_BYTE,       R_MSP430X_S_BYTE},
+    {BFD_RELOC_MSP430X_S,            R_MSP430X_S},
+    {BFD_RELOC_MSP430X_D_BYTE,       R_MSP430X_D_BYTE},
+    {BFD_RELOC_MSP430X_D,            R_MSP430X_D},
+    {BFD_RELOC_MSP430X_PCREL_D,      R_MSP430X_PCREL_D},
+    {BFD_RELOC_MSP430X_INDXD,        R_MSP430X_INDXD},
+    {BFD_RELOC_MSP430X_PCREL_INDXD,  R_MSP430X_PCREL_INDXD},
   };
 
 static reloc_howto_type *
@@ -207,10 +514,7 @@
 {
   unsigned int i;
 
-  for (i = 0;
-       i < (sizeof (elf_msp430_howto_table)
-	    / sizeof (elf_msp430_howto_table[0]));
-       i++)
+  for (i = 0; i < ARRAY_SIZE (elf_msp430_howto_table); i++)
     if (elf_msp430_howto_table[i].name != NULL
 	&& strcasecmp (elf_msp430_howto_table[i].name, r_name) == 0)
       return &elf_msp430_howto_table[i];
@@ -282,18 +586,44 @@
 {
   bfd_reloc_status_type r = bfd_reloc_ok;
   bfd_vma x;
-  bfd_signed_vma srel;
+  bfd_signed_vma srel = 0;
 
-  switch (howto->type)
+  if (howto->type > R_MSP430_32 && howto->type < R_MSP430_max)
     {
-    case R_MSP430_10_PCREL:
       contents += rel->r_offset;
       srel = (bfd_signed_vma) relocation;
       srel += rel->r_addend;
-      srel -= rel->r_offset;
+
+      if(howto->pc_relative)
+        {
+          srel -= rel->r_offset;
+          srel -= (input_section->output_section->vma +
+	           input_section->output_offset);
+        }
+        
+      switch (howto->type)
+        {
+        case R_MSP430X_PCREL_D:     // PC relative dst operand of calla
+        case R_MSP430X_PCREL_INDXD: // 16-bit idx in mova/bra instruction PC relative (symbolic) mode operand
+          srel -= 2;                // operand located 2 bytes after opcode
+          break;
+        case R_MSP430X_PCREL_SRC:   // PC-relative 20-bit address operand
+        case R_MSP430X_PCREL_SRC_BYTE:
+        case R_MSP430X_PCREL_DST:
+        case R_MSP430X_PCREL_DST_BYTE:
+          srel -= 4;                // operand located 4 bytes after opcode
+          break;
+        case R_MSP430X_PCREL_DST_2ND:
+        case R_MSP430X_PCREL_DST_2ND_BYTE:
+          srel -= 6;                // operand located 6 bytes after opcode
+          break;
+        }
+    }
+    
+  switch (howto->type)
+    {
+    case R_MSP430_10_PCREL:
       srel -= 2;		/* Branch instructions add 2 to the PC...  */
-      srel -= (input_section->output_section->vma +
-	       input_section->output_offset);
 
       if (srel & 1)
 	return bfd_reloc_outofrange;
@@ -311,13 +641,7 @@
       break;
 
     case R_MSP430_2X_PCREL:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
-      srel -= rel->r_offset;
       srel -= 2;		/* Branch instructions add 2 to the PC...  */
-      srel -= (input_section->output_section->vma +
-	       input_section->output_offset);
 
       if (srel & 1)
 	return bfd_reloc_outofrange;
@@ -341,13 +665,7 @@
 
     case R_MSP430_16_PCREL:
     case R_MSP430_RL_PCREL:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
-      srel -= rel->r_offset;
       /* Only branch instructions add 2 to the PC...  */
-      srel -= (input_section->output_section->vma +
-	       input_section->output_offset);
 
       if (srel & 1)
 	return bfd_reloc_outofrange;
@@ -356,35 +674,138 @@
       break;
 
     case R_MSP430_16_PCREL_BYTE:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
-      srel -= rel->r_offset;
       /* Only branch instructions add 2 to the PC...  */
-      srel -= (input_section->output_section->vma +
-	       input_section->output_offset);
 
       bfd_put_16 (input_bfd, srel & 0xffff, contents);
       break;
 
     case R_MSP430_16_BYTE:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
       bfd_put_16 (input_bfd, srel & 0xffff, contents);
       break;
 
     case R_MSP430_16:
-      contents += rel->r_offset;
-      srel = (bfd_signed_vma) relocation;
-      srel += rel->r_addend;
-
       if (srel & 1)
 	return bfd_reloc_notsupported;
 
       bfd_put_16 (input_bfd, srel & 0xffff, contents);
       break;
 
+    case R_MSP430X_SRC:         // address operand
+    case R_MSP430X_PCREL_SRC:   // PC-relative address operand
+
+    // 20 bit reloc for msp430x 
+    // src in Non-register mode extended instructions,
+    // imm/abs in bra instruction  
+
+    // src(19:16) located at positions 10:7 of extension word
+    // src(15:0) located just after opcode
+
+      if (srel & 1)             // odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_SRC_BYTE:            // byte instructions or immediate operand
+    case R_MSP430X_PCREL_SRC_BYTE:
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xf87f) | ((srel >> 9) & 0x0780);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 4); 
+      break;
+
+    case R_MSP430X_DST:         // address operand
+    case R_MSP430X_PCREL_DST:
+
+    // 20 bit reloc for msp430x
+    // dst in Non-register mode extended instructions,
+    // imm/abs/20-bit idx in calla instruction
+
+    // dst(19:16) located at positions 3:0 of extension word
+    // dst(15:0) located just after opcode
+
+      if (srel & 1)             // odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_DST_BYTE:    // byte instructions or immediate operand
+    case R_MSP430X_PCREL_DST_BYTE:
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xfff0) | ((srel >> 16) & 0x000f);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 4); 
+      break;
+
+    case R_MSP430X_DST_2ND:     // address operand
+    case R_MSP430X_PCREL_DST_2ND:
+
+    // 20 bit reloc for msp430x
+    // dst in Non-register mode extended instructions,
+
+    // dst(19:16) located at positions 3:0 of extension word
+    // dst(15:0) located after src(15:0)
+
+      if (srel & 1)             // odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_DST_2ND_BYTE:        // byte instructions or immediate operand
+    case R_MSP430X_PCREL_DST_2ND_BYTE:
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xfff0) | ((srel >> 16) & 0x000f);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 6); 
+      break;
+
+    case R_MSP430X_S:                   // absolute src operand of address instructions
+    // 20 bit reloc for msp430x 
+
+    // src(19:16) located at positions 11:8 of opcode
+    // src(15:0) located just after opcode
+
+      if (srel & 1)             //odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_S_BYTE:              // immediate src operand of address instructions
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xf0ff) | ((srel >> 8) & 0x0f00);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 2); 
+      break;
+
+    case R_MSP430X_D:                   // absolute dst operand of address instructions
+    case R_MSP430X_PCREL_D:             // PC relative dst operand of calla
+    // 20 bit reloc for msp430x, 
+
+    // dst(19:16) located at positions 3:0 of opcode
+    // dst(15:0) located just after opcode
+
+      if (srel & 1)             //odd address 
+        return bfd_reloc_notsupported;
+      /* and fall trough, no break here!!! */
+    case R_MSP430X_D_BYTE:              //immediate dst operand of address instructions
+
+      x = bfd_get_16 (input_bfd, contents);
+      /* 4 most-significant bits */
+      x = (x & 0xfff0) | ((srel >> 16) & 0x000f);        
+      bfd_put_16 (input_bfd, x, contents);
+      /* 16 least-significant bits */
+      bfd_put_16 (input_bfd, srel & 0xffff, contents + 2); 
+      break;
+
+    case R_MSP430X_PCREL_INDXD: // 16-bit idx in mova/bra instruction PC relative (symbolic) mode operand
+
+      if (srel & 1)             //odd address 
+	return bfd_reloc_notsupported;
+    case R_MSP430X_INDXD:       // 16-bit idx in calla/mova/bra instruction  
+
+      x = srel & 0xffff;
+      bfd_put_16 (input_bfd, x, contents + 2);          //16 least-significant bits
+      break;
+
     default:
       r = _bfd_final_link_relocate (howto, input_bfd, input_section,
 				    contents, rel->r_offset,
@@ -560,6 +981,34 @@
       val = E_MSP430_MACH_MSP430x16;
       break;
 
+    case bfd_mach_msp20:
+      val = E_MSP430_MACH_MSP430x20;
+      break;
+
+    case bfd_mach_msp21:
+      val = E_MSP430_MACH_MSP430x21;
+      break;
+
+    case bfd_mach_msp22:
+      val = E_MSP430_MACH_MSP430x22;
+      break;
+
+    case bfd_mach_msp23:
+      val = E_MSP430_MACH_MSP430x23;
+      break;
+
+    case bfd_mach_msp24:
+      val = E_MSP430_MACH_MSP430x24;
+      break;
+
+    case bfd_mach_msp241:
+      val = E_MSP430_MACH_MSP430x241;
+      break;
+
+    case bfd_mach_msp26:
+      val = E_MSP430_MACH_MSP430x26;
+      break;
+
     case bfd_mach_msp31:
       val = E_MSP430_MACH_MSP430x31;
       break;
@@ -587,6 +1036,22 @@
     case bfd_mach_msp44:
       val = E_MSP430_MACH_MSP430x44;
       break;
+
+    case bfd_mach_msp46:
+      val = E_MSP430_MACH_MSP430x46;
+      break;
+
+    case bfd_mach_msp47:
+      val = E_MSP430_MACH_MSP430x47;
+      break;
+
+    case bfd_mach_msp471:
+      val = E_MSP430_MACH_MSP430x471;
+      break;
+
+    case bfd_mach_msp54:
+      val = E_MSP430_MACH_MSP430x54;
+      break;
     }
 
   elf_elfheader (abfd)->e_machine = EM_MSP430;
@@ -637,6 +1102,34 @@
 	  e_set = bfd_mach_msp16;
 	  break;
 
+	case E_MSP430_MACH_MSP430x20:
+	  e_set = bfd_mach_msp20;
+	  break;
+
+	case E_MSP430_MACH_MSP430x21:
+	  e_set = bfd_mach_msp21;
+	  break;
+
+	case E_MSP430_MACH_MSP430x22:
+	  e_set = bfd_mach_msp22;
+	  break;
+
+        case E_MSP430_MACH_MSP430x23:
+	  e_set = bfd_mach_msp23;
+	  break;
+
+	case E_MSP430_MACH_MSP430x24:
+	  e_set = bfd_mach_msp24;
+	  break;
+
+	case E_MSP430_MACH_MSP430x241:
+	  e_set = bfd_mach_msp241;
+	  break;
+
+	case E_MSP430_MACH_MSP430x26:
+	  e_set = bfd_mach_msp26;
+	  break;
+
 	case E_MSP430_MACH_MSP430x31:
 	  e_set = bfd_mach_msp31;
 	  break;
@@ -664,6 +1157,22 @@
 	case E_MSP430_MACH_MSP430x44:
 	  e_set = bfd_mach_msp44;
 	  break;
+
+	case E_MSP430_MACH_MSP430x46:
+	  e_set = bfd_mach_msp46;
+	  break;
+
+	case E_MSP430_MACH_MSP430x47:
+	  e_set = bfd_mach_msp47;
+	  break;
+
+	case E_MSP430_MACH_MSP430x471:
+	  e_set = bfd_mach_msp471;
+	  break;
+
+	case E_MSP430_MACH_MSP430x54:
+	  e_set = bfd_mach_msp54;
+	  break;
 	}
     }
 
diff -urN binutils-2.20.1/bfd/libbfd.h binutils-2.20.1-mspgcc4/bfd/libbfd.h
--- binutils-2.20.1/bfd/libbfd.h	2009-09-02 03:10:55.000000000 -0500
+++ binutils-2.20.1-mspgcc4/bfd/libbfd.h	2010-04-30 19:31:50.000000000 -0500
@@ -2004,6 +2004,25 @@
   "BFD_RELOC_MSP430_16_BYTE",
   "BFD_RELOC_MSP430_2X_PCREL",
   "BFD_RELOC_MSP430_RL_PCREL",
+  "BFD_RELOC_MSP430X_SRC_BYTE",
+  "BFD_RELOC_MSP430X_SRC",
+  "BFD_RELOC_MSP430X_DST_BYTE",
+  "BFD_RELOC_MSP430X_DST",
+  "BFD_RELOC_MSP430X_DST_2ND_BYTE",
+  "BFD_RELOC_MSP430X_DST_2ND",
+  "BFD_RELOC_MSP430X_PCREL_SRC_BYTE",
+  "BFD_RELOC_MSP430X_PCREL_SRC",
+  "BFD_RELOC_MSP430X_PCREL_DST_BYTE",
+  "BFD_RELOC_MSP430X_PCREL_DST",
+  "BFD_RELOC_MSP430X_PCREL_DST_2ND",
+  "BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE",
+  "BFD_RELOC_MSP430X_S_BYTE",
+  "BFD_RELOC_MSP430X_S",
+  "BFD_RELOC_MSP430X_D_BYTE",
+  "BFD_RELOC_MSP430X_D",
+  "BFD_RELOC_MSP430X_PCREL_D",
+  "BFD_RELOC_MSP430X_INDXD",
+  "BFD_RELOC_MSP430X_PCREL_INDXD",
   "BFD_RELOC_IQ2000_OFFSET_16",
   "BFD_RELOC_IQ2000_OFFSET_21",
   "BFD_RELOC_IQ2000_UHI16",
diff -urN binutils-2.20.1/bfd/reloc.c binutils-2.20.1-mspgcc4/bfd/reloc.c
--- binutils-2.20.1/bfd/reloc.c	2009-09-10 06:47:13.000000000 -0500
+++ binutils-2.20.1-mspgcc4/bfd/reloc.c	2010-04-30 19:31:50.000000000 -0500
@@ -4993,6 +4993,44 @@
   BFD_RELOC_MSP430_2X_PCREL
 ENUMX
   BFD_RELOC_MSP430_RL_PCREL
+ENUMX
+  BFD_RELOC_MSP430X_SRC_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_SRC
+ENUMX
+  BFD_RELOC_MSP430X_DST_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_DST
+ENUMX
+  BFD_RELOC_MSP430X_DST_2ND_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_DST_2ND
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_SRC_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_SRC
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_DST_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_DST
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_DST_2ND
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_S_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_S
+ENUMX
+  BFD_RELOC_MSP430X_D_BYTE
+ENUMX
+  BFD_RELOC_MSP430X_D
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_D
+ENUMX
+  BFD_RELOC_MSP430X_INDXD
+ENUMX
+  BFD_RELOC_MSP430X_PCREL_INDXD
 ENUMDOC
   msp430 specific relocation codes
 
diff -urN binutils-2.20.1/gas/config/tc-msp430.c binutils-2.20.1-mspgcc4/gas/config/tc-msp430.c
--- binutils-2.20.1/gas/config/tc-msp430.c	2009-09-02 02:24:20.000000000 -0500
+++ binutils-2.20.1-mspgcc4/gas/config/tc-msp430.c	2010-04-30 19:31:50.000000000 -0500
@@ -23,7 +23,6 @@
 
 #include <limits.h>
 
-#define PUSH_1X_WORKAROUND
 #include "as.h"
 #include "subsegs.h"
 #include "opcode/msp430.h"
@@ -69,6 +68,7 @@
 
 int msp430_enable_relax;
 int msp430_enable_polys;
+int msp430x_repeats;    // It's not a right way to use global variable, but I don't know other way how to do it
 
 /* GCC uses the some condition codes which we'll
    implement as new polymorph instructions.
@@ -99,12 +99,13 @@
    Also, we add 'jump' instruction:
    jump	UNCOND	-> jmp		br lab
 
-   They will have fmt == 4, and insn_opnumb == number of instruction.  */
+   They will have opcode_format() == FMT_EMULATED_POLYMORPH_JUMP, 
+   and opcode_variant() == number of instruction.  */
 
 struct rcodes_s 
 {
   char * name;
-  int    index;	/* Corresponding insn_opnumb.  */
+  int    index;	/* Corresponding opcode_variant().  */
   int    sop;	/* Opcode if jump length is short.  */
   long   lpos;	/* Label position.  */
   long   lop0;	/* Opcode 1 _word_ (16 bits).  */
@@ -143,7 +144,7 @@
 struct hcodes_s 
 {
   char * name;	
-  int    index;		/* Corresponding insn_opnumb.  */
+  int    index;		/* Corresponding opcode_variant().  */
   int    tlab;		/* Number of labels in short mode.  */
   int    op0;		/* Opcode for first word of short jump.  */
   int    op1;		/* Opcode for second word of short jump.  */
@@ -237,107 +238,251 @@
   int mach;
 };
 
-#define MSP430_ISA_11   11
-#define MSP430_ISA_110	110
-#define MSP430_ISA_12   12
-#define MSP430_ISA_13   13
-#define MSP430_ISA_14   14
-#define MSP430_ISA_15   15
-#define MSP430_ISA_16   16
-#define MSP430_ISA_21   21
-#define MSP430_ISA_31   31
-#define MSP430_ISA_32   32
-#define MSP430_ISA_33   33
-#define MSP430_ISA_41   41
-#define MSP430_ISA_42   42
-#define MSP430_ISA_43   43
-#define MSP430_ISA_44   44
-
-#define CHECK_RELOC_MSP430 		((imm_op || byte_op)?BFD_RELOC_MSP430_16_BYTE:BFD_RELOC_MSP430_16)
-#define CHECK_RELOC_MSP430_PCREL	((imm_op || byte_op)?BFD_RELOC_MSP430_16_PCREL_BYTE:BFD_RELOC_MSP430_16_PCREL)
-
-static struct mcu_type_s mcu_types[] =
-{
-  {"msp1",        MSP430_ISA_11, bfd_mach_msp11},
-  {"msp2",        MSP430_ISA_14, bfd_mach_msp14},
-  {"msp430x110",  MSP430_ISA_11, bfd_mach_msp11},
-  {"msp430x112",  MSP430_ISA_11, bfd_mach_msp11},
-  {"msp430x1101", MSP430_ISA_110, bfd_mach_msp110},
-  {"msp430x1111", MSP430_ISA_110, bfd_mach_msp110},
-  {"msp430x1121", MSP430_ISA_110, bfd_mach_msp110},
-  {"msp430x1122", MSP430_ISA_11, bfd_mach_msp110},
-  {"msp430x1132", MSP430_ISA_11, bfd_mach_msp110},
-
-  {"msp430x122",  MSP430_ISA_12, bfd_mach_msp12},
-  {"msp430x123",  MSP430_ISA_12, bfd_mach_msp12},
-  {"msp430x1222", MSP430_ISA_12, bfd_mach_msp12},
-  {"msp430x1232", MSP430_ISA_12, bfd_mach_msp12},
-
-  {"msp430x133",  MSP430_ISA_13, bfd_mach_msp13},
-  {"msp430x135",  MSP430_ISA_13, bfd_mach_msp13},
-  {"msp430x1331", MSP430_ISA_13, bfd_mach_msp13},
-  {"msp430x1351", MSP430_ISA_13, bfd_mach_msp13},
-  {"msp430x147",  MSP430_ISA_14, bfd_mach_msp14},
-  {"msp430x148",  MSP430_ISA_14, bfd_mach_msp14},
-  {"msp430x149",  MSP430_ISA_14, bfd_mach_msp14},
-
-  {"msp430x155",  MSP430_ISA_15, bfd_mach_msp15},
-  {"msp430x156",  MSP430_ISA_15, bfd_mach_msp15},
-  {"msp430x157",  MSP430_ISA_15, bfd_mach_msp15},
-  {"msp430x167",  MSP430_ISA_16, bfd_mach_msp16},
-  {"msp430x168",  MSP430_ISA_16, bfd_mach_msp16},
-  {"msp430x169",  MSP430_ISA_16, bfd_mach_msp16},
-  {"msp430x1610", MSP430_ISA_16, bfd_mach_msp16},
-  {"msp430x1611", MSP430_ISA_16, bfd_mach_msp16},
-  {"msp430x1612", MSP430_ISA_16, bfd_mach_msp16},
-
-  {"msp430x2101", MSP430_ISA_21, bfd_mach_msp21},
-  {"msp430x2111", MSP430_ISA_21, bfd_mach_msp21},
-  {"msp430x2121", MSP430_ISA_21, bfd_mach_msp21},
-  {"msp430x2131", MSP430_ISA_21, bfd_mach_msp21},
+enum
+{
+  CORE_MASK = 0x3,
+  CPU4_BUG = 1 << 2,    // push #4, push #8 cannot use CG
+  CPU7_BUG = 1 << 3,    // CALL and PUSH with @SP+, @SP, and X(SP) uses the SP to calculate the address, then decrements it
+  CPU8_BUG = 1 << 4,    // using odd values with SP
+  CPU11_BUG = 1 << 5,   // When addressing the program counter (PC) in register mode and the PC is the destination, the
+                        // status register (SR) may be erroneous. The instructions BIS, BIC, and MOV do not affect SR contents.
+  CPU12_BUG = 1 << 6,   // Any instruction immediately following a CMP(.B) or BIT(.B) instruction where the PC is the 
+                        // destination address using register mode is ignored or erroneously executed. 
+                        // *** we can issue warning if any instruction other than nop follows cmp(.b) or bit(.b) ***
+  CPU13_BUG = 1 << 7,   // Performing arithmetic operations with the status register as the destination address does not 
+                        // update the status register as intended. The result in SR can be invalid, leading to erroneous low-
+                        // power mode entry. *** we can issue warning ***
+  CPU16_BUG = 1 << 8,   // With indexed addressing mode and instructions calla, mova and bra
+                        // it is not possible to reach memory above 64k if the register content is <64k. 
+};
+static core_t msp430_core( struct mcu_type_s const * mcu )
+{
+  return (core_t)(mcu->isa & CORE_MASK);
+}
+
+#define MSP430_ISA_11           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_110          (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_12           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_13           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_14           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_15           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_16           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_20           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_21           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_21x1         (CORE_430 | CPU4_BUG|CPU11_BUG|CPU12_BUG|CPU13_BUG)
+#define MSP430_ISA_22           (CORE_430)
+#define MSP430_ISA_23           (CORE_430)
+#define MSP430_ISA_24           (CORE_430 | CPU8_BUG)
+#define MSP430_ISA_241          (CORE_430X | CPU7_BUG|CPU8_BUG|CPU16_BUG)
+#define MSP430_ISA_26           (CORE_430X | CPU7_BUG|CPU8_BUG|CPU16_BUG)
+#define MSP430_ISA_31           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_32           (CORE_430 | CPU4_BUG) 
+#define MSP430_ISA_33           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_41           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_42           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_43           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_44           (CORE_430 | CPU4_BUG)
+#define MSP430_ISA_46           (CORE_430X | CPU7_BUG|CPU8_BUG)
+#define MSP430_ISA_47           (CORE_430)
+#define MSP430_ISA_471          (CORE_430X)
+#define MSP430_ISA_54           (CORE_430X2)
+
+#define CHECK_RELOC_MSP430                  ((imm_op || op_width == BYTE_OP) ? BFD_RELOC_MSP430_16_BYTE : BFD_RELOC_MSP430_16)
+#define CHECK_RELOC_MSP430_PCREL            ((imm_op || op_width == BYTE_OP) ? BFD_RELOC_MSP430_16_PCREL_BYTE : BFD_RELOC_MSP430_16_PCREL)
+#define CHECK_RELOC_MSP430X_SRC             ((imm_op || op_width == BYTE_OP) ? BFD_RELOC_MSP430X_SRC_BYTE : BFD_RELOC_MSP430X_SRC)
+#define CHECK_RELOC_MSP430X_PCREL_SRC       ((imm_op || op_width == BYTE_OP) ? BFD_RELOC_MSP430X_PCREL_SRC_BYTE : BFD_RELOC_MSP430X_PCREL_SRC)
+#define CHECK_RELOC_MSP430X_DST             ((imm_op || op_width == BYTE_OP) ? BFD_RELOC_MSP430X_DST_BYTE : BFD_RELOC_MSP430X_DST)
+#define CHECK_RELOC_MSP430X_PCREL_DST       ((imm_op || op_width == BYTE_OP) ? BFD_RELOC_MSP430X_PCREL_DST_BYTE : BFD_RELOC_MSP430X_PCREL_DST)
+#define CHECK_RELOC_MSP430X_DST_2ND         ((imm_op || op_width == BYTE_OP) ? BFD_RELOC_MSP430X_DST_2ND_BYTE : BFD_RELOC_MSP430X_DST_2ND)
+#define CHECK_RELOC_MSP430X_PCREL_DST_2ND   ((imm_op || op_width == BYTE_OP) ? BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE : BFD_RELOC_MSP430X_PCREL_DST_2ND)
+
+static struct mcu_type_s const mcu_types[] =
+{
+  {"msp1",         MSP430_ISA_11,  bfd_mach_msp11},
+  {"msp2",         MSP430_ISA_14,  bfd_mach_msp14},
+  {"msp3",         MSP430_ISA_46,  bfd_mach_msp46},
+  {"msp4",         MSP430_ISA_47,  bfd_mach_msp47},
+  {"msp5",         MSP430_ISA_471, bfd_mach_msp471},
+  {"msp6",         MSP430_ISA_54,  bfd_mach_msp54},
+  {"msp430x110",   MSP430_ISA_11,  bfd_mach_msp11},
+  {"msp430x112",   MSP430_ISA_11,  bfd_mach_msp11},
+  {"msp430x1101",  MSP430_ISA_110, bfd_mach_msp110},
+  {"msp430x1111",  MSP430_ISA_110, bfd_mach_msp110},
+  {"msp430x1121",  MSP430_ISA_110, bfd_mach_msp110},
+  {"msp430x1122",  MSP430_ISA_11,  bfd_mach_msp110},
+  {"msp430x1132",  MSP430_ISA_11,  bfd_mach_msp110},
+
+  {"msp430x122",   MSP430_ISA_12,  bfd_mach_msp12},
+  {"msp430x123",   MSP430_ISA_12,  bfd_mach_msp12},
+  {"msp430x1222",  MSP430_ISA_12,  bfd_mach_msp12},
+  {"msp430x1232",  MSP430_ISA_12,  bfd_mach_msp12},
+
+  {"msp430x133",   MSP430_ISA_13,  bfd_mach_msp13},
+  {"msp430x135",   MSP430_ISA_13,  bfd_mach_msp13},
+  {"msp430x1331",  MSP430_ISA_13,  bfd_mach_msp13},
+  {"msp430x1351",  MSP430_ISA_13,  bfd_mach_msp13},
+  {"msp430x147",   MSP430_ISA_14,  bfd_mach_msp14},
+  {"msp430x148",   MSP430_ISA_14,  bfd_mach_msp14},
+  {"msp430x149",   MSP430_ISA_14,  bfd_mach_msp14},
+  {"msp430x1471",  MSP430_ISA_14,  bfd_mach_msp14},
+  {"msp430x1481",  MSP430_ISA_14,  bfd_mach_msp14},
+  {"msp430x1491",  MSP430_ISA_14,  bfd_mach_msp14},
+
+  {"msp430x155",   MSP430_ISA_15,  bfd_mach_msp15},
+  {"msp430x156",   MSP430_ISA_15,  bfd_mach_msp15},
+  {"msp430x157",   MSP430_ISA_15,  bfd_mach_msp15},
+  {"msp430x167",   MSP430_ISA_16,  bfd_mach_msp16},
+  {"msp430x168",   MSP430_ISA_16,  bfd_mach_msp16},
+  {"msp430x169",   MSP430_ISA_16,  bfd_mach_msp16},
+  {"msp430x1610",  MSP430_ISA_16,  bfd_mach_msp16},
+  {"msp430x1611",  MSP430_ISA_16,  bfd_mach_msp16},
+  {"msp430x1612",  MSP430_ISA_16,  bfd_mach_msp16},
+
+  {"msp430x2001",  MSP430_ISA_20,  bfd_mach_msp20},
+  {"msp430x2011",  MSP430_ISA_20,  bfd_mach_msp20},
+
+  {"msp430x2002",  MSP430_ISA_20,  bfd_mach_msp20},
+  {"msp430x2012",  MSP430_ISA_20,  bfd_mach_msp20},
+
+  {"msp430x2003",  MSP430_ISA_20,  bfd_mach_msp20},
+  {"msp430x2013",  MSP430_ISA_20,  bfd_mach_msp20},
+
+  {"msp430x2101",  MSP430_ISA_21x1,  bfd_mach_msp21},
+  {"msp430x2111",  MSP430_ISA_21x1,  bfd_mach_msp21},
+  {"msp430x2112",  MSP430_ISA_21,  bfd_mach_msp21},
+  {"msp430x2121",  MSP430_ISA_21x1,  bfd_mach_msp21},
+  {"msp430x2122",  MSP430_ISA_21,  bfd_mach_msp21},
+  {"msp430x2131",  MSP430_ISA_21x1,  bfd_mach_msp21},
+  {"msp430x2132",  MSP430_ISA_21,  bfd_mach_msp21},
+
+  {"msp430x2232",  MSP430_ISA_22,  bfd_mach_msp22},
+  {"msp430x2234",  MSP430_ISA_22,  bfd_mach_msp22},
+  {"msp430x2252",  MSP430_ISA_22,  bfd_mach_msp22},
+  {"msp430x2254",  MSP430_ISA_22,  bfd_mach_msp22},
+  {"msp430x2272",  MSP430_ISA_22,  bfd_mach_msp22},
+  {"msp430x2274",  MSP430_ISA_22,  bfd_mach_msp22},
+
+  {"msp430x233",   MSP430_ISA_24,  bfd_mach_msp24},
+  {"msp430x235",   MSP430_ISA_24,  bfd_mach_msp24},
+  {"msp430x2330",  MSP430_ISA_23,  bfd_mach_msp23},
+  {"msp430x2350",  MSP430_ISA_23,  bfd_mach_msp23},
+  {"msp430x2370",  MSP430_ISA_23,  bfd_mach_msp23},
+
+  {"msp430x247",   MSP430_ISA_24,  bfd_mach_msp24},
+  {"msp430x2471",  MSP430_ISA_24,  bfd_mach_msp24},
+  {"msp430x248",   MSP430_ISA_24,  bfd_mach_msp24},
+  {"msp430x2481",  MSP430_ISA_24,  bfd_mach_msp24},
+  {"msp430x249",   MSP430_ISA_24,  bfd_mach_msp24},
+  {"msp430x2491",  MSP430_ISA_24,  bfd_mach_msp24},
+  {"msp430x2410",  MSP430_ISA_24,  bfd_mach_msp24},
+
+  {"msp430x2416",  MSP430_ISA_241, bfd_mach_msp241},
+  {"msp430x2417",  MSP430_ISA_241, bfd_mach_msp241},
+  {"msp430x2418",  MSP430_ISA_241, bfd_mach_msp241},
+  {"msp430x2419",  MSP430_ISA_241, bfd_mach_msp241},
   
-  {"msp430x311",  MSP430_ISA_31, bfd_mach_msp31},
-  {"msp430x312",  MSP430_ISA_31, bfd_mach_msp31},
-  {"msp430x313",  MSP430_ISA_31, bfd_mach_msp31},
-  {"msp430x314",  MSP430_ISA_31, bfd_mach_msp31},
-  {"msp430x315",  MSP430_ISA_31, bfd_mach_msp31},
-  {"msp430x323",  MSP430_ISA_32, bfd_mach_msp32},
-  {"msp430x325",  MSP430_ISA_32, bfd_mach_msp32},
-  {"msp430x336",  MSP430_ISA_33, bfd_mach_msp33},
-  {"msp430x337",  MSP430_ISA_33, bfd_mach_msp33},
-
-  {"msp430x412",  MSP430_ISA_41, bfd_mach_msp41},
-  {"msp430x413",  MSP430_ISA_41, bfd_mach_msp41},
-  {"msp430x415",  MSP430_ISA_41, bfd_mach_msp41},
-  {"msp430x417",  MSP430_ISA_41, bfd_mach_msp41},
-
-  {"msp430xE423", MSP430_ISA_42, bfd_mach_msp42},
-  {"msp430xE425", MSP430_ISA_42, bfd_mach_msp42},
-  {"msp430xE427", MSP430_ISA_42, bfd_mach_msp42},
-
-  {"msp430xW423", MSP430_ISA_42, bfd_mach_msp42},
-  {"msp430xW425", MSP430_ISA_42, bfd_mach_msp42},
-  {"msp430xW427", MSP430_ISA_42, bfd_mach_msp42},
-
-  {"msp430xG437", MSP430_ISA_43, bfd_mach_msp43},
-  {"msp430xG438", MSP430_ISA_43, bfd_mach_msp43},
-  {"msp430xG439", MSP430_ISA_43, bfd_mach_msp43},
-
-  {"msp430x435",  MSP430_ISA_43, bfd_mach_msp43},
-  {"msp430x436",  MSP430_ISA_43, bfd_mach_msp43},
-  {"msp430x437",  MSP430_ISA_43, bfd_mach_msp43},
-  {"msp430x447",  MSP430_ISA_44, bfd_mach_msp44},
-  {"msp430x448",  MSP430_ISA_44, bfd_mach_msp44},
-  {"msp430x449",  MSP430_ISA_44, bfd_mach_msp44},
+  {"msp430x2616",  MSP430_ISA_26,  bfd_mach_msp26},
+  {"msp430x2617",  MSP430_ISA_26,  bfd_mach_msp26},
+  {"msp430x2618",  MSP430_ISA_26,  bfd_mach_msp26},
+  {"msp430x2619",  MSP430_ISA_26,  bfd_mach_msp26},
+  
+  {"msp430x311",   MSP430_ISA_31,  bfd_mach_msp31},
+  {"msp430x312",   MSP430_ISA_31,  bfd_mach_msp31},
+  {"msp430x313",   MSP430_ISA_31,  bfd_mach_msp31},
+  {"msp430x314",   MSP430_ISA_31,  bfd_mach_msp31},
+  {"msp430x315",   MSP430_ISA_31,  bfd_mach_msp31},
+  {"msp430x323",   MSP430_ISA_32,  bfd_mach_msp32},
+  {"msp430x325",   MSP430_ISA_32,  bfd_mach_msp32},
+  {"msp430x336",   MSP430_ISA_33,  bfd_mach_msp33},
+  {"msp430x337",   MSP430_ISA_33,  bfd_mach_msp33},
+
+  {"msp430x412",   MSP430_ISA_41,  bfd_mach_msp41},
+  {"msp430x413",   MSP430_ISA_41,  bfd_mach_msp41},
+  {"msp430x415",   MSP430_ISA_41,  bfd_mach_msp41},
+  {"msp430x417",   MSP430_ISA_41,  bfd_mach_msp41},
+
+  {"msp430x423",   MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430x425",   MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430x427",   MSP430_ISA_42,  bfd_mach_msp42},
+
+  {"msp430x4250",  MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430x4260",  MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430x4270",  MSP430_ISA_42,  bfd_mach_msp42},
+
+  {"msp430xG4250", MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xG4260", MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xG4270", MSP430_ISA_42,  bfd_mach_msp42},
+
+  {"msp430xE423",  MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xE4232", MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xE4242", MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xE4252", MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xE425",  MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xE427",  MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xE4272", MSP430_ISA_42,  bfd_mach_msp42},
+
+  {"msp430xW423",  MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xW425",  MSP430_ISA_42,  bfd_mach_msp42},
+  {"msp430xW427",  MSP430_ISA_42,  bfd_mach_msp42},
+
+  {"msp430xG437",  MSP430_ISA_43,  bfd_mach_msp43},
+  {"msp430xG438",  MSP430_ISA_43,  bfd_mach_msp43},
+  {"msp430xG439",  MSP430_ISA_43,  bfd_mach_msp43},
+
+  {"msp430x435",   MSP430_ISA_43,  bfd_mach_msp43},
+  {"msp430x4351",  MSP430_ISA_43,  bfd_mach_msp43},
+  {"msp430x436",   MSP430_ISA_43,  bfd_mach_msp43},
+  {"msp430x4361",  MSP430_ISA_43,  bfd_mach_msp43},
+  {"msp430x437",   MSP430_ISA_43,  bfd_mach_msp43},
+  {"msp430x4371",  MSP430_ISA_43,  bfd_mach_msp43},
+  {"msp430x447",   MSP430_ISA_44,  bfd_mach_msp44},
+  {"msp430x448",   MSP430_ISA_44,  bfd_mach_msp44},
+  {"msp430x449",   MSP430_ISA_44,  bfd_mach_msp44},
+
+  {"msp430xG4616", MSP430_ISA_46,  bfd_mach_msp46},
+  {"msp430xG4617", MSP430_ISA_46,  bfd_mach_msp46},
+  {"msp430xG4618", MSP430_ISA_46,  bfd_mach_msp46},
+  {"msp430xG4619", MSP430_ISA_46,  bfd_mach_msp46},
+
+  {"msp430x4783",  MSP430_ISA_47,  bfd_mach_msp47},
+  {"msp430x4784",  MSP430_ISA_47,  bfd_mach_msp47},
+  {"msp430x4793",  MSP430_ISA_47,  bfd_mach_msp47},
+  {"msp430x4794",  MSP430_ISA_47,  bfd_mach_msp47},
+  
+  {"msp430x47166", MSP430_ISA_471, bfd_mach_msp471},
+  {"msp430x47176", MSP430_ISA_471, bfd_mach_msp471},
+  {"msp430x47186", MSP430_ISA_471, bfd_mach_msp471},
+  {"msp430x47196", MSP430_ISA_471, bfd_mach_msp471},
+
+  {"msp430x47167", MSP430_ISA_471, bfd_mach_msp471},
+  {"msp430x47177", MSP430_ISA_471, bfd_mach_msp471},
+  {"msp430x47187", MSP430_ISA_471, bfd_mach_msp471},
+  {"msp430x47197", MSP430_ISA_471, bfd_mach_msp471},
+
+  {"msp430x5418",  MSP430_ISA_54,  bfd_mach_msp54},
+  {"msp430x5419",  MSP430_ISA_54,  bfd_mach_msp54},
+  {"msp430x5435",  MSP430_ISA_54,  bfd_mach_msp54},
+  {"msp430x5436",  MSP430_ISA_54,  bfd_mach_msp54},
+  {"msp430x5437",  MSP430_ISA_54,  bfd_mach_msp54},
+  {"msp430x5438",  MSP430_ISA_54,  bfd_mach_msp54},
+
+  {"cc430x5123",   MSP430_ISA_54,  bfd_mach_msp54},
+  {"cc430x5125",   MSP430_ISA_54,  bfd_mach_msp54},
+  {"cc430x6125",   MSP430_ISA_54,  bfd_mach_msp54},
+  {"cc430x6135",   MSP430_ISA_54,  bfd_mach_msp54},
+  {"cc430x6126",   MSP430_ISA_54,  bfd_mach_msp54},
+  {"cc430x5137",   MSP430_ISA_54,  bfd_mach_msp54},
+  {"cc430x6127",   MSP430_ISA_54,  bfd_mach_msp54},
+  {"cc430x6137",   MSP430_ISA_54,  bfd_mach_msp54},
 
   {NULL, 0, 0}
 };
 
 
-static struct mcu_type_s default_mcu =
+static struct mcu_type_s const default_mcu =
     { "msp430x11", MSP430_ISA_11, bfd_mach_msp11 };
 
-static struct mcu_type_s * msp430_mcu = & default_mcu;
+static struct mcu_type_s const * msp430_mcu = & default_mcu;
 
 /* Profiling capability:
    It is a performance hit to use gcc's profiling approach for this tiny target.
@@ -446,11 +591,14 @@
 static char *
 parse_exp (char * s, expressionS * op)
 {
+  char * in_save = input_line_pointer;
   input_line_pointer = s;
   expression (op);
+  s = input_line_pointer;
+  input_line_pointer = in_save;
   if (op->X_op == O_absent)
     as_bad (_("missing operand"));
-  return input_line_pointer;
+  return s;
 }
 
 
@@ -504,7 +652,8 @@
   *(to + size) = 0;
   del_spaces (to);
 
-  from++;
+  if(*from == ',')
+    from++;
 
   return from;
 }
@@ -549,7 +698,8 @@
       return;
     }
 
-  input_line_pointer = extract_operand (input_line_pointer, flags, 32);
+  input_line_pointer = extract_operand (input_line_pointer, flags, 32)
+                        + 1;    // skip trailing zero
 
   while (*flags)
     {
@@ -662,7 +812,7 @@
       /* Process like ".word xxx" directive.  */
       parse_exp (str, & exp);
       emit_expr (& exp, 2);
-      input_line_pointer = halt;
+      input_line_pointer = halt + 1;
     }
 
   /* Fill the rest with zeros.  */
@@ -766,11 +916,14 @@
   return 0;
 }
 
+static void
+msp430_repeat_insn (int dummy ATTRIBUTE_UNUSED);
 
 const pseudo_typeS md_pseudo_table[] =
 {
   {"arch", msp430_set_arch, 0},
   {"profiler", msp430_profiler, 0},
+  {"rpt", msp430_repeat_insn, 0},
   {NULL, NULL, 0}
 };
 
@@ -792,26 +945,57 @@
   fprintf (stream,
 	   _("MSP430 options:\n"
 	     "  -mmcu=[msp430-name] select microcontroller type\n"
-	     "                  msp430x110  msp430x112\n"
-	     "                  msp430x1101 msp430x1111\n"
-	     "                  msp430x1121 msp430x1122 msp430x1132\n"
-	     "                  msp430x122  msp430x123\n"
-	     "                  msp430x1222 msp430x1232\n"
-	     "                  msp430x133  msp430x135\n"
-	     "                  msp430x1331 msp430x1351\n"
-	     "                  msp430x147  msp430x148  msp430x149\n"
-	     "                  msp430x155  msp430x156  msp430x157\n"
-	     "                  msp430x167  msp430x168  msp430x169\n"
-	     "                  msp430x1610 msp430x1611 msp430x1612\n"
-	     "                  msp430x311  msp430x312  msp430x313  msp430x314  msp430x315\n"
-	     "                  msp430x323  msp430x325\n"
-	     "                  msp430x336  msp430x337\n"
-	     "                  msp430x412  msp430x413  msp430x415  msp430x417\n"
-	     "                  msp430xE423 msp430xE425 msp430E427\n"
-	     "                  msp430xW423 msp430xW425 msp430W427\n"
-	     "                  msp430xG437 msp430xG438 msp430G439\n"
-	     "                  msp430x435  msp430x436  msp430x437\n"
-	     "                  msp430x447  msp430x448  msp430x449\n"));
+	     "                  msp430x110   msp430x112\n"
+	     "                  msp430x1101  msp430x1111  msp430x1121\n"
+	     "                  msp430x1122  msp430x1132\n"
+	     "                  msp430x122   msp430x123\n"
+	     "                  msp430x1222  msp430x1232\n"
+	     "                  msp430x133   msp430x135\n"
+	     "                  msp430x1331  msp430x1351\n"
+	     "                  msp430x147   msp430x148   msp430x149\n"
+	     "                  msp430x1471  msp430x1481  msp430x1491\n"
+	     "                  msp430x155   msp430x156   msp430x157\n"
+	     "                  msp430x167   msp430x168   msp430x169\n"
+	     "                  msp430x1610  msp430x1611  msp430x1612\n"
+	     "                  msp430x2001  msp430x2011\n"
+	     "                  msp430x2002  msp430x2012\n"
+	     "                  msp430x2003  msp430x2013\n"
+	     "                  msp430x2101  msp430x2111  msp430x2121  msp430x2131\n"
+	     "                  msp430x2112  msp430x2122  msp430x2132\n"
+	     "                  msp430x2232  msp430x2252  msp430x2272\n"
+	     "                  msp430x2234  msp430x2254  msp430x2274\n"
+	     "                  msp430x233   msp430x235\n"
+	     "                  msp430x2330  msp430x2350  msp430x2370\n"
+	     "                  msp430x247   msp430x248   msp430x249   msp430x2410\n"
+	     "                  msp430x2471  msp430x2481  msp430x2491\n"
+	     "                  msp430x2416  msp430x2417  msp430x2418  msp430x2419\n"
+	     "                  msp430x2616  msp430x2617  msp430x2618  msp430x2619\n"
+	     "                  msp430x311   msp430x312   msp430x313   msp430x314  msp430x315\n"
+	     "                  msp430x323   msp430x325\n" 
+	     "                  msp430x336   msp430x337\n"
+	     "                  msp430x412   msp430x413   msp430x415   msp430x417\n"
+	     "                  msp430x423   msp430x425   msp430427\n"
+	     "                  msp430x4250  msp430x4260  msp4304270\n"
+	     "                  msp430xE423  msp430xE425  msp430E427\n"
+	     "                  msp430xE4232 msp430xE4242 msp430xE4252 msp430E4272\n"
+	     "                  msp430xW423  msp430xW425  msp430W427\n"
+	     "                  msp430xG4250 msp430xG4260 msp430G4270\n"
+	     "                  msp430xG437  msp430xG438  msp430G439\n"
+	     "                  msp430x435   msp430x436   msp430x437\n"
+	     "                  msp430x4351  msp430x4361  msp430x4371\n"
+	     "                  msp430x447   msp430x448   msp430x449\n"
+	     "                  msp430xG4616 msp430xG4617 msp430xG4618 msp430xG4619\n"
+	     "                  msp430x4783  msp430x4784  msp430x4793  msp430x4794\n"
+	     "                  msp430x47166 msp430x47176 msp430x47186  msp430x47196\n"
+	     "                  msp430x47167 msp430x47177 msp430x47187  msp430x47197\n"
+	     "                  msp430x5418  msp430xG5419\n"
+	     "                  msp430x5435  msp430x5436  msp430x5437  msp430x5438\n"
+	     "                  cc430x5123\n"
+	     "                  cc430x5125   cc430x6125   cc430x6135\n"
+	     "                  cc430x6126\n"
+	     "                  cc430x5137   cc430x6127   cc430x6137\n"
+             
+             ));
   fprintf (stream,
 	   _("  -mQ - enable relaxation at assembly time. DANGEROUS!\n"
 	     "  -mP - enable polymorph instructions\n"));
@@ -851,7 +1035,7 @@
 void
 md_begin (void)
 {
-  struct msp430_opcode_s * opcode;
+  struct msp430_opcode_s const * opcode;
   msp430_hash = hash_new ();
 
   for (opcode = msp430_opcodes; opcode->name; opcode++)
@@ -881,10 +1065,63 @@
   return 0;
 }
 
+static void 
+msp430_substitute_CG(struct msp430_operand_s * op, int workaround)
+{
+  /* Substitute register mode with a constant generator if applicable.  */
+  if( op->mode != OP_EXP || ( op->exp.X_op != O_constant && op->exp.X_op != O_big ))
+    return;
+  if( op->am != 3 || op->reg != 0 )     // not #N
+    return;
+  int x = (short) op->exp.X_add_number;	/* Extend sign.  */
+
+  if (x == 0)
+    {
+      op->reg = 3;
+      op->am = 0;
+      op->ol = 0;
+      op->mode = OP_REG;
+    }
+  else if (x == 1)
+    {
+      op->reg = 3;
+      op->am = 1;
+      op->ol = 0;
+      op->mode = OP_REG;
+    }
+  else if (x == 2)
+    {
+      op->reg = 3;
+      op->am = 2;
+      op->ol = 0;
+      op->mode = OP_REG;
+    }
+  else if (x == -1)
+    {
+      op->reg = 3;
+      op->am = 3;
+      op->ol = 0;
+      op->mode = OP_REG;
+    }
+  else if (x == 4 && !workaround)
+    {
+      op->reg = 2;
+      op->am = 2;
+      op->ol = 0;
+      op->mode = OP_REG;
+    }
+  else if (x == 8 && ! workaround)
+    {
+      op->reg = 2;
+      op->am = 3;
+      op->ol = 0;
+      op->mode = OP_REG;
+    }
+}
 
 static int
 msp430_srcoperand (struct msp430_operand_s * op,
-		   char * l, int bin, int * imm_op)
+		   char * l, int * imm_op, int imm_min, int imm_max)
 {
   char *__tl = l;
 
@@ -965,79 +1202,11 @@
 	      x = op->exp.X_add_number;
 	    }
 
-	  if (op->exp.X_add_number > 65535 || op->exp.X_add_number < -32768)
-	    {
-	      as_bad (_("value %d out of range. Use #lo() or #hi()"), x);
+        if (x >= imm_max || x < imm_min)
+        {
+	      as_bad (_("value %d out of %d...%d (0x%X...0x%X) range."), x, imm_min, imm_max - 1, imm_min, imm_max - 1);
 	      return 1;
 	    }
-
-	  /* Now check constants.  */
-	  /* Substitute register mode with a constant generator if applicable.  */
-
-	  x = (short) x;	/* Extend sign.  */
-
-	  if (x == 0)
-	    {
-	      op->reg = 3;
-	      op->am = 0;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
-	  else if (x == 1)
-	    {
-	      op->reg = 3;
-	      op->am = 1;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
-	  else if (x == 2)
-	    {
-	      op->reg = 3;
-	      op->am = 2;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
-	  else if (x == -1)
-	    {
-	      op->reg = 3;
-	      op->am = 3;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
-	  else if (x == 4)
-	    {
-#ifdef PUSH_1X_WORKAROUND
-	      if (bin == 0x1200)
-		{
-		  /* Remove warning as confusing.
-		     as_warn (_("Hardware push bug workaround")); */
-		}
-	      else
-#endif
-		{
-		  op->reg = 2;
-		  op->am = 2;
-		  op->ol = 0;
-		  op->mode = OP_REG;
-		}
-	    }
-	  else if (x == 8)
-	    {
-#ifdef PUSH_1X_WORKAROUND
-	      if (bin == 0x1200)
-		{
-		  /* Remove warning as confusing.
-		     as_warn (_("Hardware push bug workaround")); */
-		}
-	      else
-#endif
-		{
-		  op->reg = 2;
-		  op->am = 3;
-		  op->ol = 0;
-		  op->mode = OP_REG;
-		}
-	    }
 	}
       else if (op->exp.X_op == O_symbol)
 	{
@@ -1045,12 +1214,10 @@
 	}
       else if (op->exp.X_op == O_big)
 	{
-	  short x;
 	  if (vshift != -1)
 	    {
 	      op->exp.X_op = O_constant;
 	      op->exp.X_add_number = 0xffff & generic_bignum[vshift];
-	      x = op->exp.X_add_number;
 	    }
 	  else
 	    {
@@ -1059,49 +1226,6 @@
 		      l);
 	      return 1;
 	    }
-
-	  if (x == 0)
-	    {
-	      op->reg = 3;
-	      op->am = 0;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
-	  else if (x == 1)
-	    {
-	      op->reg = 3;
-	      op->am = 1;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
-	  else if (x == 2)
-	    {
-	      op->reg = 3;
-	      op->am = 2;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
-	  else if (x == -1)
-	    {
-	      op->reg = 3;
-	      op->am = 3;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
-	  else if (x == 4)
-	    {
-	      op->reg = 2;
-	      op->am = 2;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
-	  else if (x == 8)
-	    {
-	      op->reg = 2;
-	      op->am = 3;
-	      op->ol = 0;
-	      op->mode = OP_REG;
-	    }
 	}
       /* Redundant (yet) check.  */
       else if (op->exp.X_op == O_register)
@@ -1128,7 +1252,7 @@
 	{
 	  int x = op->exp.X_add_number;
 
-	  if (x > 65535 || x < -32768)
+          if (x >= imm_max || x < imm_min)
 	    {
 	      as_bad (_("value out of range: %d"), x);
 	      return 1;
@@ -1263,7 +1387,7 @@
 	{
 	  int x = op->exp.X_add_number;
 
-	  if (x > 65535 || x < -32768)
+          if (x > imm_max || x < imm_min)
 	    {
 	      as_bad (_("value out of range: %d"), x);
 	      return 1;
@@ -1339,10 +1463,10 @@
 
 
 static int
-msp430_dstoperand (struct msp430_operand_s * op, char * l, int bin)
+msp430_dstoperand (struct msp430_operand_s * op, char * l, int imm_min, int imm_max)
 {
   int dummy;
-  int ret = msp430_srcoperand (op, l, bin, & dummy);
+  int ret = msp430_srcoperand (op, l, & dummy, imm_min, imm_max);
 
   if (ret)
     return ret;
@@ -1374,39 +1498,135 @@
   return 0;
 }
 
+static void
+msp430_repeat_insn (int dummy ATTRIBUTE_UNUSED)
+{
+  char operand[MAX_OP_LEN];
+  struct msp430_operand_s op;
+  int imm_op = 0;
+  char *line = input_line_pointer;
+
+  if (msp430_core(msp430_mcu) < CORE_430X)
+    {
+      as_bad (_("Repeatable instructions not allowed with %s mcu"), msp430_mcu->name);
+      return;
+    }
+
+  if (msp430x_repeats)
+    as_warn (_("two consecutive .rpt pseudo-ops. Previous .rpt discarded"));
+  
+  if (!*line || *line == '\n')
+    {
+      as_bad (_("rpt pseudo-op requires 1 operand"));
+      return;
+    }
+
+  memset (&op, 0, sizeof (op));
+
+  input_line_pointer = extract_operand (line, operand, sizeof(operand));
+
+  if (msp430_srcoperand(&op, operand, &imm_op, 1, 15) != 0)
+    return;
+  
+  if ( !(op.mode == OP_REG && op.am == 0)   // Rn
+    && !(op.mode == OP_EXP && op.am == 3)   // #N
+     )
+    {
+      as_bad (_("rpt pseudo-op requires immediate or register operand"));
+      return;
+    }
+
+  if (op.am == 0)       // rpt Rn
+     msp430x_repeats = (((1 << 7) | op.reg) << 1) | 1;          // last bit as .rpt flag
+  else                  // rpt #N
+     msp430x_repeats = ((op.exp.X_add_number - 1) << 1) | 1;    // last bit as .rpt flag
+}
 
 /* Parse instruction operands.
    Return binary opcode.  */
 
 static unsigned int
-msp430_operands (struct msp430_opcode_s * opcode, char * line)
+msp430_operands (struct msp430_opcode_s const * opcode, char * line)
 {
   int bin = opcode->bin_opcode;	/* Opcode mask.  */
   int __is = 0;
   char l1[MAX_OP_LEN], l2[MAX_OP_LEN];
-  char *frag;
-  int where;
+  char *frag = 0;
+  int where = 0;
   struct msp430_operand_s op1, op2;
   int res = 0;
   static short ZEROS = 0;
-  int byte_op, imm_op;
-
+  int imm_op;
+  opwidth_t op_width = DEFAULT_OP;
+  
   /* Opcode is the one from opcodes table
      line contains something like
      [.w] @r2+, 5(R1)
      or
-     .b @r2+, 5(R1).  */
+     .b @r2+, 5(R1)
+     or
+     .a @r2+, 5(R1)   */
 
   /* Check if byte or word operation.  */
+  
   if (*line == '.' && TOLOWER (*(line + 1)) == 'b')
     {
-      bin |= BYTE_OPERATION;
-      byte_op = 1;
+      op_width = BYTE_OP;
+    }
+  else if (*line == '.' && TOLOWER (*(line + 1)) == 'w')
+    {
+      op_width = WORD_OP;
+    }
+  else if (*line == '.' && TOLOWER (*(line + 1)) == 'a')
+    {
+      op_width = ADDR_OP;
     }
-  else
-    byte_op = 0;
 
-  /* skip .[bwBW].  */
+  if ((op_width == WORD_OP && !(opcode_modifier(opcode) & MOD_W))
+      || (op_width == BYTE_OP && !(opcode_modifier(opcode) & MOD_B))
+      || (op_width == ADDR_OP && !(opcode_modifier(opcode) & MOD_A))
+     )
+    {
+      static char* const modifier[] = { "", ".w", ".b", ".a" };
+      as_bad (_("%s not allowed with %s instruction"),
+	      modifier[op_width], opcode->name);
+      return 0;
+    }
+
+   if ( opcode_format(opcode) ==  FMT_X_DOUBLE_OPERAND 
+       || opcode_format(opcode) ==  FMT_X_SINGLE_OPERAND  
+       || opcode_format(opcode) ==  FMT_X_EMULATED 
+      )
+    {
+      switch(op_width)
+      {
+      case DEFAULT_OP:
+      case WORD_OP:
+          bin |= NON_ADDR_OPERATION;
+          break;
+      case BYTE_OP:
+          bin |= NON_ADDR_OPERATION;
+          bin |= BYTE_OPERATION_X;
+          break;
+      case ADDR_OP:
+          bin |= BYTE_OPERATION_X;
+          break;
+      }
+    }
+  else
+    {
+      if(msp430x_repeats)
+        {
+          as_bad (_("%s instruction is not repeatable"), opcode->name);
+          return 0;
+        }
+
+      if ( opcode_format(opcode) < FMT_X && op_width == BYTE_OP )         // 430 instructions
+        {
+          bin |= BYTE_OPERATION;
+        }
+    }
+  /* skip .[abwABW].  */
   while (! ISSPACE (*line) && *line)
     line++;
 
@@ -1424,22 +1644,22 @@
 
   imm_op = 0;
 
-  switch (opcode->fmt)
+  switch (opcode_format(opcode))
     {
-    case 0:			/* Emulated.  */
-      switch (opcode->insn_opnumb)
+    case FMT_EMULATED:			/* Emulated.  */
+      switch (opcode_variant(opcode))
 	{
-	case 0:
-	  /* Set/clear bits instructions.  */
+	case V_NOOP:
+	  /* Set/clear SR bits instructions, ret, nop  */
 	  __is = 2;
 	  frag = frag_more (__is);
 	  bfd_putl16 ((bfd_vma) bin, frag);
 	  dwarf2_emit_insn (__is);
 	  break;
-	case 1:
+	case V_NONE:
 	  /* Something which works with destination operand.  */
 	  line = extract_operand (line, l1, sizeof (l1));
-	  res = msp430_dstoperand (&op1, l1, opcode->bin_opcode);
+	  res = msp430_dstoperand (&op1, l1, -(1<<15), (1<<16) );
 	  if (res)
 	    break;
 
@@ -1464,14 +1684,15 @@
 	    }
 	  break;
 
-	case 2:
+	case V_SHIFT:
 	  {
 	    /* Shift instruction.  */
 	    line = extract_operand (line, l1, sizeof (l1));
 	    strncpy (l2, l1, sizeof (l2));
 	    l2[sizeof (l2) - 1] = '\0';
-	    res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
-	    res += msp430_dstoperand (&op2, l2, opcode->bin_opcode);
+	    res = msp430_srcoperand (&op1, l1, &imm_op, -(1<<15), (1<<16));
+            msp430_substitute_CG(&op1, 0);
+	    res += msp430_dstoperand (&op2, l2, -(1<<15), (1<<16));
 
 	    if (res)
 	      break;	/* An error occurred.  All warnings were done before.  */
@@ -1499,7 +1720,12 @@
 
 	    if (op2.mode == OP_EXP)
 	      {
-		imm_op = 0;
+                /*
+                  x(Rn). x can be odd in non-byte operations
+                  except x(R2) = x(0) = &TONI and x(PC) = TONI
+                */
+	        imm_op = (op2.mode == 1 && op2.reg != 2 && op2.reg != 0);
+
 		bfd_putl16 ((bfd_vma) ZEROS, frag + 2 + ((__is == 3) ? 2 : 0));
 
 		if (op2.reg)	/* Not PC relative.  */
@@ -1511,16 +1737,21 @@
 	      }
 	    break;
 	  }
-	case 3:
+	case V_BR:
 	  /* Branch instruction => mov dst, r0.  */
 	  line = extract_operand (line, l1, sizeof (l1));
 
-	  res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
+	  res = msp430_srcoperand (&op1, l1, &imm_op, -(1<<15), (1<<16));
+          msp430_substitute_CG(&op1, 0);
 	  if (res)
 	    break;
 
-	  byte_op = 0;
-	  imm_op = 0;
+	  if (op1.mode == 1 && (op1.reg == 2 || op1.reg == 0))
+            /*
+              x(Rn). x can be odd in non-byte operations
+              except x(R2) = x(0) = &EDE and x(PC) = EDE
+            */
+	    imm_op = 0;
 
 	  bin |= ((op1.reg << 8) | (op1.am << 4));
 	  __is = 1 + op1.ol;
@@ -1545,11 +1776,12 @@
 	}
       break;
 
-    case 1:			/* Format 1, double operand.  */
+    case FMT_DOUBLE_OPERAND:		/* Format 1, double operand.  */
       line = extract_operand (line, l1, sizeof (l1));
       line = extract_operand (line, l2, sizeof (l2));
-      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
-      res += msp430_dstoperand (&op2, l2, opcode->bin_opcode);
+      res = msp430_srcoperand (&op1, l1, &imm_op, -(1<<15), (1<<16));
+      msp430_substitute_CG(&op1, 0);
+      res += msp430_dstoperand (&op2, l2, -(1<<15), (1<<16));
 
       if (res)
 	break;			/* Error occurred.  All warnings were done before.  */
@@ -1577,7 +1809,12 @@
 
       if (op2.mode == OP_EXP)
 	{
-	  imm_op = 0;
+          /*
+            x(Rn). x can be odd in non-byte operations
+            except x(R2) = x(0) = &TONI and x(PC) = TONI
+          */
+	  imm_op = (op2.mode == 1 && op2.reg != 2 && op2.reg != 0);
+
 	  bfd_putl16 ((bfd_vma) ZEROS, frag + 2 + ((__is == 3) ? 2 : 0));
 
 	  if (op2.reg)		/* Not PC relative.  */
@@ -1589,8 +1826,8 @@
 	}
       break;
 
-    case 2:			/* Single-operand mostly instr.  */
-      if (opcode->insn_opnumb == 0)
+    case FMT_SINGLE_OPERAND:			/* Single-operand mostly instr.  */
+      if (opcode_variant(opcode) == V_RETI)
 	{
 	  /* reti instruction.  */
 	  frag = frag_more (2);
@@ -1600,9 +1837,10 @@
 	}
 
       line = extract_operand (line, l1, sizeof (l1));
-      res = msp430_srcoperand (&op1, l1, opcode->bin_opcode, &imm_op);
+      res = msp430_srcoperand (&op1, l1, &imm_op, -(1<<15), (1<<16));
       if (res)
 	break;		/* Error in operand.  */
+      msp430_substitute_CG(&op1, (msp430_mcu->isa & CPU4_BUG) && (opcode->bin_opcode == 0x1200));
 
       bin |= op1.reg | (op1.am << 4);
       __is = 1 + op1.ol;
@@ -1624,7 +1862,7 @@
 	}
       break;
 
-    case 3:			/* Conditional jumps instructions.  */
+    case FMT_JUMP:			/* Conditional jumps instructions.  */
       line = extract_operand (line, l1, sizeof (l1));
       /* l1 is a label.  */
       if (l1[0])
@@ -1694,11 +1932,13 @@
 	  else if (*l1 == '$')
 	    {
 	      as_bad (_("instruction requires label sans '$'"));
+              break;
 	    }
 	  else
 	    {
 	      as_bad (_
 		      ("instruction requires label or value in range -511:512"));
+              break;
 	    }
 	  dwarf2_emit_insn (2 * __is);
 	  break;
@@ -1710,7 +1950,7 @@
 	}
       break;
 
-    case 4:	/* Extended jumps.  */
+    case FMT_EMULATED_POLYMORPH_JUMP:	/* Extended jumps.  */
       if (!msp430_enable_polys)
 	{
 	  as_bad (_("polymorphs are not enabled. Use -mP option to enable."));
@@ -1731,7 +1971,7 @@
 	  if (exp.X_op == O_symbol)
 	    {
 	      /* Relaxation required.  */
-	      struct rcodes_s rc = msp430_rcodes[opcode->insn_opnumb];
+	      struct rcodes_s rc = msp430_rcodes[opcode_variant(opcode)];
 
 	      /* The parameter to dwarf2_emit_insn is actually the offset to the start
 		 of the insn from the fix piece of instruction that was emitted.
@@ -1752,7 +1992,7 @@
       as_bad (_("instruction requires label"));
       break;
 
-    case 5:	/* Emulated extended branches.  */
+    case FMT_EMULATED_LONG_POLYMORPH_JUMP:	/* Emulated extended branches.  */
       if (!msp430_enable_polys)
 	{
 	  as_bad (_("polymorphs are not enabled. Use -mP option to enable."));
@@ -1772,7 +2012,7 @@
 	  if (exp.X_op == O_symbol)
 	    {
 	      /* Relaxation required.  */
-	      struct hcodes_s hc = msp430_hcodes[opcode->insn_opnumb];
+	      struct hcodes_s hc = msp430_hcodes[opcode_variant(opcode)];
 
 	      frag = frag_more (8);
 	      dwarf2_emit_insn (0);
@@ -1791,18 +2031,680 @@
       as_bad (_("instruction requires label"));
       break;
 
+    case FMT_X_DOUBLE_OPERAND:		/* Extended Format 1 ( double operand). */
+      line = extract_operand (line, l1, sizeof (l1));
+      line = extract_operand (line, l2, sizeof (l2));
+      res = msp430_srcoperand (&op1, l1,  &imm_op, -(1<<19), (1<<20));
+      msp430_substitute_CG(&op1, 0);
+      res += msp430_dstoperand (&op2, l2, -(1<<19), (1<<20));
+
+      if (res)
+	break;			/* Error occurred.  All warnings were done before.  */
+
+      if (msp430x_repeats)
+        {
+          if (op1.mode != OP_REG || op2.mode != OP_REG)
+            {
+              as_bad(_("Repeated instruction must have register mode operands"));
+              break;
+            }
+          bin |= msp430x_repeats >> 1;
+          msp430x_repeats = 0;
+        }
+
+      bin |= (op2.reg | (op1.reg << 8) | (op1.am << 4) | (op2.am << 7)) << 16;
+
+      __is = 2 + op1.ol + op2.ol;	/* insn size in words, opcode is 2 words wide.  */
+      frag = frag_more (2 * __is);
+      where = frag - frag_now->fr_literal;
+      bfd_putl32 ((bfd_vma) bin, frag);
+      dwarf2_emit_insn (2 * __is);
+
+      if (op1.mode == OP_EXP)
+	{
+	  bfd_putl16 ((bfd_vma) ZEROS, frag + 4);
+
+	  if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
+	    fix_new_exp (frag_now, where, 2,
+			 &(op1.exp), FALSE, CHECK_RELOC_MSP430X_SRC);
+	  else
+	    fix_new_exp (frag_now, where , 2,
+			 &(op1.exp), TRUE, CHECK_RELOC_MSP430X_PCREL_SRC);
+	}
+
+      if (op2.mode == OP_EXP)
+	{
+          /*
+            x(Rn). x can be odd in non-byte operations
+            except x(R2) = x(0) = &TONI and x(PC) = TONI
+          */
+	  imm_op = (op2.mode == 1 && op2.reg != 2 && op2.reg != 0);
+	  bfd_putl16 ((bfd_vma) ZEROS, frag + 4 + ((__is == 4) ? 2 : 0));
+
+          if (op1.mode == OP_EXP)
+            {
+	      if (op2.reg)		/* Not PC relative.  */
+		fix_new_exp (frag_now, where, 2,
+				 &(op2.exp), FALSE, CHECK_RELOC_MSP430X_DST_2ND);
+	      else
+		fix_new_exp (frag_now, where, 2,
+				 &(op2.exp), TRUE, CHECK_RELOC_MSP430X_PCREL_DST_2ND);
+            }
+	  else
+            {
+              if (op2.reg)		/* Not PC relative.  */
+		fix_new_exp (frag_now, where, 2,
+				 &(op2.exp), FALSE, CHECK_RELOC_MSP430X_DST);
+	      else
+		fix_new_exp (frag_now, where, 2,
+				 &(op2.exp), TRUE, CHECK_RELOC_MSP430X_PCREL_DST);
+            }
+	}
+      break;
+
+    case FMT_X_SINGLE_OPERAND:		/* Extended format 2 (single-operand). */
+      line = extract_operand (line, l1, sizeof (l1));
+      res = msp430_srcoperand (&op1, l1, &imm_op, -(1<<19), (1<<20));
+      msp430_substitute_CG(&op1, 0);
+      if (res)
+	break;		/* Error in operand.  */
+
+      if (opcode_variant(opcode) != V_PUSHX && op1.mode == OP_EXP && op1.am == 3) // #N
+        {
+          as_bad (_("bad operand [%s]"), l1);
+          break;
+        }
+
+      if (msp430x_repeats)
+        {
+          if (op1.mode != OP_REG)
+            {
+              as_bad(_("Repeated instruction must have register mode operand"));
+              break;
+            }
+          bin |= msp430x_repeats >> 1;
+          msp430x_repeats = 0;
+        }
+
+      if(opcode_variant(opcode) == V_SWPSXT && op_width == ADDR_OP)
+        {       // sxtx.a | swpbx.a opcode
+          bin ^= BYTE_OPERATION_X;
+        }
+        
+      bin |= (op1.reg | (op1.am << 4)) << 16;
+      __is = 2 + op1.ol;		/* insn size in words, opcode is 2 words wide.  */
+      frag = frag_more (2 * __is);
+      where = frag - frag_now->fr_literal;
+      bfd_putl32 ((bfd_vma) bin, frag);
+      dwarf2_emit_insn (2 * __is);
+
+      if (op1.mode == OP_EXP)
+	{
+	  bfd_putl16 ((bfd_vma) ZEROS, frag + 4);
+
+	  if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
+	    fix_new_exp (frag_now, where, 2,
+			 &(op1.exp), FALSE, CHECK_RELOC_MSP430X_DST);
+	  else
+	    fix_new_exp (frag_now, where, 2,
+			 &(op1.exp), TRUE, CHECK_RELOC_MSP430X_PCREL_DST);
+	}
+      break;
+
+    case FMT_X_EXCEPTION:
+      /* calla, pushm, popm, rrcm, rrum, rram, rlam */
+      bin = opcode->bin_opcode;   // remove WB/AL bits
+      line = extract_operand (line, l1, sizeof (l1));
+      switch(opcode_variant(opcode))
+        {
+        case V_CALLA:   // calla
+          res = msp430_srcoperand (&op1, l1, &imm_op, -(1<<19), (1<<20));
+          if (res)
+	    break;		/* Error in operand.  */
+          __is = 1 + op1.ol;
+          frag = frag_more(__is * 2);
+
+          if (op1.mode == OP_REG)
+            {
+              bin |= op1.reg;
+              switch (op1.am)
+                {
+                case 0:         // Rdst
+                  bin |= 0x0040;
+                  break;
+                case 2:         // @Rdst
+                  bin |= 0x0060;
+                  break;
+                case 3:         // @Rdst+
+                  bin |= 0x0070;
+                  break;
+                }
+              bin |= op1.reg;
+              bfd_putl16 ((bfd_vma) bin, frag);
+              dwarf2_emit_insn (__is * 2);
+            }
+          else if (op1.mode == OP_EXP)
+            {
+              bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+              where = frag - frag_now->fr_literal;
+              switch (op1.am)
+                {
+                case 1:
+                  switch(op1.reg)
+                    {
+                    case 0:     // x(PC) = EDE
+                      bin |= 0x0090;
+                      bfd_putl16 ((bfd_vma) bin, frag);
+                      fix_new_exp (frag_now, where, 2,
+			  	    &(op1.exp), TRUE, BFD_RELOC_MSP430X_PCREL_D);
+                      break;
+                    case 2:     // &abs20
+                      bin |= 0x0080;
+                      bfd_putl16 ((bfd_vma) bin, frag);
+                      fix_new_exp (frag_now, where, 2,
+			  	    &(op1.exp), FALSE, BFD_RELOC_MSP430X_D);
+                      break;
+                    default:    //z16(Rdst)
+                      bin |= 0x0050 | op1.reg;
+                      bfd_putl16 ((bfd_vma) bin, frag);
+                      fix_new_exp (frag_now, where, 2,
+			  	    &(op1.exp), FALSE, BFD_RELOC_MSP430X_INDXD);
+                      break;
+                    }
+                  break;
+                case 3:         // calla #imm
+                  bin |= 0x00b0;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  fix_new_exp (frag_now, where, 2,
+                                &(op1.exp), FALSE, BFD_RELOC_MSP430X_D);
+                  break;
+                }
+              dwarf2_emit_insn (__is * 2);
+            }
+          break;
+        case V_ROTM:   // rxxm
+          line = extract_operand(line, l2, sizeof(l2));
+          res = msp430_srcoperand (&op1, l1, &imm_op, 1, 5);
+          res += msp430_dstoperand (&op2, l2, -(1<<19), (1<<20));
+          if(res)
+             break;	/* An error occurred.  All warnings were done before.  */
+
+          if(op_width != ADDR_OP)
+            bin |= (1 << 4);
+
+          if(op1.mode != OP_EXP || op1.am != 3) // not #imm
+            {
+              as_bad (_("bad operand [%s]"), l1);
+              break;
+            }
+          
+          bin |= ((op1.exp.X_add_number - 1) & 0x0003) << 10;
+          
+          if(op2.mode != OP_REG)
+            {
+              as_bad (_("bad operand [%s]"), l2);
+              break;
+            }
+          bin |= op2.reg;
+
+	  frag = frag_more (2);
+	  bfd_putl16 ((bfd_vma) bin, frag);
+	  dwarf2_emit_insn (2);
+          break;
+        case V_PUSHM:
+        case V_POPM:
+          line = extract_operand(line, l2, sizeof(l2));
+          res = msp430_srcoperand (&op1, l1, &imm_op, 1, 17);
+          res += msp430_dstoperand (&op2, l2, -(1<<19), (1<<20));
+          if(res)
+             break;	/* An error occurred.  All warnings were done before.  */
+
+
+          if(imm_op == 0)
+            {
+              as_bad (_("bad operand [%s]"), l1);
+              break;
+            }
+
+          if(op_width != ADDR_OP)
+            {
+              bin |= (1 << 8);
+            }
+          bin |= ((op1.exp.X_add_number - 1) & 0x000F) << 4;
+
+          if(op2.mode != OP_REG)
+            {
+              as_bad (_("bad operand [%s]"), l2);
+              break;
+            }
+          if(opcode_variant(opcode) == V_POPM)
+            {
+              /* popm */
+              bin |= (op2.reg - op1.exp.X_add_number + 1) & 0x000F;
+            }
+          else
+            {
+              /* pushm */
+              bin |= op2.reg;
+            }
+
+          frag = frag_more (2);
+	  bfd_putl16 ((bfd_vma) bin, frag);
+	  dwarf2_emit_insn (2);
+          break;
+        }
+      break;
+    case FMT_X_ADDRESS:
+    /* mova, adda, suba, cmpa */
+      line = extract_operand (line, l1, sizeof (l1));
+      line = extract_operand (line, l2, sizeof (l2));
+      res = msp430_srcoperand (&op1, l1, &imm_op, -(1<<19), (1<<20));
+      res += msp430_dstoperand (&op2, l2, -(1<<19), (1<<20));
+      if (res)
+        break;		/* Error in operand.  */
+
+      __is = 1 + op1.ol + op2.ol; 
+      frag = frag_more(__is * 2);
+      where = frag - frag_now->fr_literal;
+      bin = opcode->bin_opcode;   // remove WB/AL bits
+      if( opcode_variant(opcode) == V_MOVA)
+        {
+          if (op1.mode == OP_REG && op1.am == 0)
+            { // Rsrc
+              if(op2.mode == OP_REG && op2.am == 0) 
+                {
+                  // mova Rsrc, Rdst
+                  bin |= 0x00c0 | op1.reg << 8 | op2.reg;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                }
+              else if(op2.mode == OP_EXP && op2.am == 1 && op2.reg == 2)
+                {
+                  // mova Rsrc, &abs20
+                  bin |= 0x0060 | op1.reg << 8;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+                  fix_new_exp (frag_now, where, 2,
+                                &(op2.exp), FALSE, BFD_RELOC_MSP430X_D);
+                }
+              else if(op2.mode == OP_EXP && op2.am == 1 && op2.reg == 0)
+                {
+                  bin |= 0x0070 | op1.reg << 8;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+                  fix_new_exp (frag_now, where, 2,
+                                &(op2.exp), TRUE, BFD_RELOC_MSP430X_PCREL_D);
+                }
+              else if(op2.mode == OP_EXP && op2.am == 1)
+                {
+                  // mova Rsrc, z16(Rdst)
+                  bin |= 0x0070 | op1.reg << 8 | op2.reg;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+                  if(op2.reg == 0)
+                    // mova Rsrc, TONI == mova Rsrc, z16(PC)
+                    fix_new_exp (frag_now, where, 2,
+                                &(op2.exp), TRUE, BFD_RELOC_MSP430X_PCREL_INDXD);
+                  else
+                    fix_new_exp (frag_now, where, 2,
+                                &(op2.exp), FALSE, BFD_RELOC_MSP430X_INDXD);
+                }
+              else
+		as_bad (_("destination operand address mode not allowed with mova instruction"));
+                
+            }
+          else if (op2.mode == OP_REG && op2.am == 0)
+            { // Rdst
+              if(op1.mode == OP_REG && op1.am == 2)     
+                {
+                  // mova @Rsrc, Rdst
+                  bin |= 0x0000 | op1.reg << 8 | op2.reg;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                }
+              else if (op1.mode == OP_REG && op1.am == 3)
+                {
+                  // mova @Rsrc+, Rdst
+                  bin |= 0x0010 | op1.reg << 8 | op2.reg;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                }
+              else if (op1.mode == OP_EXP && op1.am == 1 && op1.reg == 2)
+                {
+                  if (op1.reg == 2)
+                    {
+                      // mova &abs20, Rdst
+                      bin |= 0x0020  | op2.reg;
+                      bfd_putl16 ((bfd_vma) bin, frag);
+                      dwarf2_emit_insn (__is * 2);
+                      bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+                      fix_new_exp (frag_now, where, 2,
+                                    &(op1.exp), FALSE, BFD_RELOC_MSP430X_S);
+                    }
+                  else
+                    {
+                      // mova z16(Rsrc), Rdst
+                      bin |= 0x0030 | op1.reg << 8 | op2.reg;
+                      bfd_putl16 ((bfd_vma) bin, frag);
+                      dwarf2_emit_insn (__is * 2);
+                      bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+                      if (op1.reg == 0)
+                        // mova TONI, Rdst
+                        fix_new_exp (frag_now, where, 2,
+                                     &(op1.exp), FALSE, BFD_RELOC_MSP430X_PCREL_INDXD);
+                      else
+                        fix_new_exp (frag_now, where, 2,
+                                     &(op1.exp), FALSE, BFD_RELOC_MSP430X_INDXD);
+                    }
+                }
+              else if (op1.mode == OP_EXP && op1.am == 3)
+                {
+                  // mova #imm20, Rdst
+                  bin |= 0x0080  | op2.reg;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+                  if (op2.reg == 0)
+                    fix_new_exp (frag_now, where, 2,
+                                  &(op1.exp), FALSE, BFD_RELOC_MSP430X_S);
+                  else
+                    fix_new_exp (frag_now, where, 2,
+                                  &(op1.exp), FALSE, BFD_RELOC_MSP430X_S_BYTE);
+                }
+              else
+		as_bad (_("source operand address mode not allowed with mova instruction"));
+            }
+          break;
+        }
+      else   
+      /* adda, suba, cmpa */
+        {
+          if(op2.mode == OP_REG && op2.am == 0) 
+            {
+              if (op1.mode == OP_REG && op1.am == 0)
+                { // Rsrc, Rdst
+                  bin |= 0x0040 | op1.reg << 8 | op2.reg;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                }
+              else if (op1.mode == OP_EXP && op1.am == 3)
+                {
+                  // #imm20, Rdst
+                  bin |= 0x0080  | op2.reg;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+                  if (op2.reg == 0)
+                    fix_new_exp (frag_now, where, 2,
+                                  &(op1.exp), FALSE, BFD_RELOC_MSP430X_S);
+                  else
+                    fix_new_exp (frag_now, where, 2,
+                                  &(op1.exp), FALSE, BFD_RELOC_MSP430X_S_BYTE);
+                }
+              else
+		as_bad (_("source operand address mode not allowed with %s instruction"), opcode->name);
+            }
+          else   
+            as_bad (_("destination operand address mode not allowed with %s instruction"), opcode->name);
+          break;
+        }
+      break;
+
+    case FMT_X_EMULATED:		/* Extended emulated.  */
+      switch (opcode_variant(opcode))
+	{
+	case V_NONE:
+	  /* single operand instruction emulated with Extended type 1 (double operand) instructions.  */
+	  line = extract_operand (line, l1, sizeof (l1));
+	  res = msp430_dstoperand (&op1, l1, -(1<<19), (1<<20) );
+	  if (res)
+	    break;
+
+          if (msp430x_repeats)
+            {
+              if ((bin >> 20) && 0x3 == 1) 
+                {
+                  as_bad (_("%s instruction is not repeatable"), opcode->name);
+                  break;
+                }
+              if (op1.mode != OP_REG)
+                {
+                  as_bad(_("Repeated instruction must have register mode operand"));
+                  break;
+                }
+              bin |= msp430x_repeats >> 1;
+              msp430x_repeats = 0;
+            }
+
+          bin |= (op1.reg | (op1.am << 7)) << 16;
+	  __is = 2 + op1.ol;
+	  frag = frag_more (2 * __is);
+	  where = frag - frag_now->fr_literal;
+	  bfd_putl32 ((bfd_vma) bin, frag);
+	  dwarf2_emit_insn (2 * __is);
+
+	  if (op1.mode == OP_EXP)
+	    {
+              /*
+                x(Rn). x can be odd in non-byte operations
+                except x(R2) = x(0) = &TONI and x(PC) = TONI
+              */
+	      imm_op = (op2.mode == 1 && op2.reg != 2 && op2.reg != 0);
+
+	      bfd_putl16 ((bfd_vma) ZEROS, frag + 4);
+	      if (op1.reg || (op1.reg == 0 && op1.am == 3))
+		fix_new_exp (frag_now, where, 2,
+			     &(op1.exp), FALSE, CHECK_RELOC_MSP430X_DST);
+	      else
+		fix_new_exp (frag_now, where, 2,
+			     &(op1.exp), TRUE, CHECK_RELOC_MSP430X_PCREL_DST);
+	    }
+	  break;
+	case V_X_SHIFT:
+	  {
+	    /* Shift instruction.  */
+	    line = extract_operand (line, l1, sizeof (l1));
+	    strncpy (l2, l1, sizeof (l2));
+	    l2[sizeof (l2) - 1] = '\0';
+	    res = msp430_srcoperand (&op1, l1, &imm_op, -(1<<19), (1<<20));
+            msp430_substitute_CG(&op1, 0);
+	    res += msp430_dstoperand (&op2, l2, -(1<<19), (1<<20));
+
+	    if (res)
+	      break;	/* An error occurred.  All warnings were done before.  */
+
+            if (msp430x_repeats)
+              {
+                if (op2.mode != OP_REG)
+                  {
+                    as_bad(_("Repeated instruction must have register mode operands"));
+                    break;
+                  }
+                bin |= msp430x_repeats >> 1;
+                msp430x_repeats = 0;
+              }
+
+	    bin |= (op2.reg | (op1.reg << 8) | (op1.am << 4) | (op2.am << 7)) << 16;
+
+	    __is = 2 + op1.ol + op2.ol;	/* insn size in words.  */
+	    frag = frag_more (2 * __is);
+	    where = frag - frag_now->fr_literal;
+	    bfd_putl32 ((bfd_vma) bin, frag);
+	    dwarf2_emit_insn (2 * __is);
+	    
+	    if (op1.mode == OP_EXP)
+	      {
+		bfd_putl16 ((bfd_vma) ZEROS, frag + 4);
+
+		if (op1.reg || (op1.reg == 0 && op1.am == 3))	/* Not PC relative.  */
+		  fix_new_exp (frag_now, where, 2,
+			       &(op1.exp), FALSE, CHECK_RELOC_MSP430X_SRC);
+		else
+		  fix_new_exp (frag_now, where, 2,
+			       &(op1.exp), TRUE, CHECK_RELOC_MSP430X_PCREL_SRC);
+	      }
+
+	    if (op2.mode == OP_EXP)
+	      {
+                /*
+                  x(Rn). x can be odd in non-byte operations
+                  except x(R2) = x(0) = &TONI and x(PC) = TONI
+                */
+	        imm_op = (op2.mode == 1 && op2.reg != 2 && op2.reg != 0);
+                
+		bfd_putl16 ((bfd_vma) ZEROS, frag + 4 + ((__is == 4) ? 2 : 0));
+                if (op1.mode == OP_EXP)
+	          {
+
+		    if (op2.reg)	/* Not PC relative.  */
+		      fix_new_exp (frag_now, where, 2,
+			           &(op2.exp), FALSE, CHECK_RELOC_MSP430X_DST_2ND);
+		    else
+		      fix_new_exp (frag_now, where, 2,
+			           &(op2.exp), TRUE, CHECK_RELOC_MSP430X_PCREL_DST_2ND);
+                  }
+                else
+	          {
+
+		    if (op2.reg)	/* Not PC relative.  */
+		      fix_new_exp (frag_now, where, 2,
+			           &(op2.exp), FALSE, CHECK_RELOC_MSP430X_DST);
+		    else
+		      fix_new_exp (frag_now, where, 2,
+			           &(op2.exp), TRUE, CHECK_RELOC_MSP430X_PCREL_DST);
+                  }
+	      }
+          }
+          break;
+	case V_RETA:
+	  /* reta  */
+          if (msp430x_repeats)
+            {
+              as_bad (_("%s instruction is not repeatable"), opcode->name);
+              break;
+            }
+          bin = opcode->bin_opcode;   // remove WB/AL bits
+	  frag = frag_more (2);
+	  bfd_putl16 ((bfd_vma) bin, frag);
+	  dwarf2_emit_insn (2);
+	  break;
+        case V_EMU_ADDR:   // incda, decda, tsta
+          if (msp430x_repeats)
+            {
+              as_bad (_("%s instruction is not repeatable"), opcode->name);
+              break;
+            }
+          bin = opcode->bin_opcode;   // remove WB/AL bits
+          line = extract_operand (line, l1, sizeof (l1));
+          res = msp430_dstoperand (&op1, l1, -(1<<19), (1<<20) );
+	  if (res)
+	    break;
+
+          if(op1.mode == OP_REG && op1.am == 0)     
+            {
+              frag = frag_more(2);
+              bin |= op1.reg;
+              bfd_putl16 ((bfd_vma) bin, frag);
+              dwarf2_emit_insn (2);
+            }
+          else
+            as_bad (_("destination operand address mode not allowed with %s instruction"), opcode->name);
+          break;
+        case V_BRA:   // bra, emulated with Address type instruction
+          if (msp430x_repeats)
+            {
+              as_bad (_("%s instruction is not repeatable"), opcode->name);
+              break;
+            }
+
+          bin = opcode->bin_opcode;   // remove WB/AL bits
+          line = extract_operand (line, l1, sizeof (l1));
+          res = msp430_srcoperand (&op1, l1, &imm_op, -(1<<19), (1<<20));
+          if (res)
+	    break;		/* Error in operand.  */
+
+          __is = 1 + op1.ol; 
+          frag = frag_more(__is * 2);
+	  where = frag - frag_now->fr_literal;
+          if (op1.mode == OP_REG && op1.am == 0)     
+            {
+              // mova Rsrc, PC
+              bin |= 0x00C0 | op1.reg << 8;
+              bfd_putl16 ((bfd_vma) bin, frag);
+              dwarf2_emit_insn (__is * 2);
+            }
+          else if(op1.mode == OP_REG && op1.am == 2)     
+            {
+              // mova @Rsrc, PC
+              bin |= 0x0000 | op1.reg << 8;
+              bfd_putl16 ((bfd_vma) bin, frag);
+              dwarf2_emit_insn (__is * 2);
+            }
+          else if (op1.mode == OP_REG && op1.am == 3)
+            {
+              // mova @Rsrc+, PC
+              bin |= 0x0010 | op1.reg << 8;
+              bfd_putl16 ((bfd_vma) bin, frag);
+              dwarf2_emit_insn (__is * 2);
+            }
+          else if (op1.mode == OP_EXP && op1.am == 1)
+            {
+              if (op1.reg == 2)
+                {
+                  // mova &abs20, PC
+                  bin |= 0x0020;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+                  fix_new_exp (frag_now, where, 2,
+                               &(op1.exp), FALSE, BFD_RELOC_MSP430X_S);
+                }
+              else
+                {
+                  // mova z16(Rsrc), PC
+                  bin |= 0x0030 | op1.reg << 8;
+                  bfd_putl16 ((bfd_vma) bin, frag);
+                  dwarf2_emit_insn (__is * 2);
+                  bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+                  if (op1.reg == 0)
+                    // mova z16(PC), PC = mova TONI, PC
+                    fix_new_exp (frag_now, where, 2,
+                                 &(op1.exp), TRUE, BFD_RELOC_MSP430X_PCREL_INDXD);
+                  else
+                    fix_new_exp (frag_now, where, 2,
+                                 &(op1.exp), FALSE, BFD_RELOC_MSP430X_INDXD);
+                }
+            }
+          else if (op1.mode == OP_EXP && op1.am == 3)
+            {
+              // mova #imm20, Rdst
+              bin |= 0x0080;
+              bfd_putl16 ((bfd_vma) bin, frag);
+              dwarf2_emit_insn (__is * 2);
+              bfd_putl16 ((bfd_vma) ZEROS, frag + 2);
+              fix_new_exp (frag_now, where, 2,
+                            &(op1.exp), FALSE, BFD_RELOC_MSP430X_S);
+            }
+          else
+            as_bad (_("source operand address mode not allowed with bra instruction"));
+        }
+      break;
+
     default:
       as_bad (_("Illegal instruction or not implemented opcode."));
     }
 
-  input_line_pointer = line;
+  input_line_pointer = line + 1;        // skip trailing zero
   return 0;
 }
 
 void
 md_assemble (char * str)
 {
-  struct msp430_opcode_s * opcode;
+  struct msp430_opcode_s const * opcode;
   char cmd[32];
   unsigned int i = 0;
 
@@ -1822,7 +2724,7 @@
       return;
     }
 
-  opcode = (struct msp430_opcode_s *) hash_find (msp430_hash, cmd);
+  opcode = (struct msp430_opcode_s const *) hash_find (msp430_hash, cmd);
 
   if (opcode == NULL)
     {
@@ -1830,6 +2732,12 @@
       return;
     }
 
+  if (msp430_core(msp430_mcu) < CORE_430X && opcode_format(opcode) >= FMT_X)
+    {
+      as_bad (_("Extended instruction (%s) not allowed with %s mcu"), opcode->name, msp430_mcu->name);
+      return;
+    }
+
   {
     char *__t = input_line_pointer;
 
@@ -1964,6 +2872,26 @@
 
       switch (fixp->fx_r_type)
 	{
+	case BFD_RELOC_MSP430X_PCREL_D:
+	case BFD_RELOC_MSP430X_PCREL_INDXD:
+            value -= 2;         // operand located 2 bytes after opcode
+            break;
+	case BFD_RELOC_MSP430X_PCREL_SRC:
+	case BFD_RELOC_MSP430X_PCREL_SRC_BYTE:
+	case BFD_RELOC_MSP430X_PCREL_DST:
+	case BFD_RELOC_MSP430X_PCREL_DST_BYTE:
+            value -= 4;         // operand located 4 bytes after opcode
+            break;
+	case BFD_RELOC_MSP430X_PCREL_DST_2ND:
+	case BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE:
+            value -= 6;         // operand located 6 bytes after opcode
+            break;
+        default:
+            break;
+        }
+
+      switch (fixp->fx_r_type)
+	{
 	case BFD_RELOC_MSP430_10_PCREL:
 	  if (value & 1)
 	    as_bad_where (fixp->fx_file, fixp->fx_line,
@@ -1988,7 +2916,7 @@
 			  _("odd address operand: %ld"), value);
 
 	  /* Nothing to be corrected here.  */
-	  if (value < -32768 || value > 65536)
+	  if (value < -32768 || value > 65535)
 	    as_bad_where (fixp->fx_file, fixp->fx_line,
 			  _("operand out of range: %ld"), value);
 
@@ -1998,7 +2926,7 @@
 
 	case BFD_RELOC_MSP430_16_PCREL_BYTE:
 	  /* Nothing to be corrected here.  */
-	  if (value < -32768 || value > 65536)
+	  if (value < -32768 || value > 65535)
 	    as_bad_where (fixp->fx_file, fixp->fx_line,
 			  _("operand out of range: %ld"), value);
 
@@ -2017,6 +2945,76 @@
 	  bfd_putl16 ((bfd_vma) value, where);
 	  break;
 
+	case BFD_RELOC_MSP430X_SRC:
+	case BFD_RELOC_MSP430X_PCREL_SRC:
+	  if (value & 1)
+	    as_bad_where (fixp->fx_file, fixp->fx_line,
+			  _("odd operand: %ld"), value);
+        case BFD_RELOC_MSP430X_SRC_BYTE:
+	case BFD_RELOC_MSP430X_PCREL_SRC_BYTE:
+	  value &= 0xfffff;
+          bfd_putl16 ((bfd_vma)(bfd_getl16 (where) & 0xf87f) | ((value >> 9) & 0x0780), where);
+          /* 16 least-significant bits */
+	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 4);
+	  break;
+	case BFD_RELOC_MSP430X_DST:
+	case BFD_RELOC_MSP430X_PCREL_DST:
+	  if (value & 1)
+	    as_bad_where (fixp->fx_file, fixp->fx_line,
+			  _("odd operand: %ld"), value);
+	case BFD_RELOC_MSP430X_DST_BYTE:
+	case BFD_RELOC_MSP430X_PCREL_DST_BYTE:
+          bfd_putl16 ((bfd_vma)(bfd_getl16 (where) & 0xfff0) | ((value >> 16) & 0x000f), where);
+          /* 16 least-significant bits */
+          value &= 0xfffff;
+	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 4);
+	  break;
+	case BFD_RELOC_MSP430X_DST_2ND:
+	case BFD_RELOC_MSP430X_PCREL_DST_2ND:
+	  if (value & 1)
+	    as_bad_where (fixp->fx_file, fixp->fx_line,
+			  _("odd operand: %ld"), value);
+	case BFD_RELOC_MSP430X_DST_2ND_BYTE:
+	case BFD_RELOC_MSP430X_PCREL_DST_2ND_BYTE:
+          value &= 0xfffff;
+          bfd_putl16 ((bfd_vma)(bfd_getl16 (where) & 0xfff0) | ((value >> 16) & 0x000f), where);
+          /* 16 least-significant bits */
+	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 6);
+	  break;
+	case BFD_RELOC_MSP430X_S:
+	  if (value & 1)
+	    as_bad_where (fixp->fx_file, fixp->fx_line,
+			  _("odd operand: %ld"), value);
+	case BFD_RELOC_MSP430X_S_BYTE:
+	  value &= 0xfffff;
+          bfd_putl16 ((bfd_vma)(bfd_getl16 (where) & 0xf0ff) | ((value >> 8) & 0x0f00), where);
+          /* 16 least-significant bits */
+	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 2);
+	  break;
+	case BFD_RELOC_MSP430X_D:
+	case BFD_RELOC_MSP430X_PCREL_D:
+	  if (value & 1)
+	    as_bad_where (fixp->fx_file, fixp->fx_line,
+			  _("odd operand: %ld"), value);
+	case BFD_RELOC_MSP430X_D_BYTE:
+          value &= 0xfffff;
+          bfd_putl16 ((bfd_vma)(bfd_getl16 (where) & 0xfff0) | ((value >> 16) & 0x000f), where);
+          /* 16 least-significant bits */
+	  bfd_putl16 ((bfd_vma) (value & 0xffff), where + 2);
+	  break;
+	case BFD_RELOC_MSP430X_PCREL_INDXD:
+	  if (value & 1)
+	    as_bad_where (fixp->fx_file, fixp->fx_line,
+			  _("odd operand: %ld"), value);
+	case BFD_RELOC_MSP430X_INDXD:
+	  if (value < -32768 || value > 65535)
+	    as_bad_where (fixp->fx_file, fixp->fx_line,
+			  _("operand out of range: %ld"), value);
+
+	  value &= 0xffff;	/* Get rid of extended sign.  */
+	  bfd_putl16 ((bfd_vma) value, where + 2);
+	  break;
+
 	default:
 	  as_fatal (_("line %d: unknown relocation type: 0x%x"),
 		    fixp->fx_line, fixp->fx_r_type);
diff -urN binutils-2.20.1/include/elf/msp430.h binutils-2.20.1-mspgcc4/include/elf/msp430.h
--- binutils-2.20.1/include/elf/msp430.h	2005-05-10 05:21:10.000000000 -0500
+++ binutils-2.20.1-mspgcc4/include/elf/msp430.h	2010-04-30 19:31:50.000000000 -0500
@@ -26,20 +26,31 @@
 /* Processor specific flags for the ELF header e_flags field.  */
 #define EF_MSP430_MACH 		0xff
 
-#define E_MSP430_MACH_MSP430x11  11
-#define E_MSP430_MACH_MSP430x11x1  110
-#define E_MSP430_MACH_MSP430x12  12
-#define E_MSP430_MACH_MSP430x13  13
-#define E_MSP430_MACH_MSP430x14  14
-#define E_MSP430_MACH_MSP430x15  15
-#define E_MSP430_MACH_MSP430x16  16
-#define E_MSP430_MACH_MSP430x31  31
-#define E_MSP430_MACH_MSP430x32  32
-#define E_MSP430_MACH_MSP430x33  33
-#define E_MSP430_MACH_MSP430x41  41
-#define E_MSP430_MACH_MSP430x42  42
-#define E_MSP430_MACH_MSP430x43  43
-#define E_MSP430_MACH_MSP430x44  44
+#define E_MSP430_MACH_MSP430x11   11
+#define E_MSP430_MACH_MSP430x11x1 110
+#define E_MSP430_MACH_MSP430x12   12
+#define E_MSP430_MACH_MSP430x13   13
+#define E_MSP430_MACH_MSP430x14   14
+#define E_MSP430_MACH_MSP430x15   15
+#define E_MSP430_MACH_MSP430x16   16
+#define E_MSP430_MACH_MSP430x20   20
+#define E_MSP430_MACH_MSP430x21   21
+#define E_MSP430_MACH_MSP430x22   22
+#define E_MSP430_MACH_MSP430x23   23
+#define E_MSP430_MACH_MSP430x24   24
+#define E_MSP430_MACH_MSP430x241  241
+#define E_MSP430_MACH_MSP430x26   26
+#define E_MSP430_MACH_MSP430x31   31
+#define E_MSP430_MACH_MSP430x32   32
+#define E_MSP430_MACH_MSP430x33   33
+#define E_MSP430_MACH_MSP430x41   41
+#define E_MSP430_MACH_MSP430x42   42
+#define E_MSP430_MACH_MSP430x43   43
+#define E_MSP430_MACH_MSP430x44   44
+#define E_MSP430_MACH_MSP430x46   46
+#define E_MSP430_MACH_MSP430x47   47
+#define E_MSP430_MACH_MSP430x471  471
+#define E_MSP430_MACH_MSP430x54   54
 
 /* Relocations.  */
 START_RELOC_NUMBERS (elf_msp430_reloc_type)
@@ -52,6 +63,25 @@
      RELOC_NUMBER (R_MSP430_16_PCREL_BYTE, 	6)
      RELOC_NUMBER (R_MSP430_2X_PCREL,		7)
      RELOC_NUMBER (R_MSP430_RL_PCREL,		8)
+     RELOC_NUMBER (R_MSP430X_SRC_BYTE,		9)
+     RELOC_NUMBER (R_MSP430X_SRC,		10)
+     RELOC_NUMBER (R_MSP430X_DST_BYTE,		11)
+     RELOC_NUMBER (R_MSP430X_DST,		12)
+     RELOC_NUMBER (R_MSP430X_DST_2ND_BYTE,	13)
+     RELOC_NUMBER (R_MSP430X_DST_2ND,		14)
+     RELOC_NUMBER (R_MSP430X_PCREL_SRC_BYTE,	15)
+     RELOC_NUMBER (R_MSP430X_PCREL_SRC,		16)
+     RELOC_NUMBER (R_MSP430X_PCREL_DST_BYTE,	17)
+     RELOC_NUMBER (R_MSP430X_PCREL_DST,		18)
+     RELOC_NUMBER (R_MSP430X_PCREL_DST_2ND,	19)
+     RELOC_NUMBER (R_MSP430X_PCREL_DST_2ND_BYTE,	20)
+     RELOC_NUMBER (R_MSP430X_S_BYTE,		21)
+     RELOC_NUMBER (R_MSP430X_S,			22)
+     RELOC_NUMBER (R_MSP430X_D_BYTE,		23)
+     RELOC_NUMBER (R_MSP430X_D,			24)
+     RELOC_NUMBER (R_MSP430X_PCREL_D,		25)
+     RELOC_NUMBER (R_MSP430X_INDXD,		26)
+     RELOC_NUMBER (R_MSP430X_PCREL_INDXD,	27)
 
 END_RELOC_NUMBERS (R_MSP430_max)
 
diff -urN binutils-2.20.1/include/opcode/msp430.h binutils-2.20.1-mspgcc4/include/opcode/msp430.h
--- binutils-2.20.1/include/opcode/msp430.h	2005-05-10 05:21:13.000000000 -0500
+++ binutils-2.20.1-mspgcc4/include/opcode/msp430.h	2010-04-30 19:31:50.000000000 -0500
@@ -25,7 +25,7 @@
   int ol;	/* Operand length words.  */
   int am;	/* Addr mode.  */
   int reg;	/* Register.  */
-  int mode;	/* Pperand mode.  */
+  int mode;	/* Operand mode.  */
 #define OP_REG		0
 #define OP_EXP		1
 #ifndef DASM_SECTION
@@ -33,91 +33,240 @@
 #endif
 };
 
-#define BYTE_OPERATION  (1 << 6)  /* Byte operation flag for all instructions.  */
+#define BYTE_OPERATION          (1 << 6)  /* Byte operation flag for 430 instructions.  */
+#define BYTE_OPERATION_X        (1 << 22) /* Byte operation flag for 430x instructions.  */
+#define NON_ADDR_OPERATION      (1 << 6)  /* Address operation flag for 430x instructions.  */
+
+typedef enum 
+{ 
+  DEFAULT_OP,   // instruction has no modifier
+  WORD_OP,      // .w
+  BYTE_OP,      // .b
+  ADDR_OP       // .a
+} 
+opwidth_t;
+
+typedef enum
+{ 
+  CORE_430,     // 1xxx, 2xxx, 3xxx, 4xxx
+  CORE_430X,    // 241x, 26xx, 46xx
+  CORE_430X2,   // 5xxx
+}
+core_t;
+
+typedef enum
+{
+  FMT_EMULATED = 0,
+  FMT_DOUBLE_OPERAND,
+  FMT_SINGLE_OPERAND,
+  FMT_JUMP,
+  FMT_EMULATED_POLYMORPH_JUMP,
+  FMT_EMULATED_LONG_POLYMORPH_JUMP,
+  FMT_X_DOUBLE_OPERAND,
+  FMT_X_SINGLE_OPERAND,
+  FMT_X_EXCEPTION,
+  FMT_X_EMULATED,
+  FMT_X_ADDRESS,
+
+  FMT_X = FMT_X_DOUBLE_OPERAND,
+  FMT_MASK = 0x000f,
+
+  /* allowed modifiers: .b, .w, .a */
+  MOD_NONE = 0, 
+  MOD_W = 1 << 4, 
+  MOD_B = 1 << 5, 
+  MOD_A = 1 << 6,
+  MOD_MASK = 0x0070,
+  
+  /* opcode variant */
+  VAR_MASK = 0x0380,
+} 
+format_t;
+
+#define OP_V(x) (x << 7)
 
 struct  msp430_opcode_s
 {
   char *name;
-  int fmt;
-  int insn_opnumb;
-  int bin_opcode;
-  int bin_mask;
+  format_t fmt;
+  unsigned int insn_opnumb;
+  unsigned int bin_opcode;
+  unsigned int bin_mask;
+};
+
+#define opcode_format(opcode)   (opcode->fmt & FMT_MASK)
+#define opcode_modifier(opcode) (opcode->fmt & MOD_MASK)
+#define opcode_variant(opcode)  ((opcode->fmt & VAR_MASK) >> 7)
+
+/* opcode variants:  */
+enum
+{   
+   V_NONE = 0,          // ordinary instruction
+
+   /* FMT_EMULATED: */
+   V_NOOP,              // no operands: set/clear bit instructions, reti
+   V_SHIFT,             // shift instructions
+   V_BR,                // br instruction
+   
+   /* FMT_SINGLE_OPERAND: */
+   V_RETI = 1,          // reti
+   V_CALL = 2,          // hex operand in disassembly
+
+   /* FMT_X_SINGLE_OPERAND: */
+                        // V_NONE - #N operand disallowed
+   V_SWPSXT = 1,        // #N operand disallowed, special A/L, B/W bits case with .a modifier
+   V_PUSHX,             // #N operand allowed
+
+   /* FMT_X_EXCEPTIONS: */
+   V_CALLA = 0,         // calla 
+   V_ROTM,              // two operands, rotations
+   V_POPM,              // two operands, popm
+   V_PUSHM,             // two operands, pushm
+
+   /* FMT_X_EMULATED: */
+                        // V_NONE - substituted by 430x double operand instruction
+   V_X_SHIFT,           // shifts
+   V_RETA,              // reta, short instruction, no operands
+   V_EMU_ADDR,          // substituted by address instruction other than mova 
+   V_BRA,               // bra, substituted by mova address instruction == format II exception instruction
+   // clra emulated by msp430 instruction
+
+   /* FMT_X_ADDRESS: */
+   V_MOVA = 1,          // mova, more address modes allowed
 };
 
-#define MSP_INSN(name, size, numb, bin, mask) { #name, size, numb, bin, mask }
+#define MSP_INSN(name, format, opnumb, bin, mask) { #name, format, opnumb, bin, mask }
 
-static struct msp430_opcode_s msp430_opcodes[] = 
+static struct msp430_opcode_s const msp430_opcodes[] = 
 {
-  MSP_INSN (and,   1, 2, 0xf000, 0xf000),
-  MSP_INSN (inv,   0, 1, 0xe330, 0xfff0),
-  MSP_INSN (xor,   1, 2, 0xe000, 0xf000),
-  MSP_INSN (setz,  0, 0, 0xd322, 0xffff),
-  MSP_INSN (setc,  0, 0, 0xd312, 0xffff),
-  MSP_INSN (eint,  0, 0, 0xd232, 0xffff),
-  MSP_INSN (setn,  0, 0, 0xd222, 0xffff),
-  MSP_INSN (bis,   1, 2, 0xd000, 0xf000),
-  MSP_INSN (clrz,  0, 0, 0xc322, 0xffff),
-  MSP_INSN (clrc,  0, 0, 0xc312, 0xffff),
-  MSP_INSN (dint,  0, 0, 0xc232, 0xffff),
-  MSP_INSN (clrn,  0, 0, 0xc222, 0xffff),
-  MSP_INSN (bic,   1, 2, 0xc000, 0xf000),
-  MSP_INSN (bit,   1, 2, 0xb000, 0xf000),
-  MSP_INSN (dadc,  0, 1, 0xa300, 0xff30),
-  MSP_INSN (dadd,  1, 2, 0xa000, 0xf000),
-  MSP_INSN (tst,   0, 1, 0x9300, 0xff30),
-  MSP_INSN (cmp,   1, 2, 0x9000, 0xf000),
-  MSP_INSN (decd,  0, 1, 0x8320, 0xff30),
-  MSP_INSN (dec,   0, 1, 0x8310, 0xff30),
-  MSP_INSN (sub,   1, 2, 0x8000, 0xf000),
-  MSP_INSN (sbc,   0, 1, 0x7300, 0xff30),
-  MSP_INSN (subc,  1, 2, 0x7000, 0xf000),
-  MSP_INSN (adc,   0, 1, 0x6300, 0xff30),
-  MSP_INSN (rlc,   0, 2, 0x6000, 0xf000),
-  MSP_INSN (addc,  1, 2, 0x6000, 0xf000),
-  MSP_INSN (incd,  0, 1, 0x5320, 0xff30),
-  MSP_INSN (inc,   0, 1, 0x5310, 0xff30),
-  MSP_INSN (rla,   0, 2, 0x5000, 0xf000),
-  MSP_INSN (add,   1, 2, 0x5000, 0xf000),
-  MSP_INSN (nop,   0, 0, 0x4303, 0xffff),
-  MSP_INSN (clr,   0, 1, 0x4300, 0xff30),
-  MSP_INSN (ret,   0, 0, 0x4130, 0xff30),
-  MSP_INSN (pop,   0, 1, 0x4130, 0xff30),
-  MSP_INSN (br,    0, 3, 0x4000, 0xf000),
-  MSP_INSN (mov,   1, 2, 0x4000, 0xf000),
-  MSP_INSN (jmp,   3, 1, 0x3c00, 0xfc00),
-  MSP_INSN (jl,    3, 1, 0x3800, 0xfc00),
-  MSP_INSN (jge,   3, 1, 0x3400, 0xfc00),
-  MSP_INSN (jn,    3, 1, 0x3000, 0xfc00),
-  MSP_INSN (jc,    3, 1, 0x2c00, 0xfc00),
-  MSP_INSN (jhs,   3, 1, 0x2c00, 0xfc00),
-  MSP_INSN (jnc,   3, 1, 0x2800, 0xfc00),
-  MSP_INSN (jlo,   3, 1, 0x2800, 0xfc00),
-  MSP_INSN (jz,    3, 1, 0x2400, 0xfc00),
-  MSP_INSN (jeq,   3, 1, 0x2400, 0xfc00),
-  MSP_INSN (jnz,   3, 1, 0x2000, 0xfc00),
-  MSP_INSN (jne,   3, 1, 0x2000, 0xfc00),
-  MSP_INSN (reti,  2, 0, 0x1300, 0xffc0),
-  MSP_INSN (call,  2, 1, 0x1280, 0xffc0),
-  MSP_INSN (push,  2, 1, 0x1200, 0xff80),
-  MSP_INSN (sxt,   2, 1, 0x1180, 0xffc0),
-  MSP_INSN (rra,   2, 1, 0x1100, 0xff80),
-  MSP_INSN (swpb,  2, 1, 0x1080, 0xffc0),
-  MSP_INSN (rrc,   2, 1, 0x1000, 0xff80),
+  MSP_INSN (and,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xf000, 0xfffff000),
+  MSP_INSN (inv,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0xe330, 0xfffffff0),
+  MSP_INSN (xor,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xe000, 0xfffff000),
+  MSP_INSN (setz,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xd322, 0xffffffff),
+  MSP_INSN (setc,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xd312, 0xffffffff),
+  MSP_INSN (eint,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xd232, 0xffffffff),
+  MSP_INSN (setn,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xd222, 0xffffffff),
+  MSP_INSN (bis,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xd000, 0xfffff000),
+  MSP_INSN (clrz,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xc322, 0xffffffff),
+  MSP_INSN (clrc,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xc312, 0xffffffff),
+  MSP_INSN (dint,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xc232, 0xffffffff),
+  MSP_INSN (clrn,  FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0xc222, 0xffffffff),
+  MSP_INSN (bic,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xc000, 0xfffff000),
+  MSP_INSN (bit,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xb000, 0xfffff000),
+  MSP_INSN (dadc,  FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0xa300, 0xffffff30),
+  MSP_INSN (dadd,  FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0xa000, 0xfffff000),
+  MSP_INSN (tst,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x9300, 0xffffff30),
+  MSP_INSN (cmp,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x9000, 0xfffff000),
+  MSP_INSN (decd,  FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x8320, 0xffffff30),
+  MSP_INSN (dec,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x8310, 0xffffff30),
+  MSP_INSN (sub,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x8000, 0xfffff000),
+  MSP_INSN (sbc,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x7300, 0xffffff30),
+  MSP_INSN (subc,  FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x7000, 0xfffff000),
+  MSP_INSN (adc,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x6300, 0xffffff30),
+  MSP_INSN (rlc,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(V_SHIFT),       2, 0x6000, 0xfffff000),
+  MSP_INSN (addc,  FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x6000, 0xfffff000),
+  MSP_INSN (incd,  FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x5320, 0xffffff30),
+  MSP_INSN (inc,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x5310, 0xffffff30),
+  MSP_INSN (rla,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(V_SHIFT),       2, 0x5000, 0xfffff000),
+  MSP_INSN (add,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x5000, 0xfffff000),
+  MSP_INSN (nop,   FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0x4303, 0xffffffff),
+  MSP_INSN (clr,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x4300, 0xffffff30),
+  MSP_INSN (clra,  FMT_EMULATED          | MOD_NONE          | OP_V(0),             1, 0x4300, 0xffffff30),     // MOV      #0, Rdst
+  MSP_INSN (ret,   FMT_EMULATED          | MOD_NONE          | OP_V(V_NOOP),        0, 0x4130, 0xffffffff),
+  MSP_INSN (pop,   FMT_EMULATED          | MOD_W|MOD_B       | OP_V(0),             1, 0x4130, 0xffffff30),
+  MSP_INSN (br,    FMT_EMULATED          | MOD_NONE          | OP_V(V_BR),          1, 0x4000, 0xfffff08f),
+  MSP_INSN (mov,   FMT_DOUBLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             2, 0x4000, 0xfffff000),
+
+  MSP_INSN (jmp,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x3c00, 0xfffffc00),
+  MSP_INSN (jl,    FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x3800, 0xfffffc00),
+  MSP_INSN (jge,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x3400, 0xfffffc00),
+  MSP_INSN (jn,    FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x3000, 0xfffffc00),
+  MSP_INSN (jc,    FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2c00, 0xfffffc00),
+  MSP_INSN (jhs,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2c00, 0xfffffc00),
+  MSP_INSN (jnc,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2800, 0xfffffc00),
+  MSP_INSN (jlo,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2800, 0xfffffc00),
+  MSP_INSN (jz,    FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2400, 0xfffffc00),
+  MSP_INSN (jeq,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2400, 0xfffffc00),
+  MSP_INSN (jnz,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2000, 0xfffffc00),
+  MSP_INSN (jne,   FMT_JUMP              | MOD_NONE          | OP_V(0),             1, 0x2000, 0xfffffc00),
+
+  MSP_INSN (reti,  FMT_SINGLE_OPERAND    | MOD_NONE          | OP_V(V_RETI),        0, 0x1300, 0xffffffc0),
+  MSP_INSN (call,  FMT_SINGLE_OPERAND    | MOD_NONE          | OP_V(V_CALL),        1, 0x1280, 0xffffffc0),
+  MSP_INSN (push,  FMT_SINGLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             1, 0x1200, 0xffffff80),
+  MSP_INSN (sxt,   FMT_SINGLE_OPERAND    | MOD_NONE          | OP_V(0),             1, 0x1180, 0xffffffc0),
+  MSP_INSN (rra,   FMT_SINGLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             1, 0x1100, 0xffffff80),
+  MSP_INSN (swpb,  FMT_SINGLE_OPERAND    | MOD_NONE          | OP_V(0),             1, 0x1080, 0xffffffc0),
+  MSP_INSN (rrc,   FMT_SINGLE_OPERAND    | MOD_W|MOD_B       | OP_V(0),             1, 0x1000, 0xffffff80),
+
+
+  /* emulated instructions placed just before instruction emulated by for disassembly search */
+  MSP_INSN (popx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x41301800, 0xff30f800), // MOVX     @SP+, dst
+  MSP_INSN (clrx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x43001800, 0xff30f800), // MOVX     #0, dst
+  MSP_INSN (movx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x40001800, 0xf000f800),
+  MSP_INSN (incx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x53101800, 0xff30f800), // ADDX     #1, dst
+  MSP_INSN (incdx, FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x53201800, 0xff30f800), // ADDX     #2, dst
+  MSP_INSN (rlax,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(V_X_SHIFT),     1, 0x50001800, 0xf000f800), // ADDX     dst, dst
+  MSP_INSN (addx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x50001800, 0xf000f800),
+  MSP_INSN (adcx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x63001800, 0xff30f800), // ADDCX    #0, dst
+  MSP_INSN (rlcx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(V_X_SHIFT),     1, 0x60001800, 0xf000f800), // ADDCX    dst, dst
+  MSP_INSN (addcx, FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x60001800, 0xf000f800),
+  MSP_INSN (sbcx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x73001800, 0xff30f800), // SUBCX    #0, dst
+  MSP_INSN (subcx, FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x70001800, 0xf000f800),
+  MSP_INSN (decx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x83101800, 0xff30f800), // SUBX     #1, dst
+  MSP_INSN (decdx, FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x83201800, 0xff30f800), // SUBX     #2, dst
+  MSP_INSN (subx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x80001800, 0xf000f800),
+  MSP_INSN (tstx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x93001800, 0xff30f800), // CMPX     #0, dst
+  MSP_INSN (cmpx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0x90001800, 0xf000f800),
+  MSP_INSN (dadcx, FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0xa3001800, 0xff30f800), // DADDX    #0, dst
+  MSP_INSN (daddx, FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xa0001800, 0xf000f800),
+  MSP_INSN (bitx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xb0001800, 0xf000f800),
+  MSP_INSN (bicx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xc0001800, 0xf000f800),
+  MSP_INSN (bisx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xd0001800, 0xf000f800),
+  MSP_INSN (invx,  FMT_X_EMULATED        | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0xe3301800, 0xff30f800), // XORX     #-1, dst
+  MSP_INSN (xorx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xe0001800, 0xf000f800),
+  MSP_INSN (andx,  FMT_X_DOUBLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             2, 0xf0001800, 0xf000f800),
+  
+  MSP_INSN (rrcx,  FMT_X_SINGLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x10001800, 0xff80f800),
+  MSP_INSN (swpbx, FMT_X_SINGLE_OPERAND  | MOD_W|MOD_A       | OP_V(V_SWPSXT),      1, 0x10801800, 0xffc0f800),
+  MSP_INSN (rrax,  FMT_X_SINGLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(0),             1, 0x11001800, 0xff80f800),
+  MSP_INSN (sxtx,  FMT_X_SINGLE_OPERAND  | MOD_W|MOD_A       | OP_V(V_SWPSXT),      1, 0x11801800, 0xffc0f800),
+  MSP_INSN (pushx, FMT_X_SINGLE_OPERAND  | MOD_W|MOD_B|MOD_A | OP_V(V_PUSHX),       1, 0x12001800, 0xff80f800),
+
+  MSP_INSN (calla, FMT_X_EXCEPTION       | MOD_NONE          | OP_V(V_CALLA),       1, 0x1300, 0xffffff00),
+  MSP_INSN (pushm, FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_PUSHM),       2, 0x1400, 0xfffffe00),
+  MSP_INSN (popm,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_POPM),        2, 0x1600, 0xfffffe00),
+  MSP_INSN (rrcm,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_ROTM),        2, 0x0040, 0xfffff3e0),
+  MSP_INSN (rram,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_ROTM),        2, 0x0140, 0xfffff3e0),
+  MSP_INSN (rlam,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_ROTM),        2, 0x0240, 0xfffff3e0),
+  MSP_INSN (rrum,  FMT_X_EXCEPTION       | MOD_W|MOD_A       | OP_V(V_ROTM),        2, 0x0340, 0xfffff3e0),
+
+  /* Address.  */
+  MSP_INSN (incda, FMT_X_EMULATED        | MOD_NONE          | OP_V(V_EMU_ADDR),    1, 0x03e0, 0xfffffff0),     // ADDA     #2, Rdst = ADDA R3, Rdst
+  MSP_INSN (adda,  FMT_X_ADDRESS         | MOD_NONE          | OP_V(0),             2, 0x00a0, 0xfffff0b0),
+  MSP_INSN (tsta,  FMT_X_EMULATED        | MOD_NONE          | OP_V(V_EMU_ADDR),    1, 0x03d0, 0xfffffff0),     // CMPA     #0, Rdst = CMPA R3, Rdst
+  MSP_INSN (cmpa,  FMT_X_ADDRESS         | MOD_NONE          | OP_V(0),             2, 0x0090, 0xfffff0b0),
+  MSP_INSN (decda, FMT_X_EMULATED        | MOD_NONE          | OP_V(V_EMU_ADDR),    1, 0x03f0, 0xfffffff0),     // SUBA     #2, Rdst = SUBA R3, Rdst
+  MSP_INSN (suba,  FMT_X_ADDRESS         | MOD_NONE          | OP_V(0),             2, 0x00b0, 0xfffff0b0),
+  MSP_INSN (reta,  FMT_X_EMULATED        | MOD_NONE          | OP_V(V_RETA),        0, 0x0110, 0xffffffff),     // MOVA     @SP+, PC
+  MSP_INSN (bra,   FMT_X_EMULATED        | MOD_NONE          | OP_V(V_BRA),         1, 0x0000, 0xfffff0cf),     // MOVA     dst, PC
+  MSP_INSN (bra,   FMT_X_EMULATED        | MOD_NONE          | OP_V(V_BRA),         1, 0x0080, 0xfffff0bf),     // MOVA     #imm20, PC; MOVA Rsrc, Rdst
+  MSP_INSN (mova,  FMT_X_ADDRESS         | MOD_NONE          | OP_V(V_MOVA),        1, 0x0000, 0xfffff000),
+  
   /* Simple polymorphs.  */
-  MSP_INSN (beq,   4, 0, 0, 0xffff),
-  MSP_INSN (bne,   4, 1, 0, 0xffff),
-  MSP_INSN (blt,   4, 2, 0, 0xffff),
-  MSP_INSN (bltu,  4, 3, 0, 0xffff),
-  MSP_INSN (bge,   4, 4, 0, 0xffff),
-  MSP_INSN (bgeu,  4, 5, 0, 0xffff),
-  MSP_INSN (bltn,  4, 6, 0, 0xffff),
-  MSP_INSN (jump,  4, 7, 0, 0xffff),
-  /* Long polymorphs.  */
-  MSP_INSN (bgt,   5, 0, 0, 0xffff),
-  MSP_INSN (bgtu,  5, 1, 0, 0xffff),
-  MSP_INSN (bleu,  5, 2, 0, 0xffff),
-  MSP_INSN (ble,   5, 3, 0, 0xffff),
+  MSP_INSN (beq,   FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(0),             1, 0, 0xffff),
+  MSP_INSN (bne,   FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(1),             1, 0, 0xffff),
+  MSP_INSN (blt,   FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(2),             1, 0, 0xffff),
+  MSP_INSN (bltu,  FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(3),             1, 0, 0xffff),
+  MSP_INSN (bge,   FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(4),             1, 0, 0xffff),
+  MSP_INSN (bgeu,  FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(5),             1, 0, 0xffff),
+  MSP_INSN (bltn,  FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(6),             1, 0, 0xffff),
+  MSP_INSN (jump,  FMT_EMULATED_POLYMORPH_JUMP | MOD_NONE    | OP_V(7),             1, 0, 0xffff),
 
+  /* Long polymorphs.  */
+  MSP_INSN (bgt,   FMT_EMULATED_LONG_POLYMORPH_JUMP | MOD_NONE | OP_V(0),           1, 0, 0xffff),
+  MSP_INSN (bgtu,  FMT_EMULATED_LONG_POLYMORPH_JUMP | MOD_NONE | OP_V(1),           1, 0, 0xffff),
+  MSP_INSN (bleu,  FMT_EMULATED_LONG_POLYMORPH_JUMP | MOD_NONE | OP_V(2),           1, 0, 0xffff),
+  MSP_INSN (ble,   FMT_EMULATED_LONG_POLYMORPH_JUMP | MOD_NONE | OP_V(3),           1, 0, 0xffff),
   /* End of instruction set.  */
   { NULL, 0, 0, 0, 0 }
 };
diff -urN binutils-2.20.1/ld/Makefile.am binutils-2.20.1-mspgcc4/ld/Makefile.am
--- binutils-2.20.1/ld/Makefile.am	2010-02-22 02:07:01.000000000 -0600
+++ binutils-2.20.1-mspgcc4/ld/Makefile.am	2010-04-30 19:31:50.000000000 -0500
@@ -311,6 +311,9 @@
 	emsp430x147.o \
 	emsp430x148.o \
 	emsp430x149.o \
+	emsp430x1471.o \
+	emsp430x1481.o \
+	emsp430x1491.o \
 	emsp430x155.o \
 	emsp430x156.o \
 	emsp430x157.o \
@@ -320,10 +323,45 @@
 	emsp430x1610.o \
 	emsp430x1611.o \
 	emsp430x1612.o \
+	emsp430x2001.o \
+	emsp430x2011.o \
+	emsp430x2002.o \
+	emsp430x2012.o \
+	emsp430x2003.o \
+	emsp430x2014.o \
 	emsp430x2101.o \
 	emsp430x2111.o \
+	emsp430x2112.o \
 	emsp430x2121.o \
+	emsp430x2122.o \
 	emsp430x2131.o \
+	emsp430x2132.o \
+	emsp430x2232.o \
+	emsp430x2234.o \
+	emsp430x2252.o \
+	emsp430x2254.o \
+	emsp430x2272.o \
+	emsp430x2274.o \
+	emsp430x233.o \
+	emsp430x235.o \
+	emsp430x2330.o \
+	emsp430x2350.o \
+	emsp430x2370.o \
+	emsp430x247.o \
+	emsp430x248.o \
+	emsp430x249.o \
+	emsp430x2410.o \
+	emsp430x2471.o \
+	emsp430x2481.o \
+	emsp430x2491.o \
+	emsp430x2416.o \
+	emsp430x2417.o \
+	emsp430x2418.o \
+	emsp430x2419.o \
+	emsp430x2616.o \
+	emsp430x2617.o \
+	emsp430x2618.o \
+	emsp430x2619.o \
 	emsp430x311.o \
 	emsp430x312.o \
 	emsp430x313.o \
@@ -337,21 +375,67 @@
 	emsp430x413.o \
 	emsp430x415.o \
 	emsp430x417.o \
+	emsp430x423.o \
+	emsp430x425.o \
+	emsp430x427.o \
+	emsp430x4250.o \
+	emsp430x4260.o \
+	emsp430x4270.o \
 	emsp430xE423.o \
 	emsp430xE425.o \
 	emsp430xE427.o \
+	emsp430xE4232.o \
+	emsp430xE4242.o \
+	emsp430xE4252.o \
+	emsp430xE4272.o \
 	emsp430xW423.o \
 	emsp430xW425.o \
 	emsp430xW427.o \
+	emsp430xG4250.o \
+	emsp430xG4260.o \
+	emsp430xG4270.o \
 	emsp430xG437.o \
 	emsp430xG438.o \
 	emsp430xG439.o \
 	emsp430x435.o \
 	emsp430x436.o \
 	emsp430x437.o \
+	emsp430x4351.o \
+	emsp430x4361.o \
+	emsp430x4371.o \
 	emsp430x447.o \
 	emsp430x448.o \
 	emsp430x449.o \
+	emsp430xG4616.o \
+	emsp430xG4617.o \
+	emsp430xG4618.o \
+	emsp430xG4619.o \
+	emsp430x4783.o \
+	emsp430x4784.o \
+	emsp430x4793.o \
+	emsp430x4794.o \
+	emsp430x47166.o \
+	emsp430x47176.o \
+	emsp430x47186.o \
+	emsp430x47196.o \
+	emsp430x47167.o \
+	emsp430x47177.o \
+	emsp430x47187.o \
+	emsp430x47197.o \
+	emsp430x5418.o \
+	emsp430x5419.o \
+	emsp430x5435.o \
+	emsp430x5436.o \
+	emsp430x5437.o \
+	emsp430x5438.o \
+	ecc430x5123.o \
+	ecc430x5125.o \
+	ecc430x6125.o \
+	ecc430x6135.o \
+	ecc430x6126.o \
+	ecc430x5137.o \
+	ecc430x6127.o \
+	ecc430x6137.o \
 	enews.o \
 	ens32knbsd.o \
 	eor32.o \
@@ -1447,6 +1531,18 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x149 "$(tdir_msp430x149)" msp430all
+emsp430x1471.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1471 "$(tdir_msp430x1471)" msp430all
+emsp430x1481.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1481 "$(tdir_msp430x1481)" msp430all
+emsp430x1491.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1491 "$(tdir_msp430x1491)" msp430all
 emsp430x155.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -1483,6 +1579,30 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x1612 "$(tdir_msp430x1612)" msp430all
+emsp430x2001.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2001 "$(tdir_msp430x2001)" msp430all
+emsp430x2011.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2011 "$(tdir_msp430x2011)" msp430all
+emsp430x2002.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2002 "$(tdir_msp430x2002)" msp430all
+emsp430x2012.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2012 "$(tdir_msp430x2012)" msp430all
+emsp430x2003.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2003 "$(tdir_msp430x2003)" msp430all
+emsp430x2013.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2013 "$(tdir_msp430x2013)" msp430all
 emsp430x2101.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -1491,14 +1611,130 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x2111 "$(tdir_msp430x2111)" msp430all
+emsp430x2112.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2112 "$(tdir_msp430x2112)" msp430all
 emsp430x2121.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x2121 "$(tdir_msp430x2121)" msp430all
+emsp430x2122.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2122 "$(tdir_msp430x2122)" msp430all
 emsp430x2131.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x2131 "$(tdir_msp430x2131)" msp430all
+emsp430x2132.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2132 "$(tdir_msp430x2132)" msp430all
+emsp430x2232.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2232 "$(tdir_msp430x2232)" msp430all
+emsp430x2234.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2234 "$(tdir_msp430x2234)" msp430all
+emsp430x2252.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2252 "$(tdir_msp430x2252)" msp430all
+emsp430x2254.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2254 "$(tdir_msp430x2254)" msp430all
+emsp430x2272.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2272 "$(tdir_msp430x2272)" msp430all
+emsp430x2274.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2274 "$(tdir_msp430x2274)" msp430all
+emsp430x233.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x233 "$(tdir_msp430x233)" msp430all
+emsp430x235.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x235 "$(tdir_msp430x235)" msp430all
+emsp430x2330.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2330 "$(tdir_msp430x2330)" msp430all
+emsp430x2350.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2350 "$(tdir_msp430x2350)" msp430all
+emsp430x2370.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2370 "$(tdir_msp430x2370)" msp430all
+emsp430x247.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x247 "$(tdir_msp430x247)" msp430all
+emsp430x248.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x248 "$(tdir_msp430x248)" msp430all
+emsp430x249.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x249 "$(tdir_msp430x249)" msp430all
+emsp430x2410.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2410 "$(tdir_msp430x2410)" msp430all
+emsp430x2471.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2471 "$(tdir_msp430x2471)" msp430all
+emsp430x2481.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2481 "$(tdir_msp430x2481)" msp430all
+emsp430x2491.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2491 "$(tdir_msp430x2491)" msp430all
+emsp430x2416.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2416 "$(tdir_msp430x2416)" msp430all
+emsp430x2417.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2417 "$(tdir_msp430x2417)" msp430all
+emsp430x2418.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2418 "$(tdir_msp430x2418)" msp430all
+emsp430x2419.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2419 "$(tdir_msp430x2419)" msp430all
+emsp430x2616.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2616 "$(tdir_msp430x2616)" msp430all
+emsp430x2617.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2617 "$(tdir_msp430x2617)" msp430all
+emsp430x2618.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2618 "$(tdir_msp430x2618)" msp430all
+emsp430x2619.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2619 "$(tdir_msp430x2619)" msp430all
 emsp430x311.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
   ${GEN_DEPENDS}
@@ -1551,6 +1787,46 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x417 "$(tdir_msp430x417)" msp430all
+emsp430x423.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x423 "$(tdir_msp430x423)" msp430all
+emsp430x425.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x425 "$(tdir_msp430x425)" msp430all
+emsp430x427.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x427 "$(tdir_msp430x427)" msp430all
+emsp430x4250.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4250 "$(tdir_msp430x4250)" msp430all
+emsp430x4260.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4260 "$(tdir_msp430x4260)" msp430all
+emsp430x4270.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4270 "$(tdir_msp430x4270)" msp430all
+emsp430xE4232.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE4232 "$(tdir_msp430xE4232)" msp430all
+emsp430xE4242.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE4242 "$(tdir_msp430xE4242)" msp430all
+emsp430xE4252.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE4252 "$(tdir_msp430xE4252)" msp430all
+emsp430xE4272.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE4272 "$(tdir_msp430xE4272)" msp430all
 emsp430xE423.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -1575,6 +1851,18 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430xW427 "$(tdir_msp430xW427)" msp430all
+emsp430xG4250.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4250 "$(tdir_msp430xG4250)" msp430all
+emsp430xG4260.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4260 "$(tdir_msp430xG4260)" msp430all
+emsp430xG4270.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4270 "$(tdir_msp430xG4270)" msp430all
 emsp430xG437.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -1599,6 +1887,18 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x437 "$(tdir_msp430x437)" msp430all
+emsp430x4351.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4351 "$(tdir_msp430x4351)" msp430all
+emsp430x4361.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4361 "$(tdir_msp430x4361)" msp430all
+emsp430x4371.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4371 "$(tdir_msp430x4371)" msp430all
 emsp430x447.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -1611,6 +1911,126 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x449 "$(tdir_msp430x449)" msp430all
+emsp430xG4616.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4616 "$(tdir_msp430xG4616)" msp430all
+emsp430xG4617.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4617 "$(tdir_msp430xG4617)" msp430all
+emsp430xG4618.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4618 "$(tdir_msp430xG4618)" msp430all
+emsp430xG4619.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4619 "$(tdir_msp430xG4619)" msp430all
+emsp430x4783.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4783 "$(tdir_msp430x4783)" msp430all
+emsp430x4784.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4784 "$(tdir_msp430x4784)" msp430all
+emsp430x4793.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4793 "$(tdir_msp430x4793)" msp430all
+emsp430x4794.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4794 "$(tdir_msp430x4794)" msp430all
+emsp430x47166.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47166 "$(tdir_msp430x47166)" msp430all
+emsp430x47176.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47176 "$(tdir_msp430x47176)" msp430all
+emsp430x47186.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47186 "$(tdir_msp430x47186)" msp430all
+emsp430x47196.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47196 "$(tdir_msp430x47196)" msp430all
+emsp430x47167.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47167 "$(tdir_msp430x47167)" msp430all
+emsp430x47177.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47177 "$(tdir_msp430x47177)" msp430all
+emsp430x47187.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47187 "$(tdir_msp430x47187)" msp430all
+emsp430x47197.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47197 "$(tdir_msp430x47197)" msp430all
+emsp430x5418.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5418 "$(tdir_msp430x5418)" msp430all
+emsp430x5419.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5419 "$(tdir_msp430x5419)" msp430all
+emsp430x5435.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5435 "$(tdir_msp430x5435)" msp430all
+emsp430x5436.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5436 "$(tdir_msp430x5436)" msp430all
+emsp430x5437.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5437 "$(tdir_msp430x5437)" msp430all
+emsp430x5438.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5438 "$(tdir_msp430x5438)" msp430all
+ecc430x5123.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x5123 "$(tdir_cc430x5123)" msp430all
+ecc430x5125.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x5125 "$(tdir_cc430x5125)" msp430all
+ecc430x6125.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6125 "$(tdir_cc430x6125)" msp430all
+ecc430x6135.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6135 "$(tdir_cc430x6135)" msp430all
+ecc430x6126.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6126 "$(tdir_cc430x6126)" msp430all
+ecc430x5137.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x5137 "$(tdir_cc430x5137)" msp430all
+ecc430x6127.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6127 "$(tdir_cc430x6127)" msp430all
+ecc430x6137.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6137 "$(tdir_cc430x6137)" msp430all
 enews.c: $(srcdir)/emulparams/news.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} news "$(tdir_news)"
diff -urN binutils-2.20.1/ld/Makefile.in binutils-2.20.1-mspgcc4/ld/Makefile.in
--- binutils-2.20.1/ld/Makefile.in	2010-03-03 08:06:21.000000000 -0600
+++ binutils-2.20.1-mspgcc4/ld/Makefile.in	2010-04-30 19:31:50.000000000 -0500
@@ -597,6 +597,9 @@
 	emsp430x147.o \
 	emsp430x148.o \
 	emsp430x149.o \
+	emsp430x1471.o \
+	emsp430x1481.o \
+	emsp430x1491.o \
 	emsp430x155.o \
 	emsp430x156.o \
 	emsp430x157.o \
@@ -606,10 +609,45 @@
 	emsp430x1610.o \
 	emsp430x1611.o \
 	emsp430x1612.o \
+	emsp430x2001.o \
+	emsp430x2011.o \
+	emsp430x2002.o \
+	emsp430x2012.o \
+	emsp430x2003.o \
+	emsp430x2014.o \
 	emsp430x2101.o \
 	emsp430x2111.o \
+	emsp430x2112.o \
 	emsp430x2121.o \
+	emsp430x2122.o \
 	emsp430x2131.o \
+	emsp430x2132.o \
+	emsp430x2232.o \
+	emsp430x2234.o \
+	emsp430x2252.o \
+	emsp430x2254.o \
+	emsp430x2272.o \
+	emsp430x2274.o \
+	emsp430x233.o \
+	emsp430x235.o \
+	emsp430x2330.o \
+	emsp430x2350.o \
+	emsp430x2370.o \
+	emsp430x247.o \
+	emsp430x248.o \
+	emsp430x249.o \
+	emsp430x2410.o \
+	emsp430x2471.o \
+	emsp430x2481.o \
+	emsp430x2491.o \
+	emsp430x2416.o \
+	emsp430x2417.o \
+	emsp430x2418.o \
+	emsp430x2419.o \
+	emsp430x2616.o \
+	emsp430x2617.o \
+	emsp430x2618.o \
+	emsp430x2619.o \
 	emsp430x311.o \
 	emsp430x312.o \
 	emsp430x313.o \
@@ -623,21 +661,67 @@
 	emsp430x413.o \
 	emsp430x415.o \
 	emsp430x417.o \
+	emsp430x423.o \
+	emsp430x425.o \
+	emsp430x427.o \
+	emsp430x4250.o \
+	emsp430x4260.o \
+	emsp430x4270.o \
 	emsp430xE423.o \
 	emsp430xE425.o \
 	emsp430xE427.o \
+	emsp430xE4232.o \
+	emsp430xE4242.o \
+	emsp430xE4252.o \
+	emsp430xE4272.o \
 	emsp430xW423.o \
 	emsp430xW425.o \
 	emsp430xW427.o \
+	emsp430xG4250.o \
+	emsp430xG4260.o \
+	emsp430xG4270.o \
 	emsp430xG437.o \
 	emsp430xG438.o \
 	emsp430xG439.o \
 	emsp430x435.o \
 	emsp430x436.o \
 	emsp430x437.o \
+	emsp430x4351.o \
+	emsp430x4361.o \
+	emsp430x4371.o \
 	emsp430x447.o \
 	emsp430x448.o \
 	emsp430x449.o \
+	emsp430xG4616.o \
+	emsp430xG4617.o \
+	emsp430xG4618.o \
+	emsp430xG4619.o \
+	emsp430x4783.o \
+	emsp430x4784.o \
+	emsp430x4793.o \
+	emsp430x4794.o \
+	emsp430x47166.o \
+	emsp430x47176.o \
+	emsp430x47186.o \
+	emsp430x47196.o \
+	emsp430x47167.o \
+	emsp430x47177.o \
+	emsp430x47187.o \
+	emsp430x47197.o \
+	emsp430x5418.o \
+	emsp430x5419.o \
+	emsp430x5435.o \
+	emsp430x5436.o \
+	emsp430x5437.o \
+	emsp430x5438.o \
+	ecc430x5123.o \
+	ecc430x5125.o \
+	ecc430x6125.o \
+	ecc430x6135.o \
+	ecc430x6126.o \
+	ecc430x5137.o \
+	ecc430x6127.o \
+	ecc430x6137.o \
 	enews.o \
 	ens32knbsd.o \
 	eor32.o \
@@ -2789,6 +2873,18 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x149 "$(tdir_msp430x149)" msp430all
+emsp430x1471.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1471 "$(tdir_msp430x1471)" msp430all
+emsp430x1481.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1481 "$(tdir_msp430x1481)" msp430all
+emsp430x1491.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1491 "$(tdir_msp430x1491)" msp430all
 emsp430x155.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -2825,6 +2921,30 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x1612 "$(tdir_msp430x1612)" msp430all
+emsp430x2001.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2001 "$(tdir_msp430x2001)" msp430all
+emsp430x2011.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2011 "$(tdir_msp430x2011)" msp430all
+emsp430x2002.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2002 "$(tdir_msp430x2002)" msp430all
+emsp430x2012.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2012 "$(tdir_msp430x2012)" msp430all
+emsp430x2003.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2003 "$(tdir_msp430x2003)" msp430all
+emsp430x2013.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2013 "$(tdir_msp430x2013)" msp430all
 emsp430x2101.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -2833,14 +2953,130 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x2111 "$(tdir_msp430x2111)" msp430all
+emsp430x2112.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2112 "$(tdir_msp430x2112)" msp430all
 emsp430x2121.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x2121 "$(tdir_msp430x2121)" msp430all
+emsp430x2122.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2122 "$(tdir_msp430x2122)" msp430all
 emsp430x2131.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x2131 "$(tdir_msp430x2131)" msp430all
+emsp430x2132.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2132 "$(tdir_msp430x2132)" msp430all
+emsp430x2232.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2232 "$(tdir_msp430x2232)" msp430all
+emsp430x2234.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2234 "$(tdir_msp430x2234)" msp430all
+emsp430x2252.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2252 "$(tdir_msp430x2252)" msp430all
+emsp430x2254.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2254 "$(tdir_msp430x2254)" msp430all
+emsp430x2272.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2272 "$(tdir_msp430x2272)" msp430all
+emsp430x2274.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2274 "$(tdir_msp430x2274)" msp430all
+emsp430x233.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x233 "$(tdir_msp430x233)" msp430all
+emsp430x235.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x235 "$(tdir_msp430x235)" msp430all
+emsp430x2330.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2330 "$(tdir_msp430x2330)" msp430all
+emsp430x2350.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2350 "$(tdir_msp430x2350)" msp430all
+emsp430x2370.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2370 "$(tdir_msp430x2370)" msp430all
+emsp430x247.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x247 "$(tdir_msp430x247)" msp430all
+emsp430x248.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x248 "$(tdir_msp430x248)" msp430all
+emsp430x249.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x249 "$(tdir_msp430x249)" msp430all
+emsp430x2410.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2410 "$(tdir_msp430x2410)" msp430all
+emsp430x2471.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2471 "$(tdir_msp430x2471)" msp430all
+emsp430x2481.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2481 "$(tdir_msp430x2481)" msp430all
+emsp430x2491.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2491 "$(tdir_msp430x2491)" msp430all
+emsp430x2416.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2416 "$(tdir_msp430x2416)" msp430all
+emsp430x2417.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2417 "$(tdir_msp430x2417)" msp430all
+emsp430x2418.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2418 "$(tdir_msp430x2418)" msp430all
+emsp430x2419.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2419 "$(tdir_msp430x2419)" msp430all
+emsp430x2616.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2616 "$(tdir_msp430x2616)" msp430all
+emsp430x2617.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2617 "$(tdir_msp430x2617)" msp430all
+emsp430x2618.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2618 "$(tdir_msp430x2618)" msp430all
+emsp430x2619.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2619 "$(tdir_msp430x2619)" msp430all
 emsp430x311.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
   ${GEN_DEPENDS}
@@ -2893,6 +3129,46 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x417 "$(tdir_msp430x417)" msp430all
+emsp430x423.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x423 "$(tdir_msp430x423)" msp430all
+emsp430x425.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x425 "$(tdir_msp430x425)" msp430all
+emsp430x427.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x427 "$(tdir_msp430x427)" msp430all
+emsp430x4250.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4250 "$(tdir_msp430x4250)" msp430all
+emsp430x4260.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4260 "$(tdir_msp430x4260)" msp430all
+emsp430x4270.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4270 "$(tdir_msp430x4270)" msp430all
+emsp430xE4232.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE4232 "$(tdir_msp430xE4232)" msp430all
+emsp430xE4242.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE4242 "$(tdir_msp430xE4242)" msp430all
+emsp430xE4252.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE4252 "$(tdir_msp430xE4252)" msp430all
+emsp430xE4272.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE4272 "$(tdir_msp430xE4272)" msp430all
 emsp430xE423.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -2917,6 +3193,18 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430xW427 "$(tdir_msp430xW427)" msp430all
+emsp430xG4250.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4250 "$(tdir_msp430xG4250)" msp430all
+emsp430xG4260.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4260 "$(tdir_msp430xG4260)" msp430all
+emsp430xG4270.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4270 "$(tdir_msp430xG4270)" msp430all
 emsp430xG437.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -2941,6 +3229,18 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x437 "$(tdir_msp430x437)" msp430all
+emsp430x4351.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4351 "$(tdir_msp430x4351)" msp430all
+emsp430x4361.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4361 "$(tdir_msp430x4361)" msp430all
+emsp430x4371.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4371 "$(tdir_msp430x4371)" msp430all
 emsp430x447.c: $(srcdir)/emulparams/msp430all.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
@@ -2953,6 +3253,126 @@
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} msp430x449 "$(tdir_msp430x449)" msp430all
+emsp430xG4616.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4616 "$(tdir_msp430xG4616)" msp430all
+emsp430xG4617.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4617 "$(tdir_msp430xG4617)" msp430all
+emsp430xG4618.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4618 "$(tdir_msp430xG4618)" msp430all
+emsp430xG4619.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG4619 "$(tdir_msp430xG4619)" msp430all
+emsp430x4783.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4783 "$(tdir_msp430x4783)" msp430all
+emsp430x4784.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4784 "$(tdir_msp430x4784)" msp430all
+emsp430x4793.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4793 "$(tdir_msp430x4793)" msp430all
+emsp430x4794.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x4794 "$(tdir_msp430x4794)" msp430all
+emsp430x5418.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5418 "$(tdir_msp430x5418)" msp430all
+emsp430x47166.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47166 "$(tdir_msp430x47166)" msp430all
+emsp430x47176.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47176 "$(tdir_msp430x47176)" msp430all
+emsp430x47186.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47186 "$(tdir_msp430x47186)" msp430all
+emsp430x47196.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47196 "$(tdir_msp430x47196)" msp430all
+emsp430x47167.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47167 "$(tdir_msp430x47167)" msp430all
+emsp430x47177.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47177 "$(tdir_msp430x47177)" msp430all
+emsp430x47187.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47187 "$(tdir_msp430x47187)" msp430all
+emsp430x47197.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x47197 "$(tdir_msp430x47197)" msp430all
+emsp430x5419.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5419 "$(tdir_msp430x5419)" msp430all
+emsp430x5435.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5435 "$(tdir_msp430x5435)" msp430all
+emsp430x5436.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5436 "$(tdir_msp430x5436)" msp430all
+emsp430x5437.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5437 "$(tdir_msp430x5437)" msp430all
+emsp430x5438.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x5438 "$(tdir_msp430x5438)" msp430all
+ecc430x5123.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x5123 "$(tdir_cc430x5123)" msp430all
+ecc430x5125.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x5125 "$(tdir_cc430x5125)" msp430all
+ecc430x6125.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6125 "$(tdir_cc430x6125)" msp430all
+ecc430x6135.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6135 "$(tdir_cc430x6135)" msp430all
+ecc430x6126.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6126 "$(tdir_cc430x6126)" msp430all
+ecc430x5137.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x5137 "$(tdir_cc430x5137)" msp430all
+ecc430x6127.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6127 "$(tdir_cc430x6127)" msp430all
+ecc430x6137.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} cc430x6137 "$(tdir_cc430x6137)" msp430all
 enews.c: $(srcdir)/emulparams/news.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} news "$(tdir_news)"
diff -urN binutils-2.20.1/ld/configure.tgt binutils-2.20.1-mspgcc4/ld/configure.tgt
--- binutils-2.20.1/ld/configure.tgt	2009-08-06 12:38:03.000000000 -0500
+++ binutils-2.20.1-mspgcc4/ld/configure.tgt	2010-04-30 19:31:50.000000000 -0500
@@ -426,7 +426,7 @@
 mt-*elf)                targ_emul=elf32mt
 			;;
 msp430-*-*)             targ_emul=msp430x110
-                        targ_extra_emuls="msp430x112 msp430x1101 msp430x1111 msp430x1121 msp430x1122 msp430x1132 msp430x122 msp430x123 msp430x1222 msp430x1232 msp430x133 msp430x135 msp430x1331 msp430x1351 msp430x147 msp430x148 msp430x149 msp430x155 msp430x156 msp430x157 msp430x167 msp430x168 msp430x169 msp430x1610 msp430x1611 msp430x1612 msp430x2101 msp430x2111 msp430x2121 msp430x2131 msp430x311 msp430x312 msp430x313 msp430x314 msp430x315 msp430x323 msp430x325 msp430x336 msp430x337 msp430x412 msp430x413 msp430x415 msp430x417 msp430xE423 msp430xE425 msp430xE427 msp430xW423 msp430xW425 msp430xW427 msp430xG437 msp430xG438 msp430xG439 msp430x435 msp430x436 msp430x437 msp430x447 msp430x448 msp430x449"
+                        targ_extra_emuls="msp430x112 msp430x1101 msp430x1111 msp430x1121 msp430x1122 msp430x1132 msp430x122 msp430x123 msp430x1222 msp430x1232 msp430x133 msp430x135 msp430x1331 msp430x1351 msp430x147 msp430x148 msp430x149 msp430x1471 msp430x1481 msp430x1491 msp430x155 msp430x156 msp430x157 msp430x167 msp430x168 msp430x169 msp430x1610 msp430x1611 msp430x1612 msp430x2001 msp430x2011 msp430x2002 msp430x2012 msp430x2003 msp430x2013 msp430x2101 msp430x2111 msp430x2112 msp430x2121 msp430x2122 msp430x2131 msp430x2132 msp430x2232 msp430x2234 msp430x2252 msp430x2254 msp430x2272 msp430x2274 msp430x233 msp430x235 msp430x2330 msp430x2350 msp430x2370 msp430x247 msp430x248 msp430x249 msp430x2410 msp430x2471 msp430x2481 msp430x2491 msp430x2416 msp430x2417 msp430x2418 msp430x2419 msp430x2616 msp430x2617 msp430x2618 msp430x2619 msp430x311 msp430x312 msp430x313 msp430x314 msp430x315 msp430x323 msp430x325 msp430x336 msp430x337 msp430x412 msp430x413 msp430x415 msp430x417 msp430x423 msp430x425 msp430x427 msp430x4250 msp430x4260 msp430x4270 msp430xE423 msp430xE425 msp430xE427 msp430xE4232 msp430xE4242 msp430xE4252 msp430xE4272 msp430xW423 msp430xW425 msp430xW427 msp430xG4250 msp430xG4260 msp430xG4270 msp430xG437 msp430xG438 msp430xG439 msp430x435 msp430x436 msp430x437 msp430x4351 msp430x4361 msp430x4371 msp430x447 msp430x448 msp430x449 msp430xG4616 msp430xG4617 msp430xG4618 msp430xG4619 msp430x4783 msp430x4784 msp430x4793 msp430x4794 msp430x47166 msp430x47176 msp430x47186 msp430x47196 msp430x47167 msp430x47177 msp430x47187 msp430x47197 msp430x5418 msp430x5419 msp430x5435 msp430x5436 msp430x5437 msp430x5438 cc430x5123 cc430x5125 cc430x6125 cc430x6135 cc430x6126 cc430x5137 cc430x6127 cc430x6137"
 			;;
 ns32k-pc532-mach* | ns32k-pc532-ux*)  targ_emul=pc532macha ;;
 ns32k-*-netbsd* | ns32k-pc532-lites*) targ_emul=ns32knbsd
diff -urN binutils-2.20.1/ld/emulparams/msp430all.sh binutils-2.20.1-mspgcc4/ld/emulparams/msp430all.sh
--- binutils-2.20.1/ld/emulparams/msp430all.sh	2006-06-19 21:22:14.000000000 -0500
+++ binutils-2.20.1-mspgcc4/ld/emulparams/msp430all.sh	2010-04-30 19:31:50.000000000 -0500
@@ -18,7 +18,7 @@
 ROM_SIZE=0x3e0
 RAM_START=0x0200
 RAM_SIZE=128
-STACK=0x280
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x1101" ] ; then
@@ -27,7 +27,7 @@
 ROM_SIZE=0x3e0
 RAM_START=0x0200
 RAM_SIZE=128
-STACK=0x280
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x1111" ] ; then
@@ -36,7 +36,7 @@
 ROM_SIZE=0x07e0
 RAM_START=0x0200
 RAM_SIZE=128
-STACK=0x280
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x112" ] ; then
@@ -45,25 +45,16 @@
 ROM_SIZE=0xfe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x1121" ] ; then
+if [ "${MSP430_NAME}" = "msp430x1121" -o "${MSP430_NAME}" = "msp430x1122" ] ; then
 ARCH=msp:110
 ROM_START=0xf000
 ROM_SIZE=0x0fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
-fi
-
-if [ "${MSP430_NAME}" = "msp430x1122" ] ; then
-ARCH=msp:110
-ROM_START=0xf000
-ROM_SIZE=0x0fe0
-RAM_START=0x0200
-RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x1132" ] ; then
@@ -72,106 +63,70 @@
 ROM_SIZE=0x1fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
-fi
-
-if [ "${MSP430_NAME}" = "msp430x122" ] ; then
-ARCH=msp:12
-ROM_START=0xf000
-ROM_SIZE=0xfe0
-RAM_START=0x0200
-RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x1222" ] ; then
+if [ "${MSP430_NAME}" = "msp430x122" -o "${MSP430_NAME}" = "msp430x1222" ] ; then
 ARCH=msp:12
 ROM_START=0xf000
 ROM_SIZE=0xfe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x123" ] ; then
+if [ "${MSP430_NAME}" = "msp430x123" -o "${MSP430_NAME}" = "msp430x1232" ] ; then
 ARCH=msp:12
 ROM_START=0xe000
 ROM_SIZE=0x1fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
-fi
-
-if [ "${MSP430_NAME}" = "msp430x1232" ] ; then
-ARCH=msp:12
-ROM_START=0xe000
-ROM_SIZE=0x1fe0
-RAM_START=0x0200
-RAM_SIZE=256
-STACK=0x300
-fi
-
-if [ "${MSP430_NAME}" = "msp430x133" ] ; then
-ARCH=msp:13
-ROM_START=0xe000
-ROM_SIZE=0x1fe0
-RAM_START=0x0200
-RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x1331" ] ; then
+if [ "${MSP430_NAME}" = "msp430x133" -o "${MSP430_NAME}" = "msp430x1331" ] ; then
 ARCH=msp:13
 ROM_START=0xe000
 ROM_SIZE=0x1fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x135" ] ; then
+if [ "${MSP430_NAME}" = "msp430x135" -o "${MSP430_NAME}" = "msp430x1351" ] ; then
 ARCH=msp:13
 ROM_START=0xc000
 ROM_SIZE=0x3fe0
 RAM_START=0x0200
 RAM_SIZE=512
-STACK=0x400
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x1351" ] ; then
-ARCH=msp:13
-ROM_START=0xc000
-ROM_SIZE=0x3fe0
-RAM_START=0x0200
-RAM_SIZE=512
-STACK=0x400
-fi
-
-if [ "${MSP430_NAME}" = "msp430x147" ] ; then
+if [ "${MSP430_NAME}" = "msp430x147" -o  "${MSP430_NAME}" = "msp430x1471" ] ; then
 ARCH=msp:14
 ROM_START=0x8000
 ROM_SIZE=0x7fe0
 RAM_START=0x0200
-RAM_SIZE=1K
-STACK=0x600
+RAM_SIZE=1024
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x148" ] ; then
+if [ "${MSP430_NAME}" = "msp430x148" -o "${MSP430_NAME}" = "msp430x1481" ] ; then
 ARCH=msp:14
 ROM_START=0x4000
 ROM_SIZE=0xbfe0
 RAM_START=0x0200
-RAM_SIZE=0x0800
-STACK=0xa00
+RAM_SIZE=2048
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x149" ] ; then
+if [ "${MSP430_NAME}" = "msp430x149" -o "${MSP430_NAME}" = "msp430x1491" ] ; then
 ARCH=msp:14
 ROM_START=0x1100
 ROM_SIZE=0xeee0
 RAM_START=0x0200
-RAM_SIZE=0x0800
-STACK=0xa00
+RAM_SIZE=2048
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x155" ] ; then
@@ -180,7 +135,7 @@
 ROM_SIZE=0x3fe0
 RAM_START=0x0200
 RAM_SIZE=512
-STACK=0x400
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x156" ] ; then
@@ -189,7 +144,7 @@
 ROM_SIZE=0x5fe0
 RAM_START=0x0200
 RAM_SIZE=512
-STACK=0x400
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x157" ] ; then
@@ -197,8 +152,8 @@
 ROM_START=0x8000
 ROM_SIZE=0x7fe0
 RAM_START=0x0200
-RAM_SIZE=1K
-STACK=0x600
+RAM_SIZE=1024
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x167" ] ; then
@@ -206,8 +161,8 @@
 ROM_START=0x8000
 ROM_SIZE=0x7fe0
 RAM_START=0x0200
-RAM_SIZE=1K
-STACK=0x600
+RAM_SIZE=1024
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x168" ] ; then
@@ -215,8 +170,8 @@
 ROM_START=0x4000
 ROM_SIZE=0xbfe0
 RAM_START=0x0200
-RAM_SIZE=0x0800
-STACK=0xa00
+RAM_SIZE=2048
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x169" ] ; then
@@ -224,8 +179,8 @@
 ROM_START=0x1100
 ROM_SIZE=0xeee0
 RAM_START=0x0200
-RAM_SIZE=0x0800
-STACK=0xa00
+RAM_SIZE=2048
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x1610" ] ; then
@@ -234,7 +189,7 @@
 ROM_SIZE=0x7fe0
 RAM_START=0x1100
 RAM_SIZE=0x1400
-STACK=0x2500
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x1611" ] ; then
@@ -243,7 +198,7 @@
 ROM_SIZE=0xbfe0
 RAM_START=0x1100
 RAM_SIZE=0x2800
-STACK=0x3900
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x1612" ] ; then
@@ -252,7 +207,25 @@
 ROM_SIZE=0xdae0
 RAM_START=0x1100
 RAM_SIZE=0x1400
-STACK=0x2500
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2001" -o "${MSP430_NAME}" = "msp430x2002" -o "${MSP430_NAME}" = "msp430x2003" ] ; then
+ARCH=msp:20
+ROM_START=0xFC00
+ROM_SIZE=0x03e0
+RAM_START=0x0200
+RAM_SIZE=128
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2011" -o "${MSP430_NAME}" = "msp430x2012" -o "${MSP430_NAME}" = "msp430x2013" ] ; then
+ARCH=msp:20
+ROM_START=0xF800
+ROM_SIZE=0x07e0
+RAM_START=0x0200
+RAM_SIZE=128
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x2101" ] ; then
@@ -261,34 +234,210 @@
 ROM_SIZE=0x03e0
 RAM_START=0x0200
 RAM_SIZE=128
-STACK=0x280
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x2111" ] ; then
+if [ "${MSP430_NAME}" = "msp430x2111" -o "${MSP430_NAME}" = "msp430x2112" ] ; then
 ARCH=msp:21
 ROM_START=0xF800
 ROM_SIZE=0x07e0
 RAM_START=0x0200
 RAM_SIZE=128
-STACK=0x280
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x2121" ] ; then
+if [ "${MSP430_NAME}" = "msp430x2121" -o "${MSP430_NAME}" = "msp430x2122" ] ; then
 ARCH=msp:21
 ROM_START=0xf000
 ROM_SIZE=0x0fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x2131" ] ; then
+if [ "${MSP430_NAME}" = "msp430x2131" -o "${MSP430_NAME}" = "msp430x2132" ] ; then
 ARCH=msp:21
 ROM_START=0xe000
 ROM_SIZE=0x1fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2232" -o "${MSP430_NAME}" = "msp430x2234" ] ; then
+ARCH=msp:22
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=512
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2252" -o "${MSP430_NAME}" = "msp430x2254" ] ; then
+ARCH=msp:22
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+RAM_SIZE=512
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2272" -o "${MSP430_NAME}" = "msp430x2274" ] ; then
+ARCH=msp:22
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x0200
+RAM_SIZE=1024
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x233" ] ; then
+ARCH=msp:24
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=0x0400
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x235" ] ; then
+ARCH=msp:24
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+RAM_SIZE=2048
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2330" ] ; then
+ARCH=msp:23
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=0x0400
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2350" ] ; then
+ARCH=msp:23
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+RAM_SIZE=2048
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2370" ] ; then
+ARCH=msp:23
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x0200
+RAM_SIZE=2048
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x247" -o "${MSP430_NAME}" = "msp430x2471" ] ; then
+ARCH=msp:24
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x1100
+RAM_SIZE=4096
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x248" -o "${MSP430_NAME}" = "msp430x2481" ] ; then
+ARCH=msp:24
+ROM_START=0x4000
+ROM_SIZE=0xbfe0
+RAM_START=0x1100
+RAM_SIZE=4096
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x249" -o "${MSP430_NAME}" = "msp430x2491" ] ; then
+ARCH=msp:24
+ROM_START=0x1100
+ROM_SIZE=0xeee0
+RAM_START=0x0200
+RAM_SIZE=2048
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2410" ] ; then
+ARCH=msp:24
+ROM_START=0x2100
+ROM_SIZE=0xdee0
+RAM_START=0x1100
+RAM_SIZE=4096
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2416" -o "${MSP430_NAME}" = "msp430x2616" ] ; then
+if [ "${MSP430_NAME}" = "msp430x2416" ] ; then
+ARCH=msp:241
+else
+ARCH=msp:26
+fi
+ROM_START=0x2100
+ROM_SIZE=0x16f00
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=4096
+VECTORS_START=0xffc0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2417" -o "${MSP430_NAME}" = "msp430x2617" ] ; then
+if [ "${MSP430_NAME}" = "msp430x2417" ] ; then
+ARCH=msp:241
+else
+ARCH=msp:26
+fi
+ROM_START=0x3100
+ROM_SIZE=0x16f00
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=8192
+VECTORS_START=0xffc0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2418" -o "${MSP430_NAME}" = "msp430x2618" ] ; then
+if [ "${MSP430_NAME}" = "msp430x2418" ] ; then
+ARCH=msp:241
+else
+ARCH=msp:26
+fi
+ROM_START=0x3100
+ROM_SIZE=0x1cf00
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=8192
+VECTORS_START=0xffc0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x2419" -o "${MSP430_NAME}" = "msp430x2619" ] ; then
+if [ "${MSP430_NAME}" = "msp430x2419" ] ; then
+ARCH=msp:241
+else
+ARCH=msp:26
+fi
+ROM_START=0x2100
+ROM_SIZE=0x1df00
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=4096
+VECTORS_START=0xffc0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x311" ] ; then
@@ -298,7 +447,7 @@
 ROM_SIZE=0x07e0
 RAM_START=0x0200
 RAM_SIZE=128
-STACK=0x280
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x312" ] ; then
@@ -308,7 +457,7 @@
 ROM_SIZE=0x0fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x313" ] ; then
@@ -318,7 +467,7 @@
 ROM_SIZE=0x1fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x314" ] ; then
@@ -328,7 +477,7 @@
 ROM_SIZE=0x2fe0
 RAM_START=0x0200
 RAM_SIZE=512
-STACK=0x400
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x315" ] ; then
@@ -338,7 +487,7 @@
 ROM_SIZE=0x3fe0
 RAM_START=0x0200
 RAM_SIZE=512
-STACK=0x400
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x323" ] ; then
@@ -348,7 +497,7 @@
 ROM_SIZE=0x1fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x325" ] ; then
@@ -358,7 +507,7 @@
 ROM_SIZE=0x3fe0
 RAM_START=0x0200
 RAM_SIZE=512
-STACK=0x400
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x336" ] ; then
@@ -368,7 +517,7 @@
 ROM_SIZE=0x5fe0
 RAM_START=0x0200
 RAM_SIZE=1024
-STACK=0x600
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x337" ] ; then
@@ -378,7 +527,7 @@
 ROM_SIZE=0x7fe0
 RAM_START=0x0200
 RAM_SIZE=1024
-STACK=0x600
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x412" ] ; then
@@ -387,7 +536,7 @@
 ROM_SIZE=0x0fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x413" ] ; then
@@ -396,7 +545,7 @@
 ROM_SIZE=0x1fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x415" ] ; then
@@ -405,7 +554,7 @@
 ROM_SIZE=0x3fe0
 RAM_START=0x0200
 RAM_SIZE=512
-STACK=0x400
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x417" ] ; then
@@ -414,34 +563,79 @@
 ROM_SIZE=0x7fe0
 RAM_START=0x0200
 RAM_SIZE=1024
-STACK=0x600
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x423" ] ; then
+ARCH=msp:42
+ROM_START=0xe000
+ROM_SIZE=0x1fe0
+RAM_START=0x0200
+RAM_SIZE=256
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x425" -o "${MSP430_NAME}" = "msp430x4250" ] ; then
+ARCH=msp:42
+ROM_START=0xc000
+ROM_SIZE=0x3fe0
+RAM_START=0x0200
+if [ "${MSP430_NAME}" = "msp430x4250" ] ; then
+RAM_SIZE=256
+else
+RAM_SIZE=512
+fi
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x435" ] ; then
+if [ "${MSP430_NAME}" = "msp430x4260" ] ; then
+ARCH=msp:42
+ROM_START=0xa000
+ROM_SIZE=0x5fe0
+RAM_START=0x0200
+RAM_SIZE=256
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x427" -o "${MSP430_NAME}" = "msp430x4270" ] ; then
+ARCH=msp:42
+ROM_START=0x8000
+ROM_SIZE=0x7fe0
+RAM_START=0x0200
+if [ "${MSP430_NAME}" = "msp430x4270" ] ; then
+RAM_SIZE=256
+else
+RAM_SIZE=1024
+fi
+VECTORS_START=0xffe0
+fi
+
+
+if [ "${MSP430_NAME}" = "msp430x435" -o "${MSP430_NAME}" = "msp430x4351" ] ; then
 ARCH=msp:43
 ROM_START=0xc000
 ROM_SIZE=0x3fe0
 RAM_START=0x0200
 RAM_SIZE=512
-STACK=0x400
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x436" ] ; then
+if [ "${MSP430_NAME}" = "msp430x436" -o "${MSP430_NAME}" = "msp430x4361" ] ; then
 ARCH=msp:43
 ROM_START=0xa000
 ROM_SIZE=0x5fe0
 RAM_START=0x0200
 RAM_SIZE=1024
-STACK=0x600
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430x437" ] ; then
+if [ "${MSP430_NAME}" = "msp430x437" -o "${MSP430_NAME}" = "msp430x4371" ] ; then
 ARCH=msp:43
 ROM_START=0x8000
 ROM_SIZE=0x7fe0
 RAM_START=0x0200
 RAM_SIZE=1024
-STACK=0x600
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x447" ] ; then
@@ -450,7 +644,7 @@
 ROM_SIZE=0x7fe0
 RAM_START=0x0200
 RAM_SIZE=1024
-STACK=0x600
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x448" ] ; then
@@ -458,8 +652,8 @@
 ROM_START=0x4000
 ROM_SIZE=0xbfe0
 RAM_START=0x0200
-RAM_SIZE=0x0800
-STACK=0xa00
+RAM_SIZE=2048
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430x449" ] ; then
@@ -467,36 +661,69 @@
 ROM_START=0x1100
 ROM_SIZE=0xeee0
 RAM_START=0x0200
-RAM_SIZE=0x0800
-STACK=0xa00
+RAM_SIZE=2048
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430xE423" ] ; then
+if [ "${MSP430_NAME}" = "msp430xE423" -o  "${MSP430_NAME}" = "msp430xW423" \
+     -o "${MSP430_NAME}" = "msp430xE4232" \
+   ] ; then
 ARCH=msp:42
 ROM_START=0xe000
 ROM_SIZE=0x1fe0
 RAM_START=0x0200
 RAM_SIZE=256
-STACK=0x300
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430xE425" ] ; then
+if [ "${MSP430_NAME}" = "msp430xE4242" ] ; then
+ARCH=msp:42
+ROM_START=0xd000
+ROM_SIZE=0x2fe0
+RAM_START=0x0200
+RAM_SIZE=512
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430xE425" -o "${MSP430_NAME}" = "msp430xW425" \
+    -o "${MSP430_NAME}" = "msp430xG4250" -o "${MSP430_NAME}" = "msp430xE4252" \
+   ] ; then
 ARCH=msp:42
 ROM_START=0xc000
 ROM_SIZE=0x3fe0
 RAM_START=0x0200
+if [ "${MSP430_NAME}" = "msp430xG4250" ] ; then
+RAM_SIZE=256
+else
 RAM_SIZE=512
-STACK=0x400
+fi
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430xG4260" ] ; then
+ARCH=msp:42
+ROM_START=0xa000
+ROM_SIZE=0x5fe0
+RAM_START=0x0200
+RAM_SIZE=256
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430xE427" ] ; then
+if [ "${MSP430_NAME}" = "msp430xE427" -o "${MSP430_NAME}" = "msp430xW427" \
+    -o "${MSP430_NAME}" = "msp430xG4270" -o "${MSP430_NAME}" = "msp430xE4272" \
+   ] ; then
 ARCH=msp:42
 ROM_START=0x8000
 ROM_SIZE=0x7fe0
 RAM_START=0x0200
+if [ "${MSP430_NAME}" = "msp430xG4270" ] ; then
+RAM_SIZE=256
+else
 RAM_SIZE=1024
-STACK=0x600
 fi
+VECTORS_START=0xffe0
+fi
+
 
 if [ "${MSP430_NAME}" = "msp430xG437" ] ; then
 ARCH=msp:43
@@ -504,7 +731,7 @@
 ROM_SIZE=0x7fe0
 RAM_START=0x0200
 RAM_SIZE=1024
-STACK=0x600
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430xG438" ] ; then
@@ -512,8 +739,8 @@
 ROM_START=0x4000
 ROM_SIZE=0xbef0
 RAM_START=0x0200
-RAM_SIZE=0x0800
-STACK=0xa00
+RAM_SIZE=2048
+VECTORS_START=0xffe0
 fi
 
 if [ "${MSP430_NAME}" = "msp430xG439" ] ; then
@@ -521,33 +748,222 @@
 ROM_START=0x1100
 ROM_SIZE=0xeee0
 RAM_START=0x0200
-RAM_SIZE=0x0800
-STACK=0xa00
+RAM_SIZE=2048
+VECTORS_START=0xffe0
 fi
 
-if [ "${MSP430_NAME}" = "msp430xW423" ] ; then
-ARCH=msp:42
-ROM_START=0xe000
-ROM_SIZE=0x1fe0
-RAM_START=0x0200
-RAM_SIZE=256
-STACK=0x300
+if [ "${MSP430_NAME}" = "msp430xG4616" ] ; then
+ARCH=msp:46
+ROM_START=0x2100
+ROM_SIZE=0x17000
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=4096
+VECTORS_START=0xffc0
 fi
 
-if [ "${MSP430_NAME}" = "msp430xW425" ] ; then
-ARCH=msp:42
-ROM_START=0xc000
-ROM_SIZE=0x3fe0
-RAM_START=0x0200
-RAM_SIZE=512
-STACK=0x400
+if [ "${MSP430_NAME}" = "msp430xG4617" ] ; then
+ARCH=msp:46
+ROM_START=0x3100
+ROM_SIZE=0x17000
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=8192
+VECTORS_START=0xffc0
 fi
 
-if [ "${MSP430_NAME}" = "msp430xW427" ] ; then
-ARCH=msp:42
-ROM_START=0x8000
-ROM_SIZE=0x7fe0
-RAM_START=0x0200
-RAM_SIZE=0x400
-STACK=0x600
+if [ "${MSP430_NAME}" = "msp430xG4618" ] ; then
+ARCH=msp:46
+ROM_START=0x3100
+ROM_SIZE=0x1D000
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=8192
+VECTORS_START=0xffc0
 fi
+
+if [ "${MSP430_NAME}" = "msp430xG4619" ] ; then
+ARCH=msp:46
+ROM_START=0x2100
+ROM_SIZE=0x1E000
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=4096
+VECTORS_START=0xffc0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x4783" -o "${MSP430_NAME}" = "msp430x4784" ] ; then
+ARCH=msp:47
+ROM_START=0x4000
+ROM_SIZE=0xbfe0
+RAM_START=0x200
+RAM_SIZE=2048
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x4793" -o "${MSP430_NAME}" = "msp430x4794" ] ; then
+ARCH=msp:47
+ROM_START=0x1100
+ROM_SIZE=0xeee0
+RAM_START=0x200
+RAM_SIZE=2560
+VECTORS_START=0xffe0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x47166" -o "${MSP430_NAME}" = "msp430x47167" ] ; then
+ARCH=msp:471
+ROM_START=0x2100
+ROM_SIZE=0x16f00
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=4096
+VECTORS_START=0xffc0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x47176" -o "${MSP430_NAME}" = "msp430x47177" ] ; then
+ARCH=msp:471
+ROM_START=0x3100
+ROM_SIZE=0x16f00
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=8192
+VECTORS_START=0xffc0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x47186" -o "${MSP430_NAME}" = "msp430x47187" ] ; then
+ARCH=msp:471
+ROM_START=0x3100
+ROM_SIZE=0x1cf00
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=8192
+VECTORS_START=0xffc0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x47196" -o "${MSP430_NAME}" = "msp430x47197" ] ; then
+ARCH=msp:471
+ROM_START=0x2100
+ROM_SIZE=0x1df00
+INFO_START=0x1000
+INFO_SIZE=256
+BOOT_START=0x0c00
+BOOT_SIZE=1024
+RAM_START=0x1100
+RAM_SIZE=4096
+VECTORS_START=0xffc0
+fi
+
+if [ "${MSP430_NAME}" = "msp430x5418" -o "${MSP430_NAME}" = "msp430x5419" ] ; then
+ARCH=msp:54
+ROM_START=0x5c00
+ROM_SIZE=0x20000
+INFO_START=0x1800
+INFO_SIZE=512
+BOOT_START=0x1000
+BOOT_SIZE=2048
+RAM_START=0x1c00
+RAM_SIZE=16384
+VECTORS_START=0xff80
+fi
+
+if [ "${MSP430_NAME}" = "msp430x5435" -o "${MSP430_NAME}" = "msp430x5436" ] ; then
+ARCH=msp:54
+ROM_START=0x5c00
+ROM_SIZE=0x30000
+INFO_START=0x1800
+INFO_SIZE=512
+BOOT_START=0x1000
+BOOT_SIZE=2048
+RAM_START=0x1c00
+RAM_SIZE=16384
+VECTORS_START=0xff80
+fi
+
+if [ "${MSP430_NAME}" = "msp430x5437" -o "${MSP430_NAME}" = "msp430x5438" ] ; then
+ARCH=msp:54
+ROM_START=0x5c00
+ROM_SIZE=0x40000
+INFO_START=0x1800
+INFO_SIZE=512
+BOOT_START=0x1000
+BOOT_SIZE=2048
+RAM_START=0x1c00
+RAM_SIZE=16384
+VECTORS_START=0xff80
+fi
+
+if [ "${MSP430_NAME}" = "cc430x5123" ] ; then
+ARCH=msp:54
+ROM_START=0xe000
+ROM_SIZE=0x2000
+INFO_START=0x1800
+INFO_SIZE=512
+BOOT_START=0x1000
+BOOT_SIZE=2048
+RAM_START=0x1c00
+RAM_SIZE=2048
+VECTORS_START=0xff80
+fi
+
+if [ "${MSP430_NAME}" = "cc430x5125" -o "${MSP430_NAME}" = "cc430x6125" -o "${MSP430_NAME}" = "cc430x6135" ] ; then
+ARCH=msp:54
+ROM_START=0xc000
+ROM_SIZE=0x4000
+INFO_START=0x1800
+INFO_SIZE=512
+BOOT_START=0x1000
+BOOT_SIZE=2048
+RAM_START=0x1c00
+RAM_SIZE=2048
+VECTORS_START=0xff80
+fi
+
+if [ "${MSP430_NAME}" = "cc430x6126" ] ; then
+ARCH=msp:54
+ROM_START=0x8000
+ROM_SIZE=0x8000
+INFO_START=0x1800
+INFO_SIZE=512
+BOOT_START=0x1000
+BOOT_SIZE=2048
+RAM_START=0x1c00
+RAM_SIZE=2048
+VECTORS_START=0xff80
+fi
+
+if [ "${MSP430_NAME}" = "cc430x5137" -o "${MSP430_NAME}" = "cc430x6127" -o "${MSP430_NAME}" = "cc430x6137" ] ; then
+ARCH=msp:54
+ROM_START=0x8000
+ROM_SIZE=0x8000
+INFO_START=0x1800
+INFO_SIZE=512
+BOOT_START=0x1000
+BOOT_SIZE=2048
+RAM_START=0x1c00
+RAM_SIZE=4096
+VECTORS_START=0xff80
+fi
+
+STACK=$(printf "0x%x" $(( RAM_START + RAM_SIZE )) )
+VECTORS_SIZE=$((0x10000 - VECTORS_START))
diff -urN binutils-2.20.1/ld/scripttempl/elf32msp430.sc binutils-2.20.1-mspgcc4/ld/scripttempl/elf32msp430.sc
--- binutils-2.20.1/ld/scripttempl/elf32msp430.sc	2009-10-09 08:12:35.000000000 -0500
+++ binutils-2.20.1-mspgcc4/ld/scripttempl/elf32msp430.sc	2010-04-30 19:31:50.000000000 -0500
@@ -14,9 +14,32 @@
     ${RELOCATING+ PROVIDE (__heap_bottom = .) ; }
     ${RELOCATING+ PROVIDE (__heap_top = ${HEAP_START} + ${HEAP_LENGTH}) ; }
   } ${RELOCATING+ > heap}"
-HEAP_MEMORY_MSP430="heap(rwx) 		: ORIGIN = $HEAP_START,	LENGTH = $HEAP_LENGTH"
+HEAP_MEMORY_MSP430="heap(rwx)         : ORIGIN = $HEAP_START,    LENGTH = $HEAP_LENGTH"
 fi
 
+ROM_END=$(( $ROM_START + $ROM_SIZE ))
+if [ $ROM_END -gt 65536 ]
+then
+NEAR_ROM_SIZE=$(printf "0x%x" $(( $VECTORS_START - $ROM_START )) )
+FAR_ROM_SIZE=$(printf  "0x%x" $(( $ROM_START + $ROM_SIZE - 0x10000 )) )
+
+TEXT_REGION_MSP430="text   (rx)       : ORIGIN = $ROM_START,     LENGTH = $NEAR_ROM_SIZE
+  fartext(rx)       : ORIGIN = 0x10000,    LENGTH = $FAR_ROM_SIZE"
+
+FARTEXT_SECTION_MSP430="/* Extended address space, accessed with extended instructions.  */
+  .fartext :
+  {
+    ${RELOCATING+. = ALIGN(2);}
+    *(.fartext)
+    ${RELOCATING+. = ALIGN(2);}
+    *(.fartext.*)
+
+    _efartext = .;
+  } ${RELOCATING+ > fartext}"
+else
+TEXT_REGION_MSP430="text   (rx)       : ORIGIN = $ROM_START,     LENGTH = $ROM_SIZE"
+FARTEXT_SECTION_MSP430=""
+fi
 
 cat <<EOF
 OUTPUT_FORMAT("${OUTPUT_FORMAT}","${OUTPUT_FORMAT}","${OUTPUT_FORMAT}")
@@ -24,12 +47,12 @@
 
 MEMORY
 {
-  text   (rx)   	: ORIGIN = $ROM_START,  LENGTH = $ROM_SIZE
-  data   (rwx)  	: ORIGIN = $RAM_START, 	LENGTH = $RAM_SIZE
-  vectors (rw)  	: ORIGIN = 0xffe0,      LENGTH = 0x20
-  bootloader(rx)	: ORIGIN = 0x0c00,	LENGTH = 1K
-  infomem(rx)		: ORIGIN = 0x1000,	LENGTH = 256
-  infomemnobits(rx)	: ORIGIN = 0x1000,      LENGTH = 256
+  ${TEXT_REGION_MSP430}
+  data   (rwx)      : ORIGIN = $RAM_START,     LENGTH = $RAM_SIZE
+  vectors (rw)      : ORIGIN = $VECTORS_START,     LENGTH = $VECTORS_SIZE
+  bootloader(rx)    : ORIGIN = 0x0c00,     LENGTH = 1K
+  infomem(rx)       : ORIGIN = 0x1000,     LENGTH = 256
+  infomemnobits(rx) : ORIGIN = 0x1000,     LENGTH = 256
   ${HEAP_MEMORY_MSP430}
 }
 
@@ -100,22 +123,35 @@
   {
     ${RELOCATING+. = ALIGN(2);}
     *(.init)
-    *(.init0)  /* Start here after reset.  */
-    *(.init1)
-    *(.init2)  /* Copy data loop  */
-    *(.init3)
-    *(.init4)  /* Clear bss  */
-    *(.init5)
-    *(.init6)  /* C++ constructors.  */
-    *(.init7)
-    *(.init8)
-    *(.init9)  /* Call main().  */
+    KEEP(*(.init))
+    *(.init0)  /* Start here after reset.               */
+    KEEP(*(.init0))
+    *(.init1)  /* User definable.                       */
+    KEEP(*(.init1))
+    *(.init2)  /* Initialize stack.                     */
+    KEEP(*(.init2))
+    *(.init3)  /* Initialize hardware, user definable.  */
+    KEEP(*(.init3))
+    *(.init4)  /* Copy data to .data, clear bss.        */
+    KEEP(*(.init4))
+    *(.init5)  /* User definable.                       */
+    KEEP(*(.init5))
+    *(.init6)  /* C++ constructors.                     */
+    KEEP(*(.init6))
+    *(.init7)  /* User definable.                       */
+    KEEP(*(.init7))
+    *(.init8)  /* User definable.                       */
+    KEEP(*(.init8))
+    *(.init9)  /* Call main().                          */
+    KEEP(*(.init9))
 
     ${CONSTRUCTING+ __ctors_start = . ; }
     ${CONSTRUCTING+ *(.ctors) }
+    ${CONSTRUCTING+ KEEP(*(.ctors)) }
     ${CONSTRUCTING+ __ctors_end = . ; }
     ${CONSTRUCTING+ __dtors_start = . ; }
     ${CONSTRUCTING+ *(.dtors) }
+    ${CONSTRUCTING+ KEEP(*(.dtors)) }
     ${CONSTRUCTING+ __dtors_end = . ; }
 
     ${RELOCATING+. = ALIGN(2);}
@@ -124,31 +160,45 @@
     *(.text.*)
 
     ${RELOCATING+. = ALIGN(2);}
-    *(.fini9)  /*   */
-    *(.fini8)
-    *(.fini7)
-    *(.fini6)  /* C++ destructors.  */
-    *(.fini5)
-    *(.fini4)
-    *(.fini3)
-    *(.fini2)
-    *(.fini1)
+    *(.fini9)  /* Jumps here after main(). User definable.  */
+    KEEP(*(.fini9))
+    *(.fini8)  /* User definable.                           */
+    KEEP(*(.fini8))
+    *(.fini7)  /* User definable.                           */
+    KEEP(*(.fini7))
+    *(.fini6)  /* C++ destructors.                          */
+    KEEP(*(.fini6))
+    *(.fini5)  /* User definable.                           */
+    KEEP(*(.fini5))
+    *(.fini4)  /* User definable.                           */
+    KEEP(*(.fini4))
+    *(.fini3)  /* User definable.                           */
+    KEEP(*(.fini3))
+    *(.fini2)  /* User definable.                           */
+    KEEP(*(.fini2))
+    *(.fini1)  /* User definable.                           */
+    KEEP(*(.fini1))
     *(.fini0)  /* Infinite loop after program termination.  */
+    KEEP(*(.fini0))
     *(.fini)
+    KEEP(*(.fini))
 
     _etext = .;
   } ${RELOCATING+ > text}
 
-  .data ${RELOCATING-0} : ${RELOCATING+AT (ADDR (.text) + SIZEOF (.text))}
+  .data ${RELOCATING-0} :
   {  
     ${RELOCATING+ PROVIDE (__data_start = .) ; }
     ${RELOCATING+. = ALIGN(2);}
     *(.data)
+    *(SORT_BY_ALIGNMENT(.data.*))
     ${RELOCATING+. = ALIGN(2);}
     *(.gnu.linkonce.d*)
     ${RELOCATING+. = ALIGN(2);}
     ${RELOCATING+ _edata = . ; }
-  } ${RELOCATING+ > data}
+  } ${RELOCATING+ > data AT > text}
+   ${RELOCATING+ PROVIDE (__data_load_start = LOADADDR(.data) ); }
+   ${RELOCATING+ PROVIDE (__data_size = SIZEOF(.data) ); }
   
   /* Bootloader.  */
   .bootloader ${RELOCATING-0} :
@@ -175,19 +225,22 @@
     *(.infomemnobits.*)
   } ${RELOCATING+ > infomemnobits}
 
-  .bss ${RELOCATING+ SIZEOF(.data) + ADDR(.data)} :
+  .bss ${RELOCATING-0} :
   {
     ${RELOCATING+ PROVIDE (__bss_start = .) ; }
     *(.bss)
+    *(SORT_BY_ALIGNMENT(.bss.*))
     *(COMMON)
     ${RELOCATING+ PROVIDE (__bss_end = .) ; }
     ${RELOCATING+ _end = . ;  }
   } ${RELOCATING+ > data}
+   ${RELOCATING+ PROVIDE (__bss_size = SIZEOF(.bss) ); }
 
-  .noinit ${RELOCATING+ SIZEOF(.bss) + ADDR(.bss)} :
+  .noinit ${RELOCATING-0} :
   {
     ${RELOCATING+ PROVIDE (__noinit_start = .) ; }
     *(.noinit)
+    *(.noinit.*)
     *(COMMON)
     ${RELOCATING+ PROVIDE (__noinit_end = .) ; }
     ${RELOCATING+ _end = . ;  }
@@ -197,9 +250,11 @@
   {
     ${RELOCATING+ PROVIDE (__vectors_start = .) ; }
     *(.vectors*)
+    KEEP(*(.vectors*))
     ${RELOCATING+ _vectors_end = . ; }
   } ${RELOCATING+ > vectors}
 
+  ${FARTEXT_SECTION_MSP430}
   ${HEAP_SECTION_MSP430}
 
   /* Stabs for profiling information*/
@@ -239,6 +294,10 @@
   .debug_loc      0 : { *(.debug_loc) }
   .debug_macinfo  0 : { *(.debug_macinfo) }
 
+  /* DWARF 3 */
+  .debug_pubtypes 0 : { *(.debug_pubtypes) }
+  .debug_ranges   0 : { *(.debug_ranges) }
+
   PROVIDE (__stack = ${STACK}) ;
   PROVIDE (__data_start_rom = _etext) ;
   PROVIDE (__data_end_rom   = _etext + SIZEOF (.data)) ;
diff -urN binutils-2.20.1/ld/scripttempl/elf32msp430_3.sc binutils-2.20.1-mspgcc4/ld/scripttempl/elf32msp430_3.sc
--- binutils-2.20.1/ld/scripttempl/elf32msp430_3.sc	2009-10-09 08:12:35.000000000 -0500
+++ binutils-2.20.1-mspgcc4/ld/scripttempl/elf32msp430_3.sc	2010-04-30 19:31:50.000000000 -0500
@@ -4,9 +4,9 @@
 
 MEMORY
 {
-  text   (rx)   : ORIGIN = $ROM_START,  LENGTH = $ROM_SIZE
-  data   (rwx)  : ORIGIN = $RAM_START, 	LENGTH = $RAM_SIZE
-  vectors (rw)  : ORIGIN = 0xffe0,      LENGTH = 0x20
+  text   (rx)   : ORIGIN = $ROM_START,    LENGTH = $ROM_SIZE
+  data   (rwx)  : ORIGIN = $RAM_START, 	  LENGTH = $RAM_SIZE
+  vectors (rw)  : ORIGIN = $VECTORS_START,    LENGTH = $VECTORS_SIZE
 }
 
 SECTIONS
@@ -76,22 +76,35 @@
   {
     ${RELOCATING+. = ALIGN(2);}
     *(.init)
-    *(.init0)  /* Start here after reset.  */
-    *(.init1)
-    *(.init2)
-    *(.init3)
-    *(.init4)
-    *(.init5)
-    *(.init6)  /* C++ constructors.  */
-    *(.init7)
-    *(.init8)
-    *(.init9)  /* Call main().  */
+    KEEP(*(.init))
+    *(.init0)  /* Start here after reset.               */
+    KEEP(*(.init0))
+    *(.init1)  /* User definable.                       */
+    KEEP(*(.init1))
+    *(.init2)  /* Initialize stack.                     */
+    KEEP(*(.init2))
+    *(.init3)  /* Initialize hardware, user definable.  */
+    KEEP(*(.init3))
+    *(.init4)  /* Copy data to .data, clear bss.        */
+    KEEP(*(.init4))
+    *(.init5)  /* User definable.                       */
+    KEEP(*(.init5))
+    *(.init6)  /* C++ constructors.                     */
+    KEEP(*(.init6))
+    *(.init7)  /* User definable.                       */
+    KEEP(*(.init7))
+    *(.init8)  /* User definable.                       */
+    KEEP(*(.init8))
+    *(.init9)  /* Call main().                          */
+    KEEP(*(.init9))
 
     ${CONSTRUCTING+ __ctors_start = . ; }
     ${CONSTRUCTING+ *(.ctors) }
+    ${CONSTRUCTING+ KEEP(*(.ctors)) }
     ${CONSTRUCTING+ __ctors_end = . ; }
     ${CONSTRUCTING+ __dtors_start = . ; }
     ${CONSTRUCTING+ *(.dtors) }
+    ${CONSTRUCTING+ KEEP(*(.dtors)) }
     ${CONSTRUCTING+ __dtors_end = . ; }
 
     ${RELOCATING+. = ALIGN(2);}
@@ -100,43 +113,60 @@
     *(.text.*)
 
     ${RELOCATING+. = ALIGN(2);}
-    *(.fini9)
-    *(.fini8)
-    *(.fini7)
-    *(.fini6)  /* C++ destructors.  */
-    *(.fini5)
-    *(.fini4)
-    *(.fini3)
-    *(.fini2)
-    *(.fini1)
+    *(.fini9)  /* Jumps here after main(). User definable.  */
+    KEEP(*(.fini9))
+    *(.fini8)  /* User definable.                           */
+    KEEP(*(.fini8))
+    *(.fini7)  /* User definable.                           */
+    KEEP(*(.fini7))
+    *(.fini6)  /* C++ destructors.                          */
+    KEEP(*(.fini6))
+    *(.fini5)  /* User definable.                           */
+    KEEP(*(.fini5))
+    *(.fini4)  /* User definable.                           */
+    KEEP(*(.fini4))
+    *(.fini3)  /* User definable.                           */
+    KEEP(*(.fini3))
+    *(.fini2)  /* User definable.                           */
+    KEEP(*(.fini2))
+    *(.fini1)  /* User definable.                           */
+    KEEP(*(.fini1))
     *(.fini0)  /* Infinite loop after program termination.  */
+    KEEP(*(.fini0))
     *(.fini)
+    KEEP(*(.fini))
 
     ${RELOCATING+ _etext = . ; }
   } ${RELOCATING+ > text}
 
-  .data ${RELOCATING-0} : ${RELOCATING+AT (ADDR (.text) + SIZEOF (.text))}
+  .data ${RELOCATING-0} :
   {  
     ${RELOCATING+ PROVIDE (__data_start = .) ; }
     *(.data)
+    *(SORT_BY_ALIGNMENT(.data.*))
     *(.gnu.linkonce.d*)
     ${RELOCATING+. = ALIGN(2);}
     ${RELOCATING+ _edata = . ; }
-  } ${RELOCATING+ > data}
+  } ${RELOCATING+ > data AT > text}
+   ${RELOCATING+ PROVIDE (__data_load_start = LOADADDR(.data) ); }
+   ${RELOCATING+ PROVIDE (__data_size = SIZEOF(.data) ); }
   
-  .bss ${RELOCATING+ SIZEOF(.data) + ADDR(.data)} :
+  .bss ${RELOCATING-0} :
   {
     ${RELOCATING+ PROVIDE (__bss_start = .) ; }
     *(.bss)
+    *(SORT_BY_ALIGNMENT(.bss.*))
     *(COMMON)
     ${RELOCATING+ PROVIDE (__bss_end = .) ; }
     ${RELOCATING+ _end = . ;  }
   } ${RELOCATING+ > data}
+   ${RELOCATING+ PROVIDE (__bss_size = SIZEOF(.bss) ); }
 
-  .noinit ${RELOCATING+ SIZEOF(.bss) + ADDR(.bss)} :
+  .noinit ${RELOCATING-0} :
   {
     ${RELOCATING+ PROVIDE (__noinit_start = .) ; }
     *(.noinit)
+    *(SORT_BY_ALIGNMENT(.noinit.*))
     *(COMMON)
     ${RELOCATING+ PROVIDE (__noinit_end = .) ; }
     ${RELOCATING+ _end = . ;  }
@@ -146,6 +176,7 @@
   {
     ${RELOCATING+ PROVIDE (__vectors_start = .) ; }
     *(.vectors*)
+    KEEP(*(.vectors*))
     ${RELOCATING+ _vectors_end = . ; }
   } ${RELOCATING+ > vectors}
 
diff -urN binutils-2.20.1/opcodes/msp430-dis.c binutils-2.20.1-mspgcc4/opcodes/msp430-dis.c
--- binutils-2.20.1/opcodes/msp430-dis.c	2009-09-02 02:20:30.000000000 -0500
+++ binutils-2.20.1-mspgcc4/opcodes/msp430-dis.c	2010-04-30 19:31:50.000000000 -0500
@@ -51,12 +51,153 @@
   return bfd_getl16 (buffer);
 }
 
+static unsigned short
+msp430dis_operand (bfd_vma addr, disassemble_info *info, int reg, int am, int *cmd_len)
+{
+  static int const op_length [][5] = 
+  {
+  // am  | reg  0  1  2  3  >3
+  /*  0  */  {  0, 0, 0, 0, 0 },    // Rn
+  /*  1  */  {  2, 2, 2, 0, 2 },    // x(Rn)
+  /*  2  */  {  0, 0, 0, 0, 0 },    // @Rn
+  /*  3  */  {  2, 0, 0, 0, 0 },    // @Rn+
+  };
+  if (reg >= (int)(sizeof(op_length[0]) / sizeof(op_length[0][0])))
+    reg = sizeof(op_length[0]) / sizeof(op_length[0][0])- 1;
+    
+  if (op_length[am][reg])
+    {
+      bfd_byte buffer[2];
+      int status = info->read_memory_func (addr, buffer, 2, info);
+      if (status != 0)
+      {
+        info->memory_error_func (status, addr, info);
+        return -1;
+      }
+      *cmd_len += 2;
+      return bfd_getl16 (buffer);
+    }
+  return 0;
+}
+
+typedef enum
+{
+  OP_20BIT,
+  OP_16BIT,
+  OP_20BIT_HEX,
+  OP_16BIT_HEX,
+  OP_DECIMAL,
+} operand_t;
+
+static void 
+msp430x_decode_operand(int reg, int am, int addr, int dst, operand_t size, char *op, char *comm)
+{
+  if (op)       // if operand not hidden in emulated instruction
+    switch (am)
+      {
+      case 0:                   // Rn
+        if (reg == 3)
+          {
+            sprintf (op, "#0"); // constant #0
+            sprintf (comm, "r3 As==00");
+          }
+        else
+          {
+            sprintf (op, "r%d", reg);
+          }
+        break;
+      case 1:                   // x(Rn)
+        if (reg == 0)           // Symbolic, ADDR
+          {
+            if (size == OP_20BIT || size == OP_20BIT_HEX)
+              sprintf (op, "0x%05x", dst & 0xfffff);
+            else
+              sprintf (op, "0x%04x", dst & 0xffff);
+            sprintf (comm, "PC rel. 0x%05x", ((int)addr + dst) & 0xfffff);
+          }
+        else if (reg == 2)      // Absolute, &ADDR
+          {
+            if (size == OP_20BIT || size == OP_20BIT_HEX)
+              sprintf (op, "&0x%05x", dst & 0xfffff);
+            else
+              sprintf (op, "&0x%04x", dst & 0xffff);
+          }
+        else if (reg == 3)      // constant #1
+          {
+            sprintf (op, "#1");
+            sprintf (comm, "r3 As==01");
+          }
+        else                    // Indexed, x(Rn)
+          {
+            sprintf (op, "%d(r%d)", dst, reg);
+            if (size == OP_20BIT || size == OP_20BIT_HEX)
+              sprintf (comm, "0x%05x(r%d)", dst & 0xfffff, reg);
+            else
+              sprintf (comm, "0x%04x(r%d)", dst & 0xffff, reg);
+          }
+        break;
+      case 2:                   // @Rn
+        if (reg == 2)           // constant #4
+          {
+            sprintf (op, "#4");
+            sprintf (comm, "r2 As==10");
+          }
+        else if(reg == 3)       // constant #2
+          {
+            sprintf (op, "#2");
+            sprintf (comm, "r3 As==10");
+          }
+        else
+          {
+            sprintf (op, "@r%d", reg);
+          }
+        break;
+      case 3:                   // @Rn+
+        switch  (reg)
+          {
+          case 0:               // immediate, #N
+            switch (size)
+              {
+              case OP_16BIT:
+                sprintf (op, "#%d", dst);
+                sprintf (comm, "#0x%04x", dst & 0xffff);
+                break;
+              case OP_16BIT_HEX:
+                sprintf (op, "#0x%04x", dst & 0xffff);
+                break;
+              case OP_20BIT:
+                sprintf (op, "#%d", dst);
+                sprintf (comm, "#0x%05x", dst & 0xfffff);
+                break;
+              case OP_20BIT_HEX:
+                sprintf (op, "#0x%05x", dst & 0xfffff);
+                break;
+              default:          // #n in rxxm
+                sprintf (op, "#%d", dst);
+                break;
+              }
+            break;
+          case 2:               // constant #8
+            sprintf (op, "#8");
+            sprintf (comm, "r2 As==11");
+            break;  
+          case 3:               // constant #-1
+            sprintf (op, "#-1");
+	    sprintf (comm, "r3 As==11");
+            break;
+          default:
+            sprintf (op, "@r%d+", reg);
+            break;
+          }
+        break;
+      }
+}
+
 static int
-msp430_nooperands (struct msp430_opcode_s *opcode,
+msp430_nooperands (struct msp430_opcode_s const *opcode,
 		   bfd_vma addr ATTRIBUTE_UNUSED,
 		   unsigned short insn ATTRIBUTE_UNUSED,
-		   char *comm,
-		   int *cycles)
+		   char *comm)
 {
   /* Pop with constant.  */
   if (insn == 0x43b2)
@@ -64,18 +205,16 @@
   if (insn == opcode->bin_opcode)
     return 2;
 
-  if (opcode->fmt == 0)
+  if (opcode_format(opcode) == FMT_EMULATED)
     {
       if ((insn & 0x0f00) != 3 || (insn & 0x0f00) != 2)
 	return 0;
 
       strcpy (comm, "emulated...");
-      *cycles = 1;
     }
   else
     {
       strcpy (comm, "return from interupt");
-      *cycles = 5;
     }
 
   return 2;
@@ -83,16 +222,14 @@
 
 static int
 msp430_singleoperand (disassemble_info *info,
-		      struct msp430_opcode_s *opcode,
+		      struct msp430_opcode_s const *opcode,
 		      bfd_vma addr,
 		      unsigned short insn,
 		      char *op,
-		      char *comm,
-		      int *cycles)
+		      char *comm)
 {
   int regs = 0, regd = 0;
   int ad = 0, as = 0;
-  int where = 0;
   int cmd_len = 2;
   short dst = 0;
 
@@ -101,9 +238,9 @@
   as = (insn & 0x0030) >> 4;
   ad = (insn & 0x0080) >> 7;
 
-  switch (opcode->fmt)
+  switch (opcode_format(opcode))
     {
-    case 0:			/* Emulated work with dst register.  */
+    case FMT_EMULATED:		/* Emulated work with dst register.  */
       if (regs != 2 && regs != 3 && regs != 1)
 	return 0;
 
@@ -115,167 +252,23 @@
       if ((opcode->bin_opcode & 0xff00) == 0x5300 && as == 3)
 	return 0;
 
-      if (ad == 0)
-	{
-	  *cycles = 1;
-
-	  /* Register.  */
-	  if (regd == 0)
-	    {
-	      *cycles += 1;
-	      sprintf (op, "r0");
-	    }
-	  else if (regd == 1)
-	    sprintf (op, "r1");
-
-	  else if (regd == 2)
-	    sprintf (op, "r2");
-
-	  else
-	    sprintf (op, "r%d", regd);
-	}
-      else	/* ad == 1 msp430dis_opcode.  */
-	{
-	  if (regd == 0)
-	    {
-	      /* PC relative.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      *cycles = 4;
-	      sprintf (op, "0x%04x", dst);
-	      sprintf (comm, "PC rel. abs addr 0x%04x",
-		       PS ((short) (addr + 2) + dst));
-	    }
-	  else if (regd == 2)
-	    {
-	      /* Absolute.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      *cycles = 4;
-	      sprintf (op, "&0x%04x", PS (dst));
-	    }
-	  else
-	    {
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      *cycles = 4;
-	      sprintf (op, "%d(r%d)", dst, regd);
-	    }
-	}
+      dst = msp430dis_operand (addr + cmd_len, info, regd, ad, &cmd_len);
+      msp430x_decode_operand (regd, ad, addr + cmd_len, dst, OP_16BIT, op, comm);
       break;
 
-    case 2:	/* rrc, push, call, swpb, rra, sxt, push, call, reti etc...  */
-      if (as == 0)
-	{
-	  if (regd == 3)
-	    {
-	      /* Constsnts.  */
-	      sprintf (op, "#0");
-	      sprintf (comm, "r3 As==00");
-	    }
-	  else
-	    {
-	      /* Register.  */
-	      sprintf (op, "r%d", regd);
-	    }
-	  *cycles = 1;
-	}
-      else if (as == 2)
-	{
-	  *cycles = 1;
-	  if (regd == 2)
-	    {
-	      sprintf (op, "#4");
-	      sprintf (comm, "r2 As==10");
-	    }
-	  else if (regd == 3)
-	    {
-	      sprintf (op, "#2");
-	      sprintf (comm, "r3 As==10");
-	    }
-	  else
-	    {
-	      *cycles = 3;
-	      /* Indexed register mode @Rn.  */
-	      sprintf (op, "@r%d", regd);
-	    }
-	}
-      else if (as == 3)
-	{
-	  *cycles = 1;
-	  if (regd == 2)
-	    {
-	      sprintf (op, "#8");
-	      sprintf (comm, "r2 As==11");
-	    }
-	  else if (regd == 3)
-	    {
-	      sprintf (op, "#-1");
-	      sprintf (comm, "r3 As==11");
-	    }
-	  else if (regd == 0)
-	    {
-	      *cycles = 3;
-	      /* absolute. @pc+ */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      sprintf (op, "#%d", dst);
-	      sprintf (comm, "#0x%04x", PS (dst));
-	    }
-	  else
-	    {
-	      *cycles = 3;
-	      sprintf (op, "@r%d+", regd);
-	    }
-	}
-      else if (as == 1)
-	{
-	  *cycles = 4;
-	  if (regd == 0)
-	    {
-	      /* PC relative.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      sprintf (op, "0x%04x", PS (dst));
-	      sprintf (comm, "PC rel. 0x%04x",
-		       PS ((short) addr + 2 + dst));
-	    }
-	  else if (regd == 2)
-	    {
-	      /* Absolute.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      sprintf (op, "&0x%04x", PS (dst));
-	    }
-	  else if (regd == 3)
-	    {
-	      *cycles = 1;
-	      sprintf (op, "#1");
-	      sprintf (comm, "r3 As==01");
-	    }
-	  else
-	    {
-	      /* Indexd.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 2;
-	      sprintf (op, "%d(r%d)", dst, regd);
-	    }
-	}
+    case FMT_SINGLE_OPERAND:	/* rrc, push, call, swpb, rra, sxt, push, call, reti etc...  */
+      dst = msp430dis_operand (addr + cmd_len, info, regd, as, &cmd_len);
+      if(opcode_variant(opcode) != V_CALL)
+        msp430x_decode_operand (regd, as, addr + cmd_len, dst, OP_16BIT, op, comm);
+      else
+        msp430x_decode_operand (regd, as, addr + cmd_len, dst, OP_16BIT_HEX, op, comm);
       break;
 
-    case 3:			/* Jumps.  */
-      where = insn & 0x03ff;
-      if (where & 0x200)
-	where |= ~0x03ff;
-      if (where > 512 || where < -511)
-	return 0;
-
-      where *= 2;
-      sprintf (op, "$%+-8d", where + 2);
-      sprintf (comm, "abs 0x%x", PS ((short) (addr) + 2 + where));
-      *cycles = 2;
+    case FMT_JUMP:		/* Jumps.  */
+      dst = (short)((insn & 0x03ff) << 6) >> 5;        // sign extension, word addr to byte addr conversion
+      sprintf (op, "$%+-8d", dst + 2);
+      sprintf (comm, "abs 0x%x", PS ((short) (addr) + 2 + dst));
       return 2;
-      break;
     default:
       cmd_len = 0;
     }
@@ -285,26 +278,26 @@
 
 static int
 msp430_doubleoperand (disassemble_info *info,
-		      struct msp430_opcode_s *opcode,
+		      struct msp430_opcode_s const *opcode,
 		      bfd_vma addr,
 		      unsigned short insn,
 		      char *op1,
 		      char *op2,
 		      char *comm1,
-		      char *comm2,
-		      int *cycles)
+		      char *comm2)
 {
   int regs = 0, regd = 0;
   int ad = 0, as = 0;
   int cmd_len = 2;
-  short dst = 0;
+  short ops;
+  short opd;
 
   regd = insn & 0x0f;
   regs = (insn & 0x0f00) >> 8;
   as = (insn & 0x0030) >> 4;
   ad = (insn & 0x0080) >> 7;
 
-  if (opcode->fmt == 0)
+  if (opcode_format(opcode) == FMT_EMULATED)
     {
       /* Special case: rla and rlc are the only 2 emulated instructions that
 	 fall into two operand instructions.  */
@@ -319,348 +312,352 @@
       if (regd != regs || as != ad)
 	return 0;		/* May be 'data' section.  */
 
-      if (ad == 0)
+      if (ad == 0 && regd == 3) // #N
 	{
-	  /* Register mode.  */
-	  if (regd == 3)
-	    {
-	      strcpy (comm1, _("Illegal as emulation instr"));
-	      return -1;
-	    }
-
-	  sprintf (op1, "r%d", regd);
-	  *cycles = 1;
-	}
-      else			/* ad == 1 */
-	{
-	  if (regd == 0)
-	    {
-	      /* PC relative, Symbolic.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 4;
-	      *cycles = 6;
-	      sprintf (op1, "0x%04x", PS (dst));
-	      sprintf (comm1, "PC rel. 0x%04x",
-		       PS ((short) addr + 2 + dst));
-
-	    }
-	  else if (regd == 2)
-	    {
-	      /* Absolute.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      /* If the 'src' field is not the same as the dst
-		 then this is not an rla instruction.  */
-	      if (dst != msp430dis_opcode (addr + 4, info))
-		return 0;
-	      cmd_len += 4;
-	      *cycles = 6;
-	      sprintf (op1, "&0x%04x", PS (dst));
-	    }
-	  else
-	    {
-	      /* Indexed.  */
-	      dst = msp430dis_opcode (addr + 2, info);
-	      cmd_len += 4;
-	      *cycles = 6;
-	      sprintf (op1, "%d(r%d)", dst, regd);
-	    }
+	  strcpy (comm1, _("Illegal as emulation instr"));
+	  return -1;
 	}
+      ops = msp430dis_operand (addr + cmd_len, info, regs, as, &cmd_len);
+      opd = msp430dis_operand (addr + cmd_len, info, regd, ad, &cmd_len);
+      /* If the 'src' field is not the same as the dst
+         then this is not an rla instruction.  */
+      if (ops != opd)  
+        return 0;
+      msp430x_decode_operand (regs, as, addr + cmd_len, ops, OP_16BIT, op1, comm1);
 
       *op2 = 0;
       *comm2 = 0;
       return cmd_len;
     }
-
   /* Two operands exactly.  */
+
   if (ad == 0 && regd == 3)
     {
       /* R2/R3 are illegal as dest: may be data section.  */
       strcpy (comm1, _("Illegal as 2-op instr"));
       return -1;
     }
+  ops = msp430dis_operand (addr + cmd_len, info, regs, as, &cmd_len);
+  msp430x_decode_operand (regs, as, addr + cmd_len, ops, OP_16BIT, op1, comm1);
 
-  /* Source.  */
-  if (as == 0)
-    {
-      *cycles = 1;
-      if (regs == 3)
-	{
-	  /* Constsnts.  */
-	  sprintf (op1, "#0");
-	  sprintf (comm1, "r3 As==00");
-	}
-      else
-	{
-	  /* Register.  */
-	  sprintf (op1, "r%d", regs);
-	}
-    }
-  else if (as == 2)
-    {
-      *cycles = 1;
+  opd = msp430dis_operand (addr + cmd_len, info, regd, ad, &cmd_len);
+  msp430x_decode_operand (regd, ad, addr + cmd_len, opd, OP_16BIT, op2, comm2);
+  return cmd_len;
+}
 
-      if (regs == 2)
-	{
-	  sprintf (op1, "#4");
-	  sprintf (comm1, "r2 As==10");
-	}
-      else if (regs == 3)
-	{
-	  sprintf (op1, "#2");
-	  sprintf (comm1, "r3 As==10");
-	}
-      else
-	{
-	  *cycles = 2;
+static int
+msp430_branchinstr (disassemble_info *info,
+		    struct msp430_opcode_s const *opcode ATTRIBUTE_UNUSED,
+		    bfd_vma addr ATTRIBUTE_UNUSED,
+		    unsigned short insn,
+		    char *op1,
+		    char *comm1)
+{
+  int regs = (insn & 0x0f00) >> 8;
+  int as = (insn & 0x0030) >> 4;
+  int cmd_len = 2;
+  short dst;
 
-	  /* Indexed register mode @Rn.  */
-	  sprintf (op1, "@r%d", regs);
-	}
-      if (!regs)
-	*cycles = 3;
-    }
-  else if (as == 3)
-    {
-      if (regs == 2)
-	{
-	  sprintf (op1, "#8");
-	  sprintf (comm1, "r2 As==11");
-	  *cycles = 1;
-	}
-      else if (regs == 3)
-	{
-	  sprintf (op1, "#-1");
-	  sprintf (comm1, "r3 As==11");
-	  *cycles = 1;
-	}
-      else if (regs == 0)
-	{
-	  *cycles = 3;
-	  /* Absolute. @pc+.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "#%d", dst);
-	  sprintf (comm1, "#0x%04x", PS (dst));
-	}
-      else
-	{
-	  *cycles = 2;
-	  sprintf (op1, "@r%d+", regs);
-	}
-    }
-  else if (as == 1)
-    {
-      if (regs == 0)
-	{
-	  *cycles = 4;
-	  /* PC relative.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "0x%04x", PS (dst));
-	  sprintf (comm1, "PC rel. 0x%04x",
-		   PS ((short) addr + 2 + dst));
-	}
-      else if (regs == 2)
-	{
-	  *cycles = 2;
-	  /* Absolute.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "&0x%04x", PS (dst));
-	  sprintf (comm1, "0x%04x", PS (dst));
-	}
-      else if (regs == 3)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#1");
-	  sprintf (comm1, "r3 As==01");
-	}
-      else
-	{
-	  *cycles = 3;
-	  /* Indexed.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "%d(r%d)", dst, regs);
-	}
-    }
+  dst = msp430dis_operand (addr + cmd_len, info, regs, as, &cmd_len);
+  msp430x_decode_operand(regs, as, addr + cmd_len, dst, OP_16BIT_HEX, op1, comm1);
 
-  /* Destination. Special care needed on addr + XXXX.  */
+  return cmd_len;
+}
 
-  if (ad == 0)
-    {
-      /* Register.  */
-      if (regd == 0)
-	{
-	  *cycles += 1;
-	  sprintf (op2, "r0");
-	}
-      else if (regd == 1)
-	sprintf (op2, "r1");
+static opwidth_t
+msp430x_opwidth(unsigned int insn)
+{
+    insn &= NON_ADDR_OPERATION | BYTE_OPERATION_X;
+    
+    if(insn == (NON_ADDR_OPERATION | BYTE_OPERATION_X))
+      return BYTE_OP;
+    if(insn == NON_ADDR_OPERATION)
+      return WORD_OP;
+    if(insn == BYTE_OPERATION_X)
+      return ADDR_OP;
 
-      else if (regd == 2)
-	sprintf (op2, "r2");
+    return 0;   // reserved
+}
 
-      else
-	sprintf (op2, "r%d", regd);
+static int
+msp430x_singleoperand (disassemble_info *info,
+		      struct msp430_opcode_s const *opcode,
+		      bfd_vma addr,
+		      unsigned int insn,
+		      char *op,
+		      char *comm,
+                      int *repeats)
+{
+  int reg = (insn >> 16) & 0xf;
+  int am = (insn >> 20) & 0x3;
+  int cmd_len = 4;
+  int dst = 0;
+
+  if ( opcode_variant(opcode) < V_PUSHX )
+    if ((am == 3 && reg == 0)           // #N operand
+        || (am == 0 && reg == 3)        // R3 is illegal as dest: may be data section. 
+       )
+        {
+          strcpy (comm, _("Illegal as 1-op instr"));
+          return -1;
+        }
+ 
+  // extract repeat count if any
+  if ( am == 0 )                // extension word for register mode
+    {
+      if (insn & 0x008f)        // repetitions
+      {
+        if (insn & 0x0080)
+          *repeats = insn & 0xf;        // positive number is Rn
+        else
+          *repeats = 0 - (insn & 0xf);  // negative number is #N
+      }
+    }
+
+  // extract operands
+  dst = msp430dis_operand(addr + cmd_len, info, reg, am, &cmd_len) | ((insn & 0x0000000f) << 16);
+  dst = (dst << 12) >> 12;      // sign extension
+  msp430x_decode_operand(reg, am, addr + cmd_len, dst, OP_20BIT, op, comm);
+
+  return cmd_len; 
+}
+
+static int
+msp430x_exception (disassemble_info *info,
+		      struct msp430_opcode_s const *opcode,
+		      bfd_vma addr,
+		      unsigned int insn,
+		      char *op1,
+		      char *op2,
+		      char *comm1,
+		      char *comm2,
+		      opwidth_t *op_width)
+{
+  int reg = 0;
+  int cmd_len = 2;
+  int n = 0;
+  int dst = 0;
+  
+  reg = insn & 0xf;
+
+  switch(opcode_variant(opcode))
+    {
+    case V_CALLA:
+      switch((insn >> 4) & 0xf)
+        {
+        case 4:     // Rdst
+          msp430x_decode_operand(reg, 0, 0, 0, 0, op1, comm1);
+          break;
+        case 5:     // x(Rdst)
+          dst = (short)msp430dis_operand(addr + cmd_len, info, reg, 1, &cmd_len);
+          msp430x_decode_operand(reg, 1, addr + cmd_len, dst, OP_16BIT, op1, comm1);
+          break;
+        case 6:     // @Rdst
+          msp430x_decode_operand(reg, 2, 0, 0, 0, op1, comm1);
+          break;
+        case 7:     // @Rdst+
+          msp430x_decode_operand(reg, 3, 0, 0, 0, op1, comm1);
+          break;
+        case 8:     // &abs20
+          dst = msp430dis_operand(addr + cmd_len, info, 2, 1, &cmd_len) | ((insn & 0x000f) << 16);
+          msp430x_decode_operand(2, 1, addr + cmd_len, dst, OP_20BIT_HEX, op1, comm1);
+          break;
+        case 9:     // EDE
+          dst = msp430dis_operand(addr + cmd_len, info, 0, 1, &cmd_len) | ((insn & 0x000f) << 16);
+          msp430x_decode_operand(0, 1, addr + cmd_len, dst, OP_20BIT, op1, comm1);
+          break;
+        case 0xb:   // #imm20
+          dst = msp430dis_operand(addr + cmd_len, info, 0, 3, &cmd_len) | ((insn & 0x000f) << 16);
+          msp430x_decode_operand(0, 3, addr + cmd_len, dst, OP_20BIT_HEX, op1, comm1);
+          break;
+        }
+      break;
+    case V_PUSHM:
+      n = ((insn >> 4) & 0xf) + 1;
+      msp430x_decode_operand(0, 3, 0, n, OP_DECIMAL, op1, comm1);   // #N
+      msp430x_decode_operand(reg, 0, 0, 0, 0, op2, comm2);          // Rdst
+      if ((insn & 0x0100) == 0)
+        *op_width = ADDR_OP;
+      break;
+    case V_POPM:
+      n = ((insn >> 4) & 0xf) + 1;
+      reg = (reg + n - 1) & 0xf;
+      msp430x_decode_operand(0, 3, 0, n, OP_DECIMAL, op1, comm1);   // #N
+      msp430x_decode_operand(reg, 0, 0, 0, 0, op2, comm2);          // Rdst
+      if ((insn & 0x0100) == 0)
+        *op_width = ADDR_OP;
+      break;
+    case V_ROTM:
+      n = ((insn >> 10) & 0x3) + 1;
+      msp430x_decode_operand(0, 3, 0, n, OP_DECIMAL, op1, comm1);   // #N
+      msp430x_decode_operand(reg, 0, 0, 0, 0, op2, comm2);          // Rdst
+      if ((insn & 0x0010) == 0)
+        *op_width = ADDR_OP;
+      break;
+    default:
+      break;
     }
-  else	/* ad == 1.  */
-    {
-      * cycles += 3;
+  return cmd_len; 
+}
 
-      if (regd == 0)
-	{
-	  /* PC relative.  */
-	  *cycles += 1;
-	  dst = msp430dis_opcode (addr + cmd_len, info);
-	  sprintf (op2, "0x%04x", PS (dst));
-	  sprintf (comm2, "PC rel. 0x%04x",
-		   PS ((short) addr + cmd_len + dst));
-	  cmd_len += 2;
-	}
-      else if (regd == 2)
-	{
-	  /* Absolute.  */
-	  dst = msp430dis_opcode (addr + cmd_len, info);
-	  cmd_len += 2;
-	  sprintf (op2, "&0x%04x", PS (dst));
-	}
-      else
-	{
-	  dst = msp430dis_opcode (addr + cmd_len, info);
-	  cmd_len += 2;
-	  sprintf (op2, "%d(r%d)", dst, regd);
-	}
+static int
+msp430x_doubleoperand (disassemble_info *info,
+		      struct msp430_opcode_s const *opcode,
+		      bfd_vma addr,
+		      unsigned int insn,
+		      char *op1,
+		      char *op2,
+		      char *comm1,
+		      char *comm2,
+		      opwidth_t *op_width,
+		      int *repeats)
+{
+  int regs, regd;
+  int as, ad;
+  int ops, opd;
+  int cmd_len = 4;
+
+  regd = (insn >> 16) & 0xf;
+  regs = (insn >> 24) & 0xf;
+  as = (insn >> 20) & 0x3;
+  ad = (insn >> 23) & 0x1;
+
+  if (ad == 0 && regd == 3)
+    {
+      // R3 is illegal as dest: may be data section.
+      if (comm1)
+        strcpy (comm1, _("Illegal as 2-op instr"));
+      else if (comm2)
+        strcpy (comm2, _("Illegal as 2-op instr"));
+      return -1;
     }
+  *op_width = msp430x_opwidth(insn);
+  
+  // extract repeat count if any
+  if ( as == 0 && ad == 0 )     // extension word for register mode
+    {
+      if (insn & 0x008f)        // repetitions
+      {
+        if (insn & 0x0080)
+          *repeats = insn & 0xf;        // positive number is Rn
+        else
+          *repeats = 0 - (insn & 0xf);  // negative number is #N
+      }
+    }
+  // extract operands
+  ops = msp430dis_operand(addr + cmd_len, info, regs, as, &cmd_len) | ((insn & 0x00000780) << 9);
+  ops = (ops << 12) >> 12;      // sign extension
+  msp430x_decode_operand(regs, as, addr + cmd_len, ops, OP_20BIT, op1, comm1);
+
+  opd = msp430dis_operand(addr + cmd_len, info, regd, ad, &cmd_len) | ((insn & 0x0000000f) << 16);
+  opd = (opd << 12) >> 12;      // sign extension
+  if (opcode_variant(opcode) == V_X_SHIFT && ops != opd)
+    return 0;   // different operand => not emulated shift
+
+  msp430x_decode_operand(regd, ad, addr + cmd_len, opd, OP_20BIT, op2, comm2);
 
   return cmd_len;
 }
 
 static int
-msp430_branchinstr (disassemble_info *info,
-		    struct msp430_opcode_s *opcode ATTRIBUTE_UNUSED,
-		    bfd_vma addr ATTRIBUTE_UNUSED,
+msp430x_address (disassemble_info *info,
+		    bfd_vma addr,
 		    unsigned short insn,
 		    char *op1,
+		    char *op2,
 		    char *comm1,
-		    int *cycles)
+		    char *comm2)
 {
-  int regs = 0, regd = 0;
-  int ad = 0, as = 0;
   int cmd_len = 2;
-  short dst = 0;
-
-  regd = insn & 0x0f;
-  regs = (insn & 0x0f00) >> 8;
-  as = (insn & 0x0030) >> 4;
-  ad = (insn & 0x0080) >> 7;
-
-  if (regd != 0)	/* Destination register is not a PC.  */
-    return 0;
-
-  /* dst is a source register.  */
-  if (as == 0)
-    {
-      /* Constants.  */
-      if (regs == 3)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#0");
-	  sprintf (comm1, "r3 As==00");
-	}
-      else
-	{
-	  /* Register.  */
-	  *cycles = 1;
-	  sprintf (op1, "r%d", regs);
-	}
-    }
-  else if (as == 2)
+  int dst = 0;
+  typedef struct 
     {
-      if (regs == 2)
-	{
-	  *cycles = 2;
-	  sprintf (op1, "#4");
-	  sprintf (comm1, "r2 As==10");
-	}
-      else if (regs == 3)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#2");
-	  sprintf (comm1, "r3 As==10");
-	}
-      else
-	{
-	  /* Indexed register mode @Rn.  */
-	  *cycles = 2;
-	  sprintf (op1, "@r%d", regs);
-	}
-    }
-  else if (as == 3)
-    {
-      if (regs == 2)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#8");
-	  sprintf (comm1, "r2 As==11");
-	}
-      else if (regs == 3)
-	{
-	  *cycles = 1;
-	  sprintf (op1, "#-1");
-	  sprintf (comm1, "r3 As==11");
-	}
-      else if (regs == 0)
-	{
-	  /* Absolute. @pc+  */
-	  *cycles = 3;
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "#0x%04x", PS (dst));
-	}
-      else
-	{
-	  *cycles = 2;
-	  sprintf (op1, "@r%d+", regs);
-	}
+      int as, regs;
+      int ad, regd;
+      int length;
+    }
+  operands_t;
+  
+  static operands_t const operands_table[] =
+    {
+      { 2, -1, 0, -1, 0 },  // 0 @Rsrc, Rdst
+      { 3, -1, 0, -1, 0 },  // 1 @Rsrc+, Rdst
+      { 1,  2, 0, -1, 2 },  // 2 &abs20, Rdst
+      { 1, -1, 0, -1, 2 },  // 3 x(Rsrc), Rdst
+      { 0,  0, 0,  0, 0 },  // 4
+      { 0,  0, 0,  0, 0 },  // 5
+      { 0, -1, 1,  2, 2 },  // 6 Rsrc, &abs20
+      { 0, -1, 1, -1, 2 },  // 7 Rsrc, x(Rdst)
+      { 3,  0, 0, -1, 2 },  // 8 #imm20, Rdst
+      { 3,  0, 0, -1, 2 },  // 9 #imm20, Rdst
+      { 3,  0, 0, -1, 2 },  // a #imm20, Rdst
+      { 3,  0, 0, -1, 2 },  // b #imm20, Rdst
+      { 0, -1, 0, -1, 0 },  // c Rsrc, Rdst
+      { 0, -1, 0, -1, 0 },  // d Rsrc, Rdst
+      { 0, -1, 0, -1, 0 },  // e Rsrc, Rdst
+      { 0, -1, 0, -1, 0 },  // f Rsrc, Rdst
+    };
+
+  operands_t operands = operands_table[(insn >> 4) & 0xf];
+  if(((insn >> 4) & 0xf) == 6)
+    dst = msp430dis_opcode (addr + cmd_len, info) | ((insn & 0x000f) << 16);
+  else if(((insn >> 4) & 0xb) == 3)
+    dst = (short)msp430dis_opcode (addr + cmd_len, info);
+  else if(operands.length != 0)
+    dst = msp430dis_opcode(addr + cmd_len, info) | ((insn & 0x0f00) << 8);
+
+  if(operands.regs == -1)
+    operands.regs = (insn >> 8 ) & 0x000f;
+  if(operands.regd == -1)
+    operands.regd = (insn >> 0 ) & 0x000f;
+
+  if (operands.regd == 3)
+    {
+      // R3 is illegal as dest: may be data section.
+      if (comm1)
+        strcpy (comm1, _("Illegal as address instr"));
+      else if (comm2)
+        strcpy (comm2, _("Illegal as address instr"));
+      return -1;
     }
-  else if (as == 1)
-    {
-      * cycles = 3;
+  // extract operands
+  msp430x_decode_operand(operands.regs, operands.as, addr + cmd_len, dst,
+                          ((insn >> 4) & 0xf) == 3 ? OP_16BIT_HEX : OP_20BIT_HEX, op1, comm1);
+  msp430x_decode_operand(operands.regd, operands.ad, addr + cmd_len, dst,
+                          ((insn >> 4) & 0xf) == 7 ? OP_16BIT_HEX : OP_20BIT_HEX, op2, comm2);
+  return cmd_len + operands.length;
+}
 
-      if (regs == 0)
-	{
-	  /* PC relative.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  (*cycles)++;
-	  sprintf (op1, "0x%04x", PS (dst));
-	  sprintf (comm1, "PC rel. 0x%04x",
-		   PS ((short) addr + 2 + dst));
-	}
-      else if (regs == 2)
-	{
-	  /* Absolute.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "&0x%04x", PS (dst));
-	}
-      else if (regs == 3)
-	{
-	  (*cycles)--;
-	  sprintf (op1, "#1");
-	  sprintf (comm1, "r3 As==01");
-	}
-      else
-	{
-	  /* Indexd.  */
-	  dst = msp430dis_opcode (addr + 2, info);
-	  cmd_len += 2;
-	  sprintf (op1, "%d(r%d)", dst, regs);
-	}
-    }
+static int
+msp430x_emulated (disassemble_info *info,
+		      struct msp430_opcode_s const *opcode,
+		      bfd_vma addr,
+		      unsigned int insn,
+		      char *op1,
+		      char *comm1,
+		      opwidth_t *op_width,
+		      int *repeats)
+{
 
-  return cmd_len;
+  switch(opcode_variant(opcode))
+    {
+    case V_NONE:
+    case V_X_SHIFT:
+      // emulated by double operand instruction
+      return msp430x_doubleoperand(info, opcode, addr, insn, (char *)0, op1,
+                                   (char *)0, comm1, op_width, repeats);
+    case V_RETA:        // reta, substituted by mova
+      return 2;
+    case V_EMU_ADDR:    // substituted by other address instruction
+      return msp430x_address(info, addr, insn, (char *)0, op1, 
+                             (char *)0, comm1);
+    case V_BRA:         // bra, substituted by mova
+      return msp430x_address(info, addr, insn, op1, (char *)0,
+                             comm1, (char *)0);
+    default:
+      break;
+    }
+  return 0;
 }
 
 int
@@ -668,85 +665,147 @@
 {
   void *stream = info->stream;
   fprintf_ftype prin = info->fprintf_func;
-  struct msp430_opcode_s *opcode;
+  struct msp430_opcode_s const *opcode;
   char op1[32], op2[32], comm1[64], comm2[64];
   int cmd_len = 0;
-  unsigned short insn;
-  int cycles = 0;
-  char *bc = "";
-  char dinfo[32];		/* Debug purposes.  */
-
+  unsigned int insn;
+  int repeats = 0;
+  core_t core = CORE_430;
+  
+  opwidth_t op_width = DEFAULT_OP;      // word instruction by default
+  static char const *width_modifier[] = 
+    {"", "", ".b", ".a" };
+    
   insn = msp430dis_opcode (addr, info);
-  sprintf (dinfo, "0x%04x", insn);
 
-  if (((int) addr & 0xffff) > 0xffdf)
+  if (info->mach == 241 || info->mach == 26 || info->mach == 46 || info->mach == 471)
+    {
+      core = CORE_430X;
+    }
+  else if (info->mach == 54)
+    {
+      core = CORE_430X2;
+    }
+    
+  if ( (core == CORE_430 && ((int) addr & 0xffff) >= 0xffe0)
+      || ( core == CORE_430X && (((int) addr & 0xfffff) >= 0xffc0) && ((int) addr & 0xfffff) < 0x10000)
+      || ( core == CORE_430X2 && (((int) addr & 0xfffff) >= 0xff80) && ((int) addr & 0xfffff) < 0x10000)
+     )
     {
       (*prin) (stream, "interrupt service routine at 0x%04x", 0xffff & insn);
       return 2;
     }
 
+  if (core > CORE_430 && ((insn & 0xf800) == 0x1800))    // Extended instruction
+     insn |= msp430dis_opcode(addr + 2, info) << 16;
+
   *comm1 = 0;
   *comm2 = 0;
 
   for (opcode = msp430_opcodes; opcode->name; opcode++)
     {
       if ((insn & opcode->bin_mask) == opcode->bin_opcode
-	  && opcode->bin_opcode != 0x9300)
+//	  && opcode->bin_opcode != 0x9300       // was disasm tst instruction as cmp #0, dst?
+         )
 	{
 	  *op1 = 0;
 	  *op2 = 0;
 	  *comm1 = 0;
 	  *comm2 = 0;
 
-	  /* r0 as destination. Ad should be zero.  */
-	  if (opcode->insn_opnumb == 3 && (insn & 0x000f) == 0
-	      && (0x0080 & insn) == 0)
+          /* unsupported instruction */
+          if(opcode_format(opcode) >= FMT_X && core < CORE_430X)
+            break;
+
+	  /* r0 as destination. Ad should be zero. Rdst=0 and Ad=0 are encoded in opcode & opcode_mask */
+	  if (opcode_format(opcode) == FMT_EMULATED && opcode_variant(opcode) == V_BR)
 	    {
 	      cmd_len =
-		msp430_branchinstr (info, opcode, addr, insn, op1, comm1,
-				    &cycles);
+		msp430_branchinstr (info, opcode, addr, insn, op1, comm1);
 	      if (cmd_len)
 		break;
 	    }
-
-	  switch (opcode->insn_opnumb)
-	    {
-	    case 0:
-	      cmd_len = msp430_nooperands (opcode, addr, insn, comm1, &cycles);
-	      break;
-	    case 2:
-	      cmd_len =
-		msp430_doubleoperand (info, opcode, addr, insn, op1, op2,
-				      comm1, comm2, &cycles);
-	      if (insn & BYTE_OPERATION)
-		bc = ".b";
-	      break;
-	    case 1:
-	      cmd_len =
-		msp430_singleoperand (info, opcode, addr, insn, op1, comm1,
-				      &cycles);
-	      if (insn & BYTE_OPERATION && opcode->fmt != 3)
-		bc = ".b";
-	      break;
-	    default:
-	      break;
-	    }
+          if(opcode_format(opcode) < FMT_X)
+  	    switch (opcode->insn_opnumb)
+	      {
+	      case 0:
+	        cmd_len = msp430_nooperands (opcode, addr, insn, comm1);
+	        break;
+	      case 2:
+	        cmd_len =
+		  msp430_doubleoperand (info, opcode, addr, insn, op1, op2,
+				        comm1, comm2);
+	        if (insn & BYTE_OPERATION)
+		  op_width = BYTE_OP;
+	        break;
+	      case 1:
+	        cmd_len =
+		  msp430_singleoperand (info, opcode, addr, insn, op1, comm1);
+	        if (insn & BYTE_OPERATION && opcode_format(opcode) != FMT_JUMP)
+		  op_width = BYTE_OP;
+	        break;
+	      default:
+	        break;
+	      }
+          else  // 430x instruction
+            switch(opcode_format(opcode))
+              {
+              case FMT_X_SINGLE_OPERAND:
+                if( opcode_variant(opcode) == V_SWPSXT                          // swpbx, sxtx
+                   && (insn & (NON_ADDR_OPERATION | BYTE_OPERATION_X)) == 0)    // .a, special case
+                      insn ^= BYTE_OPERATION_X;                                 // make A/L, B/W as ordinary
+
+                op_width = msp430x_opwidth(insn);
+
+                if( opcode_variant(opcode) == V_SWPSXT && op_width == BYTE_OP)         // swpbx, sxtx
+                  strcpy (comm1, _("Illegal A/L, B/W bits setting"));
+
+                cmd_len = msp430x_singleoperand (info, opcode, addr, insn, op1, comm1,
+				                 &repeats);
+                break;
+              case FMT_X_EXCEPTION:
+                cmd_len = msp430x_exception (info, opcode, addr, insn, op1, op2, 
+                                                 comm1, comm2, &op_width);
+                break;
+              case FMT_X_DOUBLE_OPERAND:
+                cmd_len = msp430x_doubleoperand (info, opcode, addr, insn, op1, op2, 
+                                                 comm1, comm2, &op_width, &repeats);
+                break;
+              case FMT_X_EMULATED:
+                cmd_len = msp430x_emulated (info, opcode, addr, insn, op1,
+                                            comm1, &op_width, &repeats);
+                break;
+
+              case FMT_X_ADDRESS:
+                cmd_len = msp430x_address (info, addr, insn, op1, op2,
+                                           comm1, comm2);
+                break;
+              default:
+                break;
+              }
 	}
 
       if (cmd_len)
 	break;
     }
 
-  dinfo[5] = 0;
-
   if (cmd_len < 1)
     {
       /* Unknown opcode, or invalid combination of operands.  */
-      (*prin) (stream, ".word	0x%04x;	????", PS (insn));
+      (*prin) (stream, ".word	0x%04x;	????\t%s%s", PS (insn), comm1, comm2);
       return 2;
     }
 
-  (*prin) (stream, "%s%s", opcode->name, bc);
+    
+  if (repeats)
+    {
+      if (repeats < 0)
+        (*prin) (stream, ".rpt\t#%d\n\t\t\t\t", 0 - repeats);
+      else
+        (*prin) (stream, ".rpt\tr%d\n\t\t\t\t", repeats);
+    }
+  
+  (*prin) (stream, "%s%s", opcode->name, width_modifier[op_width]);
 
   if (*op1)
     (*prin) (stream, "\t%s", op1);
@@ -765,23 +824,11 @@
 
   if (*comm1 || *comm2)
     (*prin) (stream, ";");
-  else if (cycles)
-    {
-      if (*op2)
-	(*prin) (stream, ";");
-      else
-	{
-	  if (strlen (op1) < 7)
-	    (*prin) (stream, ";");
-	  else
-	    (*prin) (stream, "\t;");
-	}
-    }
   if (*comm1)
     (*prin) (stream, "%s", comm1);
   if (*comm1 && *comm2)
-    (*prin) (stream, ",");
+    (*prin) (stream, ", ");
   if (*comm2)
-    (*prin) (stream, " %s", comm2);
+    (*prin) (stream, "%s", comm2);
   return cmd_len;
 }
